<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL Fixture Rotation Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
        
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-tertiary: #1e293b;
            --accent-cyan: #22d3ee;
            --accent-emerald: #10b981;
            --accent-amber: #f59e0b;
            --accent-rose: #f43f5e;
            --accent-violet: #8b5cf6;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --easy-game: #10b981;
            --medium-game: #f59e0b;
            --hard-game: #ef4444;
            --blank-game: #475569;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            background-image: 
                radial-gradient(ellipse at 20% 0%, rgba(34, 211, 238, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(139, 92, 246, 0.08) 0%, transparent 50%);
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.1), rgba(139, 92, 246, 0.1));
            border-radius: 24px;
            border: 1px solid var(--border-color);
        }
        
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }
        
        .section {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, var(--accent-cyan), var(--accent-violet));
            border-radius: 2px;
        }
        
        /* Fixture Grid */
        .fixture-grid {
            overflow-x: auto;
            margin-top: 1rem;
        }
        
        .fixture-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }
        
        .fixture-table th {
            background: var(--bg-tertiary);
            padding: 0.75rem 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .fixture-table td {
            text-align: center;
            padding: 0.5rem;
            border-radius: 6px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .fixture-table td:hover {
            transform: scale(1.1);
            z-index: 5;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .fixture-table .team-name {
            text-align: left;
            padding-left: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            min-width: 120px;
        }
        
        .easy { background: var(--easy-game); color: #000; }
        .medium { background: var(--medium-game); color: #000; }
        .hard { background: var(--hard-game); color: #fff; }
        .blank { background: var(--blank-game); color: #fff; }
        
        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .control-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        input[type="number"], select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            min-width: 120px;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.2);
        }
        
        button {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Outfit', sans-serif;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(34, 211, 238, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 16px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .tab-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            transform: none;
            box-shadow: none;
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            color: white;
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Predictions Tab Styles */
        .predictions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .prediction-card {
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        
        .prediction-card:hover {
            border-color: var(--accent-cyan);
            transform: translateY(-2px);
        }
        
        .prediction-card.winner {
            border-color: var(--accent-emerald);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }
        
        .team-rank-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        
        .rank-badge {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        .rank-badge.gold { background: linear-gradient(135deg, #ffd700, #ffaa00); color: #000; }
        .rank-badge.silver { background: linear-gradient(135deg, #c0c0c0, #a0a0a0); color: #000; }
        .rank-badge.bronze { background: linear-gradient(135deg, #cd7f32, #a0522d); color: #fff; }
        .rank-badge.default { background: var(--bg-secondary); color: var(--text-secondary); }
        
        .points-bar {
            flex: 1;
            height: 24px;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        
        .points-bar-fill {
            height: 100%;
            border-radius: 12px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-violet));
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
        }
        
        .player-breakdown-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .player-breakdown-table th {
            background: var(--bg-secondary);
            padding: 0.75rem 0.5rem;
            text-align: left;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
        }
        
        .player-breakdown-table td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .player-breakdown-table tr:hover {
            background: var(--bg-tertiary);
        }
        
        .player-link {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
            transition: color 0.15s;
        }
        
        .player-link:hover {
            color: var(--accent-cyan);
            text-decoration-style: solid;
        }
        
        .stat-cell {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }
        
        .stat-cell.highlight { color: var(--accent-emerald); font-weight: 600; }
        .stat-cell.negative { color: var(--accent-rose); }
        
        .h2h-matchup-card {
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .h2h-teams {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .h2h-team-name {
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .h2h-vs {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .win-probability-bar {
            height: 32px;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            margin-bottom: 0.75rem;
        }
        
        .win-prob-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            transition: width 0.5s ease;
        }
        
        .win-prob-segment.team1 { background: var(--accent-cyan); color: #000; }
        .win-prob-segment.draw { background: var(--text-muted); color: #fff; }
        .win-prob-segment.team2 { background: var(--accent-violet); color: #fff; }
        
        .fixture-heatmap {
            overflow-x: auto;
        }
        
        .fixture-heatmap-table {
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.75rem;
        }
        
        .fixture-heatmap-table th {
            padding: 0.5rem 0.25rem;
            background: var(--bg-secondary);
            font-weight: 500;
            min-width: 40px;
        }
        
        .fixture-heatmap-table td {
            text-align: center;
            padding: 0.4rem 0.25rem;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .fixture-heatmap-table td:hover {
            transform: scale(1.2);
            z-index: 10;
            position: relative;
        }
        
        .fdr-1 { background: #059669; color: white; }
        .fdr-2 { background: #10b981; color: white; }
        .fdr-3 { background: #f59e0b; color: #000; }
        .fdr-4 { background: #ef4444; color: white; }
        .fdr-5 { background: #7f1d1d; color: white; }
        
        .pl-team-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .pl-team-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }
        
        .pl-team-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .pl-team-rank {
            background: var(--bg-secondary);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .pl-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            text-align: center;
        }
        
        .pl-stat {
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .pl-stat-value {
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .pl-stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .form-indicator {
            display: flex;
            gap: 3px;
            justify-content: center;
            margin-top: 0.5rem;
        }
        
        .form-dot {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            font-size: 0.65rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }
        
        .form-dot.W { background: var(--accent-emerald); color: #000; }
        .form-dot.D { background: var(--accent-amber); color: #000; }
        .form-dot.L { background: var(--accent-rose); color: white; }
        
        /* Overlap Results */
        .overlap-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }
        
        .overlap-card {
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 1.25rem;
            border: 1px solid var(--border-color);
            transition: border-color 0.3s;
        }
        
        .overlap-card:hover {
            border-color: var(--accent-cyan);
        }
        
        .overlap-card .team-pair {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .overlap-card .team-pair span {
            color: var(--accent-cyan);
        }
        
        .overlap-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            text-align: center;
        }
        
        .stat-item {
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value.good { color: var(--easy-game); }
        .stat-value.bad { color: var(--hard-game); }
        .stat-value.neutral { color: var(--medium-game); }
        
        /* Simulation Results */
        .simulation-results {
            max-height: 500px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            border: 1px solid var(--border-color);
            transition: border-color 0.2s;
        }
        
        .result-row:hover {
            border-color: var(--accent-cyan);
        }
        
        .result-rank {
            font-weight: 700;
            color: var(--accent-cyan);
            min-width: 40px;
            font-size: 1rem;
        }
        
        .result-teams {
            flex: 1;
            margin-left: 1rem;
        }
        
        .result-score {
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            background: rgba(16, 185, 129, 0.15);
            color: var(--easy-game);
            text-align: right;
            min-width: 140px;
        }
        
        /* Charts */
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 1rem;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
        }
        
        /* Squad Builder */
        .squad-builder {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 2rem;
        }
        
        .position-section {
            margin-bottom: 1.5rem;
        }
        
        .position-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .position-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .position-badge.gk { background: #eab308; color: #000; }
        .position-badge.def { background: #3b82f6; color: #fff; }
        .position-badge.mid { background: #22c55e; color: #000; }
        .position-badge.fwd { background: #ef4444; color: #fff; }
        
        .player-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .player-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .player-checkbox:hover {
            border-color: var(--accent-cyan);
        }
        
        .player-checkbox.selected {
            background: rgba(34, 211, 238, 0.2);
            border-color: var(--accent-cyan);
        }
        
        .player-checkbox input {
            display: none;
        }
        
        .squad-summary {
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 1.5rem;
            position: sticky;
            top: 2rem;
            height: fit-content;
        }
        
        .squad-counter {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        
        .counter-item {
            text-align: center;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .counter-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .counter-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* Progress */
        .progress-bar {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 1rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-violet));
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 1rem;
        }
        
        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.2s;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
        }
        
        .tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            color: #000;
        }
        
        /* Import subtabs */
        .import-subtab {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        
        .import-subtab:hover {
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }
        
        .import-subtab.active {
            background: var(--accent-cyan);
            color: #000;
            border-color: var(--accent-cyan);
            font-weight: 600;
        }
        
        .import-data-section {
            transition: opacity 0.2s;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Heatmap */
        .heatmap-container {
            overflow-x: auto;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .squad-builder {
                grid-template-columns: 1fr;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 1.75rem;
            }
            
            .section {
                padding: 1rem;
            }
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
        }
        
        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        /* Mock Draft Styles */
        .draft-position-card {
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 1.25rem;
            border: 1px solid var(--border-color);
            margin-bottom: 1rem;
            transition: all 0.3s;
        }
        
        .draft-position-card:hover {
            border-color: var(--accent-cyan);
            transform: translateX(5px);
        }
        
        .draft-position-card.best {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(34, 211, 238, 0.15));
            border-color: var(--easy-game);
        }
        
        .draft-rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-weight: 700;
            font-size: 1rem;
            margin-right: 1rem;
        }
        
        .draft-rank-badge.gold { background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #000; }
        .draft-rank-badge.silver { background: linear-gradient(135deg, #94a3b8, #64748b); color: #fff; }
        .draft-rank-badge.bronze { background: linear-gradient(135deg, #b45309, #92400e); color: #fff; }
        .draft-rank-badge.normal { background: var(--bg-secondary); color: var(--text-secondary); }
        
        .draft-metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .draft-metric {
            text-align: center;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .draft-metric-value {
            font-size: 1.25rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .draft-metric-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 0.25rem;
        }
        
        .pick-strategy-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 0.5rem;
        }
        
        .pick-strategy-table th {
            text-align: left;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.85rem;
        }
        
        .pick-strategy-table td {
            padding: 0.75rem;
            background: var(--bg-tertiary);
            font-size: 0.85rem;
        }
        
        .pick-strategy-table tr:hover td {
            background: var(--bg-secondary);
        }
        
        .availability-bar {
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.25rem;
        }
        
        .availability-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .player-card-mini {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 0.8rem;
            margin: 0.25rem;
            border: 1px solid var(--border-color);
        }
        
        .player-card-mini.high-prob {
            border-color: var(--easy-game);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .player-card-mini.med-prob {
            border-color: var(--accent-amber);
            background: rgba(245, 158, 11, 0.1);
        }
        
        .player-card-mini.low-prob {
            border-color: var(--accent-rose);
            background: rgba(244, 63, 94, 0.1);
        }
        
        /* Draft Sub-tabs */
        .draft-subtabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .draft-subtab {
            padding: 0.75rem 1.25rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .draft-subtab:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--accent-cyan);
        }
        
        .draft-subtab.active {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            color: #000;
            border-color: transparent;
        }
        
        .draft-subtab-content {
            display: none;
        }
        
        .draft-subtab-content.active {
            display: block;
        }
        
        /* Live Draft Styles */
        .live-draft-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }
        
        .start-draft-btn {
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .draft-status-banner {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .draft-status-banner.my-turn {
            border-color: var(--accent-emerald);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(34, 211, 238, 0.1));
            animation: pulse-border 1.5s infinite;
        }
        
        @keyframes pulse-border {
            0%, 100% { box-shadow: 0 0 5px var(--accent-emerald); }
            50% { box-shadow: 0 0 20px var(--accent-emerald); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        .draft-round-info {
            display: flex;
            gap: 1.5rem;
        }
        
        .round-label, .pick-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .round-label { color: var(--accent-cyan); }
        .pick-label { color: var(--accent-violet); }
        
        .draft-turn-info {
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .draft-turn-info.your-turn { color: var(--accent-emerald); }
        .draft-turn-info.opponent-turn { color: var(--accent-amber); }
        
        .live-draft-grid {
            display: grid;
            grid-template-columns: 1fr 350px 300px;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        @media (max-width: 1200px) {
            .live-draft-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .draft-panel {
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 1.25rem;
            border: 1px solid var(--border-color);
        }
        
        .draft-panel h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: var(--accent-cyan);
        }
        
        .player-filters {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .filter-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
        }
        
        .filter-btn:hover, .filter-btn.active {
            background: var(--accent-cyan);
            color: #000;
            border-color: var(--accent-cyan);
        }
        
        .available-players-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .player-draft-card {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .player-draft-card:hover {
            border-color: var(--accent-cyan);
            transform: translateX(5px);
        }
        
        .player-draft-card.recommended {
            border-color: var(--accent-emerald);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .player-draft-card .player-rank {
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
            width: 35px;
        }
        
        .player-draft-card .player-info {
            flex: 1;
            margin-left: 0.75rem;
        }
        
        .player-draft-card .player-name {
            font-weight: 600;
        }
        
        .player-draft-card .player-team {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .player-draft-card .player-pos {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }
        
        .player-draft-card .player-pos.gk { background: #eab308; color: #000; }
        .player-draft-card .player-pos.def { background: #3b82f6; color: #fff; }
        .player-draft-card .player-pos.mid { background: #22c55e; color: #000; }
        .player-draft-card .player-pos.fwd { background: #ef4444; color: #fff; }
        
        .player-draft-card .player-score {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--easy-game);
        }
        
        .player-draft-card .easy-games-badge {
            font-size: 0.7rem;
            background: var(--bg-tertiary);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }
        
        .recommendation-section {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
        }
        
        .recommendation-section h4 {
            font-size: 0.85rem;
            color: var(--accent-amber);
            margin-bottom: 0.5rem;
        }
        
        .my-squad-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .squad-position-box {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.75rem;
        }
        
        .pos-header {
            font-weight: 600;
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 0.5rem;
        }
        
        .pos-header.gk { background: #eab308; color: #000; }
        .pos-header.def { background: #3b82f6; color: #fff; }
        .pos-header.mid { background: #22c55e; color: #000; }
        .pos-header.fwd { background: #ef4444; color: #fff; }
        
        .pos-players {
            font-size: 0.8rem;
            min-height: 60px;
        }
        
        .pos-player {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .squad-stats {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }
        
        .squad-stat {
            text-align: center;
        }
        
        .squad-stat .stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            display: block;
        }
        
        .squad-stat .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: var(--accent-cyan);
        }
        
        .draft-log-section {
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 1.25rem;
            border: 1px solid var(--border-color);
        }
        
        .draft-log-section h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        
        .draft-log {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }
        
        .draft-log-entry {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 1rem;
        }
        
        .draft-log-entry.user-pick {
            background: rgba(16, 185, 129, 0.1);
        }
        
        .draft-log-entry.opponent-pick {
            background: rgba(139, 92, 246, 0.05);
        }
        
        .log-round { color: var(--accent-cyan); min-width: 60px; }
        .log-team { color: var(--text-muted); min-width: 80px; }
        .log-player { flex: 1; }
        
        /* All Positions Comparison */
        .all-pos-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        
        @media (max-width: 1024px) {
            .all-pos-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .pos-comparison-card {
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 1.25rem;
            border: 2px solid var(--border-color);
            transition: all 0.3s;
        }
        
        .pos-comparison-card.best {
            border-color: var(--accent-emerald);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(34, 211, 238, 0.1));
        }
        
        .pos-comparison-card .pos-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .pos-comparison-card .pos-pick-order {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }
        
        .pos-comparison-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .pos-metric {
            text-align: center;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .pos-metric-value {
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .pos-metric-label {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .pos-typical-players {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.75rem;
        }
        
        .pos-typical-players h5 {
            color: var(--accent-amber);
            margin-bottom: 0.5rem;
        }
        
        .best-squads-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        
        @media (max-width: 1024px) {
            .best-squads-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .best-squad-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .best-squad-card h4 {
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            color: var(--accent-cyan);
        }
        
        .best-squad-list {
            font-size: 0.8rem;
        }
        
        .best-squad-item {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        /* All Teams Grid (Live Draft Results) */
        .all-teams-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        
        @media (max-width: 1200px) {
            .all-teams-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .team-result-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 1rem;
            border: 2px solid var(--border-color);
        }
        
        .team-result-card.user-team {
            border-color: var(--accent-emerald);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(34, 211, 238, 0.1));
        }
        
        .team-result-card .team-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .team-result-card .team-name {
            font-weight: 700;
            font-size: 1rem;
        }
        
        .team-result-card .team-score {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: var(--accent-cyan);
        }
        
        .team-result-card .team-players {
            font-size: 0.75rem;
        }
        
        .team-result-card .player-row {
            display: flex;
            justify-content: space-between;
            padding: 0.2rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .team-result-card .player-row:last-child {
            border-bottom: none;
        }
        
        .team-result-card .pos-tag {
            font-size: 0.65rem;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .team-result-card .pos-tag.gk { background: #eab308; color: #000; }
        .team-result-card .pos-tag.def { background: #3b82f6; color: #fff; }
        .team-result-card .pos-tag.mid { background: #22c55e; color: #000; }
        .team-result-card .pos-tag.fwd { background: #ef4444; color: #fff; }
        
        /* Full Draft Controller */
        .pos-filter {
            padding: 0.35rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        .pos-filter:hover { border-color: var(--accent-cyan); }
        .pos-filter.active { background: var(--accent-cyan); color: #000; border-color: var(--accent-cyan); }
        
        .suggestion-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .suggestion-card:hover { border-color: var(--accent-emerald); }
        .suggestion-card.top-pick { border-color: var(--accent-amber); background: rgba(251, 191, 36, 0.1); }
        
        .suggestion-rank { font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 0.75rem; color: var(--text-muted); min-width: 30px; }
        .suggestion-info { flex: 1; }
        .suggestion-name { font-weight: 600; font-size: 0.9rem; }
        .suggestion-meta { font-size: 0.7rem; color: var(--text-muted); }
        .suggestion-score { text-align: right; }
        .suggestion-score-main { font-weight: 700; color: var(--accent-emerald); }
        .suggestion-score-sub { font-size: 0.7rem; color: var(--text-muted); }
        
        .mini-team-card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.5rem;
            border-left: 3px solid var(--border-color);
        }
        .mini-team-card.current { border-left-color: var(--accent-amber); background: rgba(251, 191, 36, 0.1); }
        .mini-team-header { font-weight: 600; font-size: 0.85rem; margin-bottom: 0.25rem; }
        .mini-team-players { font-size: 0.7rem; color: var(--text-muted); }
        
        .available-player-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.2s;
        }
        .available-player-row:hover { background: var(--bg-secondary); }
        
        /* Players Manager */
        .player-manager-card {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .player-manager-card:hover {
            border-color: var(--accent-cyan);
        }
        
        .player-manager-card.always-start {
            border-color: var(--accent-amber);
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.1));
        }
        
        .player-manager-card.unlikely {
            opacity: 0.6;
            border-style: dashed;
        }
        
        .player-manager-card.unlikely:hover {
            opacity: 0.9;
        }
        
        .player-manager-card .player-rank {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 30px;
        }
        
        .player-manager-card .player-info {
            flex: 1;
        }
        
        .player-manager-card .player-name {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .player-manager-card .player-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .player-manager-card .star-toggle {
            font-size: 1.5rem;
            opacity: 0.3;
            transition: all 0.2s;
        }
        
        .player-manager-card.always-start .star-toggle {
            opacity: 1;
            color: var(--accent-amber);
        }
        
        /* Edit mode for fixture grid */
        .fixture-table.edit-mode td:not(.team-name) {
            cursor: pointer;
            position: relative;
        }
        
        .fixture-table.edit-mode td:not(.team-name):hover::after {
            content: '✏️';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.6rem;
        }
        
        .fdr-edit-popup {
            position: fixed;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 0.75rem;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .fdr-edit-popup select {
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        /* Form and Position Badges */
        .form-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .form-badge.form-hot {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-emerald);
            border: 1px solid var(--accent-emerald);
        }
        
        .form-badge.form-cold {
            background: rgba(244, 63, 94, 0.2);
            color: var(--accent-rose);
            border: 1px solid var(--accent-rose);
        }
        
        .form-badge.form-stable {
            background: rgba(148, 163, 184, 0.2);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .pos-badge {
            display: inline-block;
            padding: 0.15rem 0.35rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .pos-badge.pos-GK { background: rgba(245, 158, 11, 0.2); color: var(--accent-amber); }
        .pos-badge.pos-DEF { background: rgba(16, 185, 129, 0.2); color: var(--accent-emerald); }
        .pos-badge.pos-MID { background: rgba(34, 211, 238, 0.2); color: var(--accent-cyan); }
        .pos-badge.pos-FWD { background: rgba(244, 63, 94, 0.2); color: var(--accent-rose); }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.2s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .close-modal {
            position: absolute;
            right: 1rem;
            top: 0.75rem;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            line-height: 1;
        }
        
        .close-modal:hover {
            color: var(--text-primary);
        }
        
        /* Player Comparison Dashboard Styles */
        .compare-slot {
            flex: 1;
            min-width: 200px;
        }
        
        @media (max-width: 900px) {
            #compareSearchSection > div {
                grid-template-columns: repeat(2, 1fr) !important;
            }
        }
        
        @media (max-width: 500px) {
            #compareSearchSection > div {
                grid-template-columns: 1fr !important;
            }
        }
        
        .compare-search-container {
            position: relative;
        }
        
        .compare-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .compare-dropdown-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.15s;
        }
        
        .compare-dropdown-item:hover {
            background: var(--bg-secondary);
        }
        
        .compare-dropdown-item:last-child {
            border-bottom: none;
        }
        
        .compare-player-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 0.5rem;
            border: 2px solid var(--border-color);
            position: relative;
        }
        
        .compare-player-card.selected {
            border-color: var(--accent-cyan);
        }
        
        .compare-remove-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: var(--accent-rose);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            color: white;
            font-size: 0.8rem;
            line-height: 1;
        }
        
        .compare-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
        }
        
        /* Horizontal comparison table styles */
        #compareGrid table {
            border-collapse: collapse;
            width: 100%;
        }
        
        #compareGrid th, #compareGrid td {
            padding: 0.6rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        #compareGrid tr.section-header td {
            font-size: 0.9rem;
            border-bottom: none;
        }
        
        #compareGrid tbody tr:hover {
            background: var(--bg-tertiary);
        }
        
        .compare-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 1.25rem;
            border: 2px solid var(--border-color);
        }
        
        .compare-card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .compare-pos-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
        }
        
        .compare-section {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .compare-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .compare-section-title {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .compare-stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }
        
        .compare-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem 0.5rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 0.85rem;
        }
        
        .compare-stat-label {
            color: var(--text-muted);
        }
        
        .compare-stat-value {
            font-weight: 600;
        }
        
        .compare-stat-value.better {
            color: var(--accent-emerald);
        }
        
        .compare-stat-value.worse {
            color: var(--accent-rose);
        }
        
        .compare-recent-scores {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
        }
        
        .compare-score-badge {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .compare-mini-chart {
            height: 100px;
            margin-top: 0.5rem;
        }
        
        .compare-history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        
        .compare-history-table th,
        .compare-history-table td {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            text-align: center;
        }
        
        .compare-history-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        .compare-history-table .player-col {
            min-width: 150px;
            text-align: left;
        }
        
        /* Loading Animations */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }
        
        @keyframes bounce {
            0%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>⚽ FPL League Analyzer</h1>
            <p class="subtitle">Comprehensive FPL Draft analysis with batch predictions, H2H matchups & squad optimization</p>
        </header>

        <!-- Tabs Navigation -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('leagueimport')">🏆 League Analyzer</button>
            <button class="tab" onclick="showTab('fixtures')">📅 Fixture Grid</button>
            <button class="tab" onclick="showTab('overlap')">🔄 Team Overlaps</button>
            <button class="tab" onclick="showTab('simulation')">🎲 N-K-D Simulation</button>
            <button class="tab" onclick="showTab('charts')">📊 Visualizations</button>
            <button class="tab" onclick="showTab('lineups')">📋 Predicted Lineups</button>
            <button class="tab" onclick="showTab('squad')">👥 Squad Builder</button>
            <button class="tab" onclick="showTab('mockdraft')">🎯 Mock Draft</button>
            <button class="tab" onclick="showTab('players')">⭐ Players Manager</button>
            <button class="tab" onclick="showTab('mysquad')">🏟️ My Squad Analysis</button>
            <button class="tab" onclick="showTab('freeagents')">🆓 Free Agents</button>
        </div>

        <!-- Fixture Grid Tab -->
        <div id="fixtures" class="tab-content">
            <div class="section">
                <h2 class="section-title">Fixture Difficulty Rating (GW21-38)</h2>
                
                <!-- FDR Weight Control -->
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 12px; margin-bottom: 1.5rem; border: 1px solid var(--border-color);">
                    <div style="display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 300px;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-cyan);">
                                🎯 FDR Weight: <span id="weightValue">50%</span> Official FDR
                            </label>
                            <input type="range" id="fdrWeightSlider" min="0" max="100" value="50" 
                                style="width: 100%; accent-color: var(--accent-cyan);"
                                oninput="document.getElementById('weightValue').textContent = this.value + '%'; updateFixtureWeight(this.value / 100);">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">
                                <span>100% Your Analysis</span>
                                <span>100% Official FDR</span>
                            </div>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary); max-width: 400px;">
                            <div style="margin-bottom: 0.5rem;"><strong style="color: var(--accent-amber);">Your Analysis:</strong> Based on team form & your predictions after season started</div>
                            <div><strong style="color: var(--accent-violet);">Official FDR:</strong> Pre-season fixture difficulty ratings (2=Easy, 3=Medium, 4-5=Hard)</div>
                        </div>
                    </div>
                    
                    <!-- Manual Edit Controls -->
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
                        <button onclick="toggleEditMode()" id="editModeBtn" style="padding: 0.5rem 1rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; color: var(--text-primary);">
                            ✏️ Enable Edit Mode
                        </button>
                        <button onclick="clearManualOverrides()" style="padding: 0.5rem 1rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; color: var(--text-primary);">
                            🗑️ Clear Overrides
                        </button>
                        <span id="overrideCount" style="font-size: 0.8rem; color: var(--text-muted);"></span>
                        <div style="flex: 1;"></div>
                        <span style="font-size: 0.75rem; color: var(--text-muted);">💡 Click any cell to manually set FDR (1-5)</span>
                    </div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color easy"></div>
                        <span>Easy Game (≤2.5)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--accent-amber);"></div>
                        <span>Medium (2.5-3.5)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color hard"></div>
                        <span>Hard (>3.5)</span>
                    </div>
                </div>
                <div class="fixture-grid" id="fixtureGrid"></div>
            </div>
            
            <div class="section">
                <h2 class="section-title">Easy Games Summary</h2>
                <div id="easyGamesSummary"></div>
            </div>
        </div>

        <!-- Overlap Analysis Tab -->
        <div id="overlap" class="tab-content">
            <div class="section">
                <h2 class="section-title">Best Team Pairs for Rotation</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Find the best partner team to minimize empty gameweeks (both have hard fixtures) 
                    and maximize coverage (at least one has an easy game).
                </p>
                <div class="overlap-grid" id="overlapResults"></div>
            </div>
            
            <div class="section">
                <h2 class="section-title">Team Synergy Matrix</h2>
                <div class="heatmap-container">
                    <canvas id="synergyHeatmap"></canvas>
                </div>
            </div>
        </div>

        <!-- N-K-D Simulation Tab -->
        <div id="simulation" class="tab-content">
            <div class="section">
                <h2 class="section-title">Player Rotation Simulation</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Find the best player combinations to maximize fixture coverage.
                </p>
                
                <div class="controls" style="flex-wrap: wrap;">
                    <div class="control-group">
                        <label>N - Total Players</label>
                        <input type="number" id="paramN" min="3" max="15" value="11">
                    </div>
                    <div class="control-group">
                        <label>K - Min Easy Players/GW</label>
                        <input type="number" id="paramK" min="1" max="11" value="3">
                    </div>
                    <div class="control-group">
                        <label>D - Max per Team</label>
                        <input type="number" id="paramD" min="1" max="5" value="3">
                    </div>
                    <div class="control-group">
                        <label>Min Success GWs</label>
                        <input type="number" id="paramMinEasy" min="0" max="19" value="10">
                    </div>
                    <div class="control-group">
                        <label>From GW</label>
                        <input type="number" id="paramFromGW" min="21" max="38" value="21" onchange="updateGWRange()">
                    </div>
                    <div class="control-group">
                        <label>To GW</label>
                        <input type="number" id="paramToGW" min="21" max="38" value="38" onchange="updateGWRange()">
                    </div>
                    <button onclick="runSimulation()">🔍 Find Best Combinations</button>
                </div>
                <div id="gwRangeInfo" style="font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 0.5rem;">
                    📅 Analyzing GW21 to GW38 (18 gameweeks)
                </div>
                
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px; margin-bottom: 1rem; font-size: 0.85rem;">
                    <strong style="color: var(--accent-cyan);">Parameters:</strong><br>
                    <span style="color: var(--text-secondary);">
                        • <strong>N</strong> = Select N players total<br>
                        • <strong>K</strong> = Success threshold (≥K players must have easy game per GW)<br>
                        • <strong>D</strong> = Max players from same team (e.g., max 3 Arsenal players)<br>
                        • <strong>Min Success GWs</strong> = How many GWs must meet the K threshold
                    </span>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="simProgress"></div>
                </div>
                
                <div id="simulationStatus" class="loading" style="display: none;"></div>
                <div class="simulation-results" id="simulationResults"></div>
            </div>
        </div>

        <!-- Charts Tab -->
        <div id="charts" class="tab-content">
            <div class="section">
                <h2 class="section-title">Easy Games Distribution by Team</h2>
                <div class="chart-container">
                    <canvas id="easyGamesChart"></canvas>
                </div>
            </div>
            
            <div class="charts-grid">
                <div class="section">
                    <h2 class="section-title">Fixture Difficulty Trend</h2>
                    <div class="chart-container">
                        <canvas id="difficultyTrendChart"></canvas>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Coverage Potential (Teams Needed)</h2>
                    <div class="chart-container">
                        <canvas id="coverageChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2 class="section-title">Team Correlation Analysis</h2>
                <div class="chart-container">
                    <canvas id="correlationChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Predicted Lineups Tab -->
        <div id="lineups" class="tab-content">
            <div class="section">
                <h2 class="section-title">📋 Predicted Starting Lineups</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    View predicted starting lineups with probabilities and injury status for each gameweek.
                </p>
                
                <div class="controls">
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <label style="color: var(--text-secondary);">Gameweek:</label>
                        <select id="lineupsGwSelect" onchange="loadPredictedLineups()" style="padding: 0.5rem; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 8px;">
                            <option value="22">GW22 (Next)</option>
                            <option value="23">GW23</option>
                            <option value="24">GW24</option>
                            <option value="25">GW25</option>
                            <option value="26">GW26</option>
                        </select>
                        <button class="btn-primary" onclick="loadPredictedLineups()">
                            Load Predictions
                        </button>
                        <button class="btn-secondary" onclick="refreshPredictedLineups()">
                            🔄 Refresh Data
                        </button>
                    </div>
                </div>
                
                <div id="lineupsStatus" style="margin-top: 1rem;"></div>
                
                <div id="lineupsGrid" style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 1.5rem;">
                    <!-- Lineups will be populated here -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 3rem; color: var(--text-muted);">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">📋</div>
                        <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">No lineup predictions loaded</div>
                        <div>Select a gameweek to see predicted starting lineups with probabilities</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Squad Builder Tab -->
        <div id="squad" class="tab-content">
            <div class="section">
                <h2 class="section-title">🤖 Auto Squad Optimizer</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Automatically find the best 15-player squad for fixture coverage.<br>
                    <strong>Constraints:</strong> Max 2 from same team per position, Max 3 from same team total.<br>
                    <strong>Priority:</strong> DEF & FWD weighted higher (more affected by easy games).
                </p>
                
                <div class="controls" style="margin-bottom: 1.5rem;">
                    <div class="control-group">
                        <label>DEF/FWD Weight</label>
                        <input type="number" id="defFwdWeight" min="1" max="5" value="3" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>MID Weight</label>
                        <input type="number" id="midWeight" min="1" max="5" value="2" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>GK Weight</label>
                        <input type="number" id="gkWeight" min="1" max="5" value="1" step="0.5">
                    </div>
                    <button onclick="runAutoOptimizer()">🚀 Find Optimal Squad</button>
                </div>
                
                <div id="optimizerResults"></div>
            </div>

            <div class="section">
                <h2 class="section-title">📋 Manual Squad Builder</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Or build manually: 2 GK, 5 DEF, 5 MID, 3 FWD<br>
                    Playing formation: 1 GK, 3-5 DEF, 3-5 MID, 1-3 FWD (max 11)
                </p>
                
                <div class="squad-builder">
                    <div class="team-selection" id="teamSelection"></div>
                    <div class="squad-summary" id="squadSummary">
                        <h3 style="margin-bottom: 1rem;">Squad Overview</h3>
                        <div class="squad-counter">
                            <div class="counter-item">
                                <div class="counter-value" id="gkCount">0/2</div>
                                <div class="counter-label">Goalkeepers</div>
                            </div>
                            <div class="counter-item">
                                <div class="counter-value" id="defCount">0/5</div>
                                <div class="counter-label">Defenders</div>
                            </div>
                            <div class="counter-item">
                                <div class="counter-value" id="midCount">0/5</div>
                                <div class="counter-label">Midfielders</div>
                            </div>
                            <div class="counter-item">
                                <div class="counter-value" id="fwdCount">0/3</div>
                                <div class="counter-label">Forwards</div>
                            </div>
                        </div>
                        <div class="counter-item" style="margin-bottom: 1rem;">
                            <div class="counter-value" id="totalCount">0/15</div>
                            <div class="counter-label">Total Players</div>
                        </div>
                        <button onclick="analyzeSquad()">Analyze Squad Coverage</button>
                        <div id="squadAnalysis" style="margin-top: 1rem;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mock Draft Tab -->
        <div id="mockdraft" class="tab-content">
            <!-- Sub-tabs for Mock Draft -->
            <div class="draft-subtabs">
                <button class="draft-subtab active" onclick="showDraftSubtab('montecarlo')">📊 Monte Carlo Analysis</button>
                <button class="draft-subtab" onclick="showDraftSubtab('livedraft')">🎮 Live Draft Simulator</button>
                <button class="draft-subtab" onclick="showDraftSubtab('allpositions')">🏆 All Positions Comparison</button>
                <button class="draft-subtab" onclick="showDraftSubtab('fulldraft')">🧠 Full Draft Controller</button>
            </div>
            
            <!-- Monte Carlo Sub-tab -->
            <div id="montecarlo" class="draft-subtab-content active">
                <div class="section">
                    <h2 class="section-title">Monte Carlo Draft Simulation</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        Simulate thousands of drafts to find optimal strategies.<br>
                        <strong>Model:</strong> Early rounds use higher variance (σ×2) - opponents are more unpredictable for top picks.<br>
                        <strong>Strategy:</strong> FWD/MID by rank priority, DEF/GK optimized for fixture rotation (N-K-D).
                    </p>
                    
                    <div class="controls" style="flex-wrap: wrap;">
                        <div class="control-group">
                            <label>Draft Position</label>
                            <select id="draftPosition">
                                <option value="all">All Positions (1-8)</option>
                                <option value="1">Position 1</option>
                                <option value="2">Position 2</option>
                                <option value="3">Position 3</option>
                                <option value="4">Position 4</option>
                                <option value="5">Position 5</option>
                                <option value="6">Position 6</option>
                                <option value="7">Position 7</option>
                                <option value="8">Position 8</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Opponent Strategies</label>
                            <select id="opponentStrategy">
                                <option value="mixed">Mixed - Realistic</option>
                                <option value="allRank">All Rank-Based</option>
                                <option value="allScore">All Score-Chasers</option>
                                <option value="allFwd">All FWD Hunters</option>
                                <option value="allTopTeams">All Big Team Bias</option>
                                <option value="scoreHeavy">Mixed - Score Heavy</option>
                                <option value="fwdHeavy">Mixed - FWD Heavy</option>
                                <option value="topTeamHeavy">Mixed - Big Team Heavy</option>
                                <option value="vsScore">You vs Score Chasers</option>
                                <option value="vsFwd">You vs FWD Hunters</option>
                                <option value="vsTopTeams">You vs Big Team Fans</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Simulations</label>
                            <select id="numSimulations">
                                <option value="100">100 (Fast)</option>
                                <option value="1000">1,000</option>
                                <option value="5000" selected>5,000</option>
                                <option value="10000">10,000 (Slow)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Base Variance (σ)</label>
                            <input type="number" id="opponentSigma" min="1" max="50" value="12" step="1">
                        </div>
                        <div class="control-group">
                            <label>Early Round Multiplier</label>
                            <input type="number" id="earlyRoundMultiplier" min="1" max="5" value="2.5" step="0.5">
                        </div>
                        <button onclick="runMockDraft()">🎯 Run Simulation</button>
                    </div>
                    
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px; margin-bottom: 1rem; font-size: 0.85rem;">
                        <strong style="color: var(--accent-cyan);">Draft Goals:</strong><br>
                        <span style="color: var(--text-secondary);">
                            • <strong>FWD:</strong> 2 from top 10 forwards<br>
                            • <strong>MID:</strong> 1 from top 5 midfielders<br>
                            • <strong>DEF:</strong> 5 from optimal N-K-D combination (N=5, K=3, D=2)<br>
                            • <strong>GK:</strong> 2 from optimal rotation pair (N=2, K=1, D=1)
                        </span>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress-fill" id="draftProgress"></div>
                    </div>
                    
                    <div id="draftStatus" class="loading" style="display: none;"></div>
                </div>
                
                <div class="section" id="draftResultsSection" style="display: none;">
                    <h2 class="section-title">Draft Position Rankings</h2>
                    <div id="draftPositionRankings"></div>
                </div>
                
                <div class="section" id="draftStrategySection" style="display: none;">
                    <h2 class="section-title">Optimal Pick Strategy</h2>
                    <div id="draftStrategy"></div>
                </div>
                
                <div class="section" id="playerAvailabilitySection" style="display: none;">
                    <h2 class="section-title">Player Availability Probability</h2>
                    <div id="playerAvailability"></div>
                </div>
            </div>
            
            <!-- Live Draft Sub-tab -->
            <div id="livedraft" class="draft-subtab-content">
                <div class="section">
                    <h2 class="section-title">🎮 Interactive Live Draft</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        Simulate a real draft in real-time! Pick your players and get AI recommendations.
                    </p>
                    
                    <div class="live-draft-controls">
                        <button onclick="startLiveDraft()" class="start-draft-btn" id="startDraftBtn">🚀 Start New Draft</button>
                        <button onclick="startLiveDraft(true)" class="start-draft-btn" style="background: linear-gradient(135deg, var(--accent-amber), var(--accent-rose));">🎲 Random Position</button>
                        <div class="control-group" style="margin-left: 1rem;">
                            <label>Choose Position</label>
                            <select id="liveDraftPosition">
                                <option value="1">Position 1</option>
                                <option value="2">Position 2</option>
                                <option value="3">Position 3</option>
                                <option value="4">Position 4</option>
                                <option value="5">Position 5</option>
                                <option value="6">Position 6</option>
                                <option value="7">Position 7</option>
                                <option value="8">Position 8</option>
                            </select>
                        </div>
                        <div class="control-group" style="margin-left: 1rem;">
                            <label>Score Weight (vs Rank)</label>
                            <select id="liveScoreWeight">
                                <option value="0">0% - Pure Rank</option>
                                <option value="25">25% Score</option>
                                <option value="50" selected>50% Score</option>
                                <option value="75">75% Score</option>
                                <option value="100">100% - Pure Score</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.8rem;">
                        <strong style="color: var(--accent-amber);">Score Weight:</strong> 
                        <span style="color: var(--text-secondary);">
                            0% = Opponents pick by your rank only | 
                            100% = Opponents pick by player score only (ignores your rankings)
                        </span>
                    </div>
                    
                    <div id="liveDraftArea" style="display: none;">
                        <!-- Draft Status Banner -->
                        <div class="draft-status-banner" id="draftStatusBanner">
                            <div class="draft-round-info">
                                <span class="round-label">Round <span id="currentRound">1</span>/15</span>
                                <span class="pick-label">Pick #<span id="currentPick">1</span></span>
                            </div>
                            <div class="draft-turn-info" id="turnInfo">
                                Waiting to start...
                            </div>
                        </div>
                        
                        <!-- Main Draft Grid -->
                        <div class="live-draft-grid">
                            <!-- Available Players -->
                            <div class="draft-panel available-panel">
                                <h3>📋 Available Players</h3>
                                <div class="player-filters">
                                    <button class="filter-btn active" data-filter="all" onclick="filterPlayers('all')">All</button>
                                    <button class="filter-btn" data-filter="GK" onclick="filterPlayers('GK')">GK</button>
                                    <button class="filter-btn" data-filter="DEF" onclick="filterPlayers('DEF')">DEF</button>
                                    <button class="filter-btn" data-filter="MID" onclick="filterPlayers('MID')">MID</button>
                                    <button class="filter-btn" data-filter="FWD" onclick="filterPlayers('FWD')">FWD</button>
                                </div>
                                <div class="available-players-list" id="availablePlayersList"></div>
                            </div>
                            
                            <!-- Recommendations Panel -->
                            <div class="draft-panel recommendations-panel">
                                <h3>💡 AI Recommendations</h3>
                                <div id="recommendationsContent">
                                    <div class="recommendation-section">
                                        <h4>🎯 Top Pick</h4>
                                        <div id="topRecommendation"></div>
                                    </div>
                                    <div class="recommendation-section">
                                        <h4>📊 By Position Need</h4>
                                        <div id="positionRecommendations"></div>
                                    </div>
                                    <div class="recommendation-section">
                                        <h4>🔄 Fixture Coverage</h4>
                                        <div id="fixtureRecommendations"></div>
                                    </div>
                                    <div class="recommendation-section">
                                        <h4>⚠️ Risk Analysis</h4>
                                        <div id="riskAnalysis"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- My Squad Panel -->
                            <div class="draft-panel squad-panel">
                                <h3>👥 My Squad</h3>
                                <div class="my-squad-grid">
                                    <div class="squad-position-box">
                                        <div class="pos-header gk">GK <span id="myGKCount">0/2</span></div>
                                        <div class="pos-players" id="myGKPlayers"></div>
                                    </div>
                                    <div class="squad-position-box">
                                        <div class="pos-header def">DEF <span id="myDEFCount">0/5</span></div>
                                        <div class="pos-players" id="myDEFPlayers"></div>
                                    </div>
                                    <div class="squad-position-box">
                                        <div class="pos-header mid">MID <span id="myMIDCount">0/5</span></div>
                                        <div class="pos-players" id="myMIDPlayers"></div>
                                    </div>
                                    <div class="squad-position-box">
                                        <div class="pos-header fwd">FWD <span id="myFWDCount">0/3</span></div>
                                        <div class="pos-players" id="myFWDPlayers"></div>
                                    </div>
                                </div>
                                <div class="squad-stats">
                                    <div class="squad-stat">
                                        <span class="stat-label">Total Score</span>
                                        <span class="stat-value" id="myTotalScore">0</span>
                                    </div>
                                    <div class="squad-stat">
                                        <span class="stat-label">GW Coverage</span>
                                        <span class="stat-value" id="myGWCoverage">0/19</span>
                                    </div>
                                    <div class="squad-stat">
                                        <span class="stat-label">Unique Teams</span>
                                        <span class="stat-value" id="myUniqueTeams">0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Draft Log -->
                        <div class="draft-log-section">
                            <h3>📜 Draft Log</h3>
                            <div class="draft-log" id="draftLog"></div>
                        </div>
                        
                        <!-- All Teams Results (shown after draft complete) -->
                        <div id="allTeamsResults" style="display: none; margin-top: 1.5rem;">
                            <div class="section" style="margin: 0; padding: 1.5rem;">
                                <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">🏆 Final Draft Results - All 8 Teams</h3>
                                <div id="allTeamsGrid" class="all-teams-grid"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- All Positions Comparison Sub-tab -->
            <div id="allpositions" class="draft-subtab-content">
                <div class="section">
                    <h2 class="section-title">🏆 All Draft Positions Comparison</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        Quick comparison of expected outcomes for all 8 draft positions.
                    </p>
                    <button onclick="runAllPositionsComparison()">📊 Generate Comparison (1000 sims each)</button>
                    <div class="progress-bar" style="margin-top: 1rem;">
                        <div class="progress-fill" id="allPosProgress"></div>
                    </div>
                    <div id="allPosStatus" class="loading" style="display: none;"></div>
                </div>
                
                <div class="section" id="allPosResultsSection" style="display: none;">
                    <div id="allPositionsResults"></div>
                </div>
                
                <div class="section" id="bestSquadsSection" style="display: none;">
                    <h2 class="section-title">🌟 Best Teams by Position</h2>
                    <div id="bestSquadsGrid"></div>
                </div>
            </div>
            
            <!-- Full Draft Controller Sub-tab -->
            <div id="fulldraft" class="draft-subtab-content">
                <div class="section">
                    <h2 class="section-title">🧠 Full Draft Controller - AI Suggestions</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        Control all 8 teams' picks with AI-powered suggestions optimized for <strong>Rank + Score + N-K-D fixture coverage</strong>.
                    </p>
                    
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px; margin-bottom: 1rem;">
                        <div style="display: flex; gap: 2rem; flex-wrap: wrap; align-items: center;">
                            <div>
                                <strong style="color: var(--accent-cyan);">Target N-K-D:</strong>
                                <span style="color: var(--text-secondary);">15 players, ≥11 easy/GW, max 3/team</span>
                            </div>
                            <div>
                                <label style="margin-right: 0.5rem; color: var(--text-secondary);">Rank Weight:</label>
                                <input type="range" id="fullDraftRankWeight" min="0" max="100" value="60" style="width: 100px; vertical-align: middle;">
                                <span id="fullDraftRankWeightVal" style="color: var(--accent-amber);">60%</span>
                            </div>
                            <button onclick="startFullDraft()" style="padding: 0.75rem 1.5rem; background: var(--accent-emerald); border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                🚀 Start New Draft
                            </button>
                            <button onclick="autoCompleteDraft()" id="autoCompleteBtn" style="padding: 0.75rem 1.5rem; background: var(--accent-violet); border: none; border-radius: 8px; cursor: pointer; font-weight: 600; display: none;">
                                ⚡ Auto-Complete
                            </button>
                        </div>
                    </div>
                    
                    <!-- Draft Status -->
                    <div id="fullDraftStatus" style="display: none;">
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1.5rem;">
                            <!-- Left: Current Pick -->
                            <div>
                                <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 10px; margin-bottom: 1rem;">
                                    <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-cyan); margin-bottom: 0.5rem;">
                                        <span id="fullDraftRound">Round 1</span> - <span id="fullDraftTeam">Team 1</span>'s Pick
                                    </div>
                                    <div style="font-size: 0.85rem; color: var(--text-muted);">
                                        Pick #<span id="fullDraftPickNum">1</span> of 120
                                    </div>
                                </div>
                                
                                <!-- AI Suggestions -->
                                <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(34, 211, 238, 0.1)); padding: 1rem; border-radius: 10px; border: 1px solid var(--accent-emerald); margin-bottom: 1rem;">
                                    <h4 style="color: var(--accent-emerald); margin-bottom: 0.75rem;">🤖 AI Top 5 Suggestions</h4>
                                    <div id="fullDraftSuggestions"></div>
                                </div>
                                
                                <!-- All Available Players -->
                                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px;">
                                    <h4 style="color: var(--text-secondary); margin-bottom: 0.75rem;">All Available Players</h4>
                                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.75rem; flex-wrap: wrap;">
                                        <button onclick="filterFullDraft('all')" class="pos-filter active" data-pos="all">All</button>
                                        <button onclick="filterFullDraft('FWD')" class="pos-filter" data-pos="FWD">FWD</button>
                                        <button onclick="filterFullDraft('MID')" class="pos-filter" data-pos="MID">MID</button>
                                        <button onclick="filterFullDraft('DEF')" class="pos-filter" data-pos="DEF">DEF</button>
                                        <button onclick="filterFullDraft('GK')" class="pos-filter" data-pos="GK">GK</button>
                                    </div>
                                    <div id="fullDraftAvailable" style="max-height: 400px; overflow-y: auto;"></div>
                                </div>
                            </div>
                            
                            <!-- Right: All 8 Teams' Squads -->
                            <div>
                                <h4 style="color: var(--text-secondary); margin-bottom: 0.75rem;">📋 All Teams' Squads</h4>
                                <div id="fullDraftTeams" style="display: flex; flex-direction: column; gap: 0.75rem; max-height: 700px; overflow-y: auto;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Final Results -->
                    <div id="fullDraftResults" style="display: none;">
                        <div class="section">
                            <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">🏆 Draft Complete!</h3>
                            <div id="fullDraftFinalResults"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Players Manager Tab -->
        <div id="players" class="tab-content">
            <div class="section">
                <h2 class="section-title">⭐ Players Manager - Always Start Tokens</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Mark players as "Always Start" - these premium players perform well regardless of fixture difficulty.
                    They will be prioritized in draft simulations and squad building.
                </p>
                
                <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
                    <div class="control-group">
                        <label>Filter by Position</label>
                        <select id="playerFilterPos" onchange="renderPlayersManager()">
                            <option value="all">All Positions</option>
                            <option value="GK">Goalkeepers</option>
                            <option value="DEF">Defenders</option>
                            <option value="MID">Midfielders</option>
                            <option value="FWD">Forwards</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Filter by Team</label>
                        <select id="playerFilterTeam" onchange="renderPlayersManager()">
                            <option value="all">All Teams</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Search Player</label>
                        <input type="text" id="playerSearch" placeholder="Search..." oninput="renderPlayersManager()" style="padding: 0.5rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary);">
                    </div>
                    <div class="control-group" style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="checkbox" id="showUnlikelyPlayers" onchange="renderPlayersManager()" style="accent-color: var(--accent-rose); width: 18px; height: 18px;">
                        <label for="showUnlikelyPlayers" style="cursor: pointer; font-size: 0.85rem; color: var(--accent-rose);">⚠️ Show Unlikely</label>
                    </div>
                    <div style="display: flex; align-items: flex-end; gap: 0.5rem;">
                        <button onclick="selectTopPlayers(10)" style="padding: 0.5rem 1rem; background: var(--accent-emerald); border: none; border-radius: 6px; cursor: pointer; color: #000;">
                            ⭐ Top 10
                        </button>
                        <button onclick="clearAlwaysStart()" style="padding: 0.5rem 1rem; background: var(--accent-rose); border: none; border-radius: 6px; cursor: pointer; color: #fff;">
                            Clear All
                        </button>
                    </div>
                </div>
                
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                    <span style="color: var(--accent-amber); font-weight: 600;">⭐ Always Start Players:</span>
                    <span id="alwaysStartCount">0</span> selected
                    <div id="alwaysStartList" style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);"></div>
                </div>
                
                <div id="playersManagerGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 0.75rem; max-height: 600px; overflow-y: auto; padding-right: 0.5rem;"></div>
            </div>
        </div>
        
        <!-- My Squad Analysis Tab -->
        <div id="mysquad" class="tab-content">
            <div class="section">
                <h2 class="section-title">🏟️ My Squad Analysis</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Input your current FPL squad to get fixture analysis, N-K-D scores, and improvement suggestions.
                </p>
                
                <!-- Squad Input Section -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                    <!-- Goalkeepers -->
                    <div class="stat-card" style="border-left: 3px solid var(--accent-amber);">
                        <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">🧤 Goalkeepers (2)</h3>
                        <div id="squadGK" class="squad-position-inputs"></div>
                    </div>
                    
                    <!-- Defenders -->
                    <div class="stat-card" style="border-left: 3px solid var(--accent-emerald);">
                        <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">🛡️ Defenders (5)</h3>
                        <div id="squadDEF" class="squad-position-inputs"></div>
                    </div>
                    
                    <!-- Midfielders -->
                    <div class="stat-card" style="border-left: 3px solid var(--accent-cyan);">
                        <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">⚡ Midfielders (5)</h3>
                        <div id="squadMID" class="squad-position-inputs"></div>
                    </div>
                    
                    <!-- Forwards -->
                    <div class="stat-card" style="border-left: 3px solid var(--accent-rose);">
                        <h3 style="color: var(--accent-rose); margin-bottom: 1rem;">⚽ Forwards (3)</h3>
                        <div id="squadFWD" class="squad-position-inputs"></div>
                    </div>
                </div>
                
                <!-- Quick Load -->
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <button onclick="loadUserSquadFromImage()" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan)); border: none; border-radius: 8px; cursor: pointer; color: #fff; font-weight: 600;">
                        📷 Load Your Squad (from image)
                    </button>
                    <button onclick="analyzeMySquad()" style="padding: 0.75rem 1.5rem; background: var(--accent-emerald); border: none; border-radius: 8px; cursor: pointer; color: #000; font-weight: 600;">
                        🔍 Analyze Squad
                    </button>
                    <button onclick="clearMySquad()" style="padding: 0.75rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; color: var(--text-primary);">
                        🗑️ Clear
                    </button>
                </div>
                
                <!-- Analysis Results -->
                <div id="squadAnalysisResults" style="display: none;">
                    <!-- Summary Stats -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                        <div class="stat-card" style="text-align: center; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(6, 182, 212, 0.1));">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--accent-emerald);" id="squadTotalScore">-</div>
                            <div style="font-size: 0.8rem; color: var(--text-muted);">Total Score</div>
                        </div>
                        <div class="stat-card" style="text-align: center; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--accent-violet);" id="squadAvgRank">-</div>
                            <div style="font-size: 0.8rem; color: var(--text-muted);">Avg Rank</div>
                        </div>
                        <div class="stat-card" style="text-align: center; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(251, 146, 60, 0.1));">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--accent-amber);" id="squadEasyGWs">-</div>
                            <div style="font-size: 0.8rem; color: var(--text-muted);">GWs with 11+ Easy</div>
                        </div>
                        <div class="stat-card" style="text-align: center; background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(16, 185, 129, 0.1));">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--accent-cyan);" id="squadAvgEasy">-</div>
                            <div style="font-size: 0.8rem; color: var(--text-muted);">Avg Easy/GW</div>
                        </div>
                    </div>
                    
                    <!-- N-K-D Analysis -->
                    <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                        <h3 style="color: var(--accent-violet); margin-bottom: 1rem;">📊 N-K-D Analysis (15-11-3)</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700;" id="nkdN">15</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">N (Players)</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700;" id="nkdK">-</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">K (Min Easy/GW)</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700;" id="nkdD">-</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">D (Max/Team)</div>
                            </div>
                        </div>
                        <div id="nkdVerdict" style="padding: 1rem; border-radius: 8px; margin-bottom: 1rem;"></div>
                    </div>
                    
                    <!-- Fixture Coverage Heatmap -->
                    <div class="stat-card" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">📅 Fixture Coverage by Gameweek</h3>
                        <div id="squadFixtureCoverage" style="overflow-x: auto;"></div>
                    </div>
                    
                    <!-- DEF Specific Analysis -->
                    <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-emerald);">
                        <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">🛡️ Defenders N-K-D Analysis (5-3-2)</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                            For optimal rotation, you want at least 3 defenders with easy games each GW.
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700;" id="defN">5</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Defenders</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700;" id="defSuccessGWs">-</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">GWs with 3+ Easy</div>
                            </div>
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700;" id="defMaxTeam">-</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Max from 1 Team</div>
                            </div>
                        </div>
                        <div id="defCoverageChart" style="margin-bottom: 1rem;"></div>
                        <div id="defVerdict" style="padding: 1rem; border-radius: 8px;"></div>
                    </div>
                    
                    <!-- Team Distribution -->
                    <div class="stat-card" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">🏢 Team Distribution</h3>
                        <div id="teamDistribution" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 0.75rem;"></div>
                    </div>
                    
                    <!-- Improvement Suggestions -->
                    <div class="stat-card" style="border: 2px solid var(--accent-rose);">
                        <h3 style="color: var(--accent-rose); margin-bottom: 1rem;">💡 Improvement Suggestions</h3>
                        <div id="improvementSuggestions"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Free Agents Tab -->
        <div id="freeagents" class="tab-content">
            <div class="section">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;">
                    <div>
                        <h2 class="section-title" style="margin-bottom: 0.5rem;">🆓 Free Agents Analyzer</h2>
                        <p style="color: var(--text-secondary);">
                            Find the best available players with advanced score distributions and form analysis.
                        </p>
                    </div>
                    <button onclick="openCompareModal()" style="padding: 0.6rem 1rem; background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan)); border: none; border-radius: 8px; cursor: pointer; color: white; font-weight: 600; white-space: nowrap;">
                        📊 Open Player Comparison
                    </button>
                </div>
                
                <div class="controls" style="flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;">
                    <div class="control-group">
                        <label>Gameweek</label>
                        <select id="faGameweek" onchange="loadFreeAgents()">
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Position Filter</label>
                        <select id="faPosition" onchange="loadFreeAgents()">
                            <option value="">All Positions</option>
                            <option value="GK">Goalkeepers</option>
                            <option value="DEF">Defenders</option>
                            <option value="MID">Midfielders</option>
                            <option value="FWD">Forwards</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Sort By</label>
                        <select id="faSortBy" onchange="sortFreeAgents()">
                            <option value="expected">Expected Points</option>
                            <option value="upside">Upside (90th %)</option>
                            <option value="floor">Floor (10th %)</option>
                            <option value="form">Form (EWMA)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>View Mode</label>
                        <select id="faViewMode" onchange="renderFreeAgentsTable()">
                            <option value="cards">📊 Detailed Cards</option>
                            <option value="table">📋 Compact Table</option>
                        </select>
                    </div>
                    <button onclick="loadFreeAgents()" style="align-self: flex-end;">🔄 Refresh</button>
                    <button onclick="showOwnershipDebug()" style="align-self: flex-end; background: var(--accent-amber);">🔍 Ownership Debug</button>
                </div>
                
                <!-- Quick Position Cards -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem;">
                    <div class="stat-card" style="border-left: 3px solid var(--accent-amber); cursor: pointer;" onclick="document.getElementById('faPosition').value='GK'; loadFreeAgents();">
                        <h4 style="color: var(--accent-amber); margin-bottom: 0.5rem;">🧤 Best GK</h4>
                        <div id="faBestGK" style="font-size: 0.9rem;">-</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid var(--accent-emerald); cursor: pointer;" onclick="document.getElementById('faPosition').value='DEF'; loadFreeAgents();">
                        <h4 style="color: var(--accent-emerald); margin-bottom: 0.5rem;">🛡️ Best DEF</h4>
                        <div id="faBestDEF" style="font-size: 0.9rem;">-</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid var(--accent-cyan); cursor: pointer;" onclick="document.getElementById('faPosition').value='MID'; loadFreeAgents();">
                        <h4 style="color: var(--accent-cyan); margin-bottom: 0.5rem;">⚡ Best MID</h4>
                        <div id="faBestMID" style="font-size: 0.9rem;">-</div>
                    </div>
                    <div class="stat-card" style="border-left: 3px solid var(--accent-rose); cursor: pointer;" onclick="document.getElementById('faPosition').value='FWD'; loadFreeAgents();">
                        <h4 style="color: var(--accent-rose); margin-bottom: 0.5rem;">⚽ Best FWD</h4>
                        <div id="faBestFWD" style="font-size: 0.9rem;">-</div>
                    </div>
                </div>
                
                <!-- Differentials Section -->
                <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                    <h3 style="color: var(--accent-violet); margin-bottom: 1rem;">🚀 High-Upside Differentials</h3>
                    <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                        Players with high ceiling potential (sorted by 90th percentile score)
                    </p>
                    <div id="faDifferentials" style="overflow-x: auto;"></div>
                </div>
                
                <!-- Main Free Agents Table -->
                <div class="stat-card">
                    <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">📋 All Free Agents</h3>
                    <div id="faLoading" class="loading" style="display: none;">Loading free agents...</div>
                    <div id="faTable" style="overflow-x: auto;"></div>
                </div>
                
                <!-- Player Distribution Modal -->
                <div id="playerDistModal" class="modal" style="display: none;">
                    <div class="modal-content" style="max-width: 800px;">
                        <span class="close-modal" onclick="closeDistModal()">&times;</span>
                        <h3 id="distModalTitle" style="margin-bottom: 1rem;">Score Distribution</h3>
                        <div id="distModalContent">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                                <div class="stat-card">
                                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Expected Points</div>
                                    <div id="distExpected" style="font-size: 1.5rem; font-weight: 600; color: var(--accent-cyan);">-</div>
                                </div>
                                <div class="stat-card">
                                    <div style="font-size: 0.8rem; color: var(--text-secondary);">80% Range</div>
                                    <div id="distCI80" style="font-size: 1.5rem; font-weight: 600; color: var(--accent-emerald);">-</div>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                                <div class="stat-card">
                                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Floor (15%)</div>
                                    <div id="distFloor" style="font-size: 1.2rem; color: var(--accent-rose);">-</div>
                                </div>
                                <div class="stat-card">
                                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Median</div>
                                    <div id="distMedian" style="font-size: 1.2rem; color: var(--text-primary);">-</div>
                                </div>
                                <div class="stat-card">
                                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Upside (85%)</div>
                                    <div id="distUpside" style="font-size: 1.2rem; color: var(--accent-emerald);">-</div>
                                </div>
                                <div class="stat-card">
                                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Games</div>
                                    <div id="distGames" style="font-size: 1.2rem; color: var(--text-secondary);">-</div>
                                </div>
                            </div>
                            
                            <h4 style="margin-bottom: 0.75rem; color: var(--text-secondary);">Score Probability Distribution</h4>
                            <div style="height: 220px; position: relative; margin-bottom: 1.5rem;">
                                <canvas id="distChartCanvas"></canvas>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                                <div>
                                    <h4 style="margin-bottom: 0.75rem; color: var(--text-secondary);">Form Analysis</h4>
                                    <div id="distForm" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem;"></div>
                                </div>
                                <div>
                                    <h4 style="margin-bottom: 0.75rem; color: var(--text-secondary);">Recent Scores</h4>
                                    <div id="distRecentScores" style="display: flex; gap: 0.5rem; flex-wrap: wrap;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>

        <!-- League Import Tab (Default) -->
        <div id="leagueimport" class="tab-content active">
            <div class="section">
                <h2 class="section-title">🏆 FPL League Analyzer</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Import your FPL Draft league data to analyze all teams, compare squads, and get insights.
                </p>

                <!-- Auto-Import from Server -->
                <div id="serverDataStatus" style="display: none; background: rgba(139, 92, 246, 0.15); border: 2px solid var(--accent-violet); border-radius: 12px; padding: 1.25rem; margin-bottom: 1.5rem;">
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                        <div>
                            <span style="color: var(--accent-violet); font-weight: 700; font-size: 1.1rem;">📁 Server Data Available</span>
                            <div id="serverFileInfo" style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 0.25rem;"></div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="loadFromServer()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan)); font-weight: 600;">
                                🚀 Auto-Load Latest
                            </button>
                            <button onclick="refreshServerFiles()" style="padding: 0.6rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color);">
                                🔄
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Saved Data Status -->
                <div id="savedDataStatus" style="display: none; background: rgba(16, 185, 129, 0.1); border: 1px solid var(--accent-emerald); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem;"></div>

                <!-- Step 1: Bookmarklet -->
                <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-cyan);">
                    <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">📚 Step 1: Install Bookmarklet</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;">
                        Drag the button below to your bookmarks bar.
                    </p>
                    <div style="background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px; text-align: center; margin-bottom: 1rem;">
                        <a id="fplBookmarklet" href="#" style="display: inline-block; padding: 1rem 2rem; background: linear-gradient(135deg, var(--accent-emerald), var(--accent-cyan)); color: #000; font-weight: 700; border-radius: 10px; text-decoration: none; font-size: 1.1rem; cursor: grab;">
                            📥 FPL Data Fetcher
                        </a>
                        <p style="color: var(--text-muted); font-size: 0.8rem; margin-top: 0.75rem;">
                            ↑ Drag this to your bookmarks bar
                        </p>
                    </div>
                    <div style="background: rgba(239, 68, 68, 0.15); border: 2px solid var(--accent-rose); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <p style="color: var(--accent-rose); font-size: 0.95rem; margin: 0; font-weight: 600;">
                            🚨 <strong>CRITICAL:</strong> The bookmarklet only works when clicked on <u>draft.premierleague.com</u>!
                        </p>
                        <ol style="color: var(--text-secondary); font-size: 0.85rem; margin: 0.75rem 0 0 1.5rem; padding: 0;">
                            <li>First, drag the button above to your bookmarks bar</li>
                            <li>Go to <a href="https://draft.premierleague.com" target="_blank" style="color: var(--accent-cyan);">draft.premierleague.com</a> and log in</li>
                            <li>Click the bookmarklet from your bookmarks bar while ON the FPL site</li>
                            <li>Come back here and paste the copied data</li>
                        </ol>
                    </div>
                    <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid var(--accent-amber); border-radius: 8px; padding: 1rem;">
                        <p style="color: var(--accent-amber); font-size: 0.85rem; margin: 0;">
                            ⚠️ <strong>Why?</strong> The bookmarklet uses your logged-in session on the FPL website to access the API. It won't work from this local page.
                        </p>
                    </div>
                </div>

                <!-- Step 2: League ID Input -->
                <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                    <h3 style="color: var(--accent-violet); margin-bottom: 1rem;">🔢 Step 2: Enter League ID</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;">
                        Your league ID can be found in the URL: draft.premierleague.com/league/<strong>YOUR_ID</strong>/...
                    </p>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: flex-end;">
                        <div class="control-group">
                            <label>League ID</label>
                            <input type="number" id="leagueIdInput" value="201560" placeholder="e.g., 201560" style="width: 150px;">
                        </div>
                        <button onclick="generateBookmarklet()" style="padding: 0.75rem 1.5rem;">
                            🔄 Update Bookmarklet
                        </button>
                    </div>
                </div>
                
                <!-- Football-Data.org API Key for PL Standings -->
                <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-amber);">
                    <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">📊 PL Standings API Key (Optional)</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;">
                        To get <strong>real Premier League standings</strong> (W/D/L/Pts), you need a free API key from football-data.org.
                        <br><a href="https://www.football-data.org/client/register" target="_blank" style="color: var(--accent-cyan);">→ Sign up for free API key (takes 30 seconds)</a>
                    </p>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: flex-end;">
                        <div class="control-group" style="flex: 1; min-width: 250px;">
                            <label>Football-Data.org API Key</label>
                            <input type="text" id="footballDataApiKey" placeholder="Paste your API key here..." style="width: 100%; font-family: monospace;">
                        </div>
                        <button onclick="saveFootballDataApiKey()" style="padding: 0.75rem 1.5rem; background: var(--accent-amber);">
                            💾 Save Key
                        </button>
                        <button onclick="testFootballDataApiKey()" style="padding: 0.75rem 1.5rem; background: var(--accent-emerald);">
                            🧪 Test & Fetch Standings
                        </button>
                    </div>
                    <div id="apiKeyStatus" style="margin-top: 0.75rem; font-size: 0.85rem; display: none;"></div>
                </div>

                <!-- Step 3: Upload or Paste Data -->
                <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-emerald);">
                    <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">📋 Step 3: Upload or Paste League Data</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;">
                        Upload the downloaded JSON file, or paste the data manually.
                    </p>
                    
                    <!-- File Upload -->
                    <div style="background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px; margin-bottom: 1rem; border: 2px dashed var(--border-color); text-align: center;" id="dropZone">
                        <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="handleFileUpload(event)">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">📁</div>
                        <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 0.5rem;">Drop JSON file here or click to upload</div>
                        <button onclick="document.getElementById('jsonFileInput').click()" style="padding: 0.75rem 1.5rem; background: var(--accent-emerald);">
                            📤 Choose File
                        </button>
                        <div id="uploadStatus" style="margin-top: 0.75rem; font-size: 0.85rem; color: var(--text-muted);"></div>
                    </div>
                    
                    <div style="text-align: center; color: var(--text-muted); margin: 1rem 0;">— OR paste manually —</div>
                    
                    <!-- Sub-tabs for different data types -->
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <button onclick="showImportSubTab('league')" class="import-subtab active" data-subtab="league">League Details</button>
                        <button onclick="showImportSubTab('elements')" class="import-subtab" data-subtab="elements">Element Status</button>
                        <button onclick="showImportSubTab('bootstrap')" class="import-subtab" data-subtab="bootstrap">Bootstrap (Players)</button>
                    </div>
                    
                    <div id="importLeague" class="import-data-section">
                        <label style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem; display: block;">
                            Paste /api/league/{id}/details JSON:
                        </label>
                        <textarea id="leagueDataInput" placeholder='Paste your league JSON here...' style="width: 100%; height: 200px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; resize: vertical;"></textarea>
                    </div>
                    
                    <div id="importElements" class="import-data-section" style="display: none;">
                        <label style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem; display: block;">
                            Paste /api/league/{id}/element-status JSON:
                        </label>
                        <textarea id="elementStatusInput" placeholder='Paste element_status JSON here...' style="width: 100%; height: 200px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; resize: vertical;"></textarea>
                    </div>
                    
                    <div id="importBootstrap" class="import-data-section" style="display: none;">
                        <label style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem; display: block;">
                            Paste /api/bootstrap-static JSON (for player name mapping):
                        </label>
                        <textarea id="bootstrapDataInput" placeholder='Paste bootstrap-static JSON here (contains player names)...' style="width: 100%; height: 200px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; resize: vertical;"></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
                        <button onclick="processLeagueData()" style="padding: 0.75rem 1.5rem; background: var(--accent-emerald);">
                            🔍 Process & Analyze Data
                        </button>
                        <button onclick="clearImportData()" style="padding: 0.75rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color);">
                            🗑️ Clear All
                        </button>
                    </div>
                </div>

                <!-- Data Status -->
                <div id="importStatus" style="display: none;" class="stat-card" style="margin-bottom: 2rem;">
                    <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">📊 Import Status</h3>
                    <div id="importStatusContent"></div>
                </div>

                <!-- League Analysis Results -->
                <div id="leagueAnalysisResults" style="display: none;">
                    <!-- Tab Navigation -->
                    <div class="tab-nav">
                        <button class="tab-btn active" onclick="switchAnalysisTab('overview', this)">
                            📊 Overview
                        </button>
                        <button class="tab-btn" onclick="switchAnalysisTab('predictions', this)">
                            🎯 Predictions
                        </button>
                        <button class="tab-btn" onclick="switchAnalysisTab('plstats', this)">
                            ⚽ PL Stats
                        </button>
                        <button class="tab-btn" onclick="switchAnalysisTab('simulation', this)">
                            📈 GW Simulation
                        </button>
                    </div>
                    
                    <!-- Overview Tab -->
                    <div id="overviewTab" class="tab-content active">
                    <!-- League Overview -->
                    <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                        <h3 style="color: var(--accent-violet); margin-bottom: 1rem;">🏆 League Overview</h3>
                        <div id="leagueOverview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;"></div>
                    </div>
                    
                    <!-- Recent Transactions -->
                    <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-amber);">
                        <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">📋 Recent Transactions</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                            Trades, waivers, and free agent pickups in your league
                        </p>
                        <div id="recentTransactionsView"></div>
                    </div>
                    
                    <!-- Teams Comparison -->
                    <div class="stat-card" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">👥 All Teams Comparison</h3>
                        <div id="teamsComparisonTable" style="overflow-x: auto;"></div>
                    </div>
                    
                    <!-- N-K-D Analysis for All Teams -->
                    <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-emerald);">
                        <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">📈 N-K-D Analysis - All Teams</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                            Fixture optimization comparison for all league teams (15-11-3 benchmark).
                        </p>
                        <div id="allTeamsNKD"></div>
                    </div>
                    
                    <!-- League Teams Visualization -->
                    <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                        <h3 style="color: var(--accent-violet); margin-bottom: 1rem;">👥 League Teams - Squad View</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                            View each team's full squad with player stats, form, and gameweek performance.
                        </p>
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; align-items: center;">
                            <select id="viewTeamSelect" onchange="renderTeamSquadView()" style="padding: 0.5rem 1rem; min-width: 200px;"></select>
                            <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">
                                <input type="checkbox" id="showDetailedStats" onchange="renderTeamSquadView()" checked>
                                Show detailed stats
                            </label>
                        </div>
                        <div id="teamSquadView"></div>
                    </div>
                    
                    <!-- Free Agents -->
                    <div class="stat-card" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--accent-rose); margin-bottom: 1rem;">🆓 Top Free Agents</h3>
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                            <select id="freeAgentPosition" onchange="filterFreeAgents()" style="padding: 0.5rem 1rem;">
                                <option value="all">All Positions</option>
                                <option value="GK">Goalkeepers</option>
                                <option value="DEF">Defenders</option>
                                <option value="MID">Midfielders</option>
                                <option value="FWD">Forwards</option>
                            </select>
                            <input type="text" id="freeAgentSearch" placeholder="Search player..." oninput="filterFreeAgents()" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary);">
                        </div>
                        <div id="freeAgentsList" style="max-height: 400px; overflow-y: auto;"></div>
                    </div>
                    
                    <!-- Head to Head -->
                    <div class="stat-card" style="border: 2px solid var(--accent-amber);">
                        <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">⚔️ Head-to-Head Comparison</h3>
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; align-items: flex-end;">
                            <div class="control-group">
                                <label>Team 1</label>
                                <select id="h2hTeam1" style="min-width: 200px;"></select>
                            </div>
                            <div style="font-size: 1.5rem; color: var(--text-muted);">VS</div>
                            <div class="control-group">
                                <label>Team 2</label>
                                <select id="h2hTeam2" style="min-width: 200px;"></select>
                            </div>
                            <button onclick="runHeadToHead()" style="padding: 0.75rem 1.5rem;">
                                ⚡ Compare
                            </button>
                        </div>
                        <div id="h2hResults"></div>
                    </div>
                    </div><!-- End Overview Tab -->
                    
                    <!-- Predictions Tab -->
                    <div id="predictionsTab" class="tab-content">
                        <!-- GW Selector -->
                        <div class="stat-card" style="margin-bottom: 1.5rem; background: linear-gradient(135deg, rgba(34, 211, 238, 0.1), rgba(139, 92, 246, 0.1)); border: 2px solid var(--accent-cyan);">
                            <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                                <div>
                                    <h3 style="color: var(--accent-cyan); margin-bottom: 0.25rem;">🎯 GW Predictions</h3>
                                    <p style="color: var(--text-secondary); font-size: 0.85rem;">Predicted points based on form, fixtures, and player stats</p>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center;">
                                    <label style="color: var(--text-secondary);">Gameweek:</label>
                                    <select id="predictionGW" onchange="renderPredictionsTab()" style="padding: 0.5rem 1rem; min-width: 100px;"></select>
                                    <button onclick="renderPredictionsTab()" class="btn-primary" style="padding: 0.5rem 1rem;">
                                        🔄 Refresh
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Team Rankings -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-emerald);">
                            <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">🏆 Predicted Team Rankings</h3>
                            <div id="predictionRankings"></div>
                        </div>
                        
                        <!-- H2H Matchup Predictions -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-amber);">
                            <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">⚔️ H2H Matchup Predictions</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                                Win probability based on squad strength and predicted points
                            </p>
                            <div id="h2hMatchupPredictions"></div>
                        </div>
                        
                        <!-- Player Breakdown by Team -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                <h3 style="color: var(--accent-violet); margin: 0;">📋 Player Points Breakdown</h3>
                                <button onclick="openCompareModal()" style="padding: 0.4rem 0.75rem; background: var(--accent-violet); border: none; border-radius: 6px; cursor: pointer; color: white; font-size: 0.8rem;">
                                    📊 Compare Players
                                </button>
                            </div>
                            <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; align-items: center;">
                                <select id="breakdownTeamSelect" onchange="renderPlayerBreakdown()" style="padding: 0.5rem 1rem; min-width: 200px;"></select>
                                <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">
                                    <input type="checkbox" id="showOptimal11Only" onchange="renderPlayerBreakdown()">
                                    Show Optimal 11 Only
                                </label>
                            </div>
                            <div id="playerBreakdownTable" style="overflow-x: auto;"></div>
                        </div>
                        
                        <!-- Monte Carlo Lineup Optimizer -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-emerald);">
                            <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">🎲 Monte Carlo Lineup Optimizer</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                                Simulate lineups to find the optimal starting XI based on score distributions
                            </p>
                            <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; align-items: center;">
                                <select id="mcTeamSelect" style="padding: 0.5rem 1rem; min-width: 200px;"></select>
                                <select id="mcSimCount" style="padding: 0.5rem 1rem;">
                                    <option value="1">1 (Single Game)</option>
                                    <option value="100">100</option>
                                    <option value="500">500</option>
                                    <option value="1000" selected>1,000</option>
                                    <option value="5000">5,000</option>
                                </select>
                                <button onclick="runMCSimulation()" class="btn-primary" style="padding: 0.5rem 1rem;">
                                    🎲 Run Simulation
                                </button>
                                <button onclick="runMCSimulation(1)" class="btn-secondary" style="padding: 0.5rem 1rem;">
                                    ⚡ Quick (1 Game)
                                </button>
                            </div>
                            <div id="mcLoading" class="loading" style="display: none;">Running simulation...</div>
                            <div id="mcResults"></div>
                        </div>
                        
                        <!-- Fixture Difficulty Heatmap -->
                        <div class="stat-card" style="border: 2px solid var(--accent-cyan);">
                            <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">📅 Fixture Difficulty Heatmap</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                                Green = Easy fixture | Red = Hard fixture (based on FPL's FDR)
                            </p>
                            <div id="fixtureHeatmap" class="fixture-heatmap"></div>
                        </div>
                    </div><!-- End Predictions Tab -->
                    
                    <!-- PL Stats Tab -->
                    <div id="plstatsTab" class="tab-content">
                        <!-- PL Standings -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-emerald);">
                            <h3 style="color: var(--accent-emerald); margin-bottom: 1rem;">📊 Premier League Standings</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                                Current season statistics from FPL bootstrap data
                            </p>
                            <div id="plStandingsTable" style="overflow-x: auto;"></div>
                        </div>
                        
                        <!-- Team Stats Cards -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-violet);">
                            <h3 style="color: var(--accent-violet); margin-bottom: 1rem;">⚽ Team Performance Cards</h3>
                            <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                                <select id="plTeamFilter" onchange="renderPLTeamCards()" style="padding: 0.5rem 1rem;">
                                    <option value="all">All Teams</option>
                                    <option value="top6">Top 6</option>
                                    <option value="mid">Mid Table (7-14)</option>
                                    <option value="bottom">Bottom 6</option>
                                </select>
                                <select id="plStatSort" onchange="renderPLTeamCards()" style="padding: 0.5rem 1rem;">
                                    <option value="rank">Sort by Rank</option>
                                    <option value="attack">Sort by Attack (Goals Scored)</option>
                                    <option value="defense">Sort by Defense (Goals Conceded)</option>
                                    <option value="form">Sort by Form</option>
                                </select>
                            </div>
                            <div id="plTeamCards" class="predictions-grid"></div>
                        </div>
                        
                        <!-- Team Matchup Predictor -->
                        <div class="stat-card" style="margin-bottom: 2rem; border: 2px solid var(--accent-cyan);">
                            <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">🎯 Match Score Predictor</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                                Select two teams to predict the match score using batch-based analysis
                            </p>
                            
                            <div style="display: flex; gap: 2rem; align-items: center; flex-wrap: wrap; margin-bottom: 1.5rem;">
                                <!-- Home Team -->
                                <div class="control-group" style="flex: 1; min-width: 200px;">
                                    <label style="color: var(--accent-emerald);">🏠 Home Team</label>
                                    <select id="matchupHomeTeam" onchange="calculateMatchupPrediction()" style="padding: 0.75rem 1rem; width: 100%;">
                                        <option value="">Select home team...</option>
                                    </select>
                                </div>
                                
                                <div style="font-size: 1.5rem; color: var(--text-muted);">vs</div>
                                
                                <!-- Away Team -->
                                <div class="control-group" style="flex: 1; min-width: 200px;">
                                    <label style="color: var(--accent-rose);">✈️ Away Team</label>
                                    <select id="matchupAwayTeam" onchange="calculateMatchupPrediction()" style="padding: 0.75rem 1rem; width: 100%;">
                                        <option value="">Select away team...</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div id="matchupResult" style="display: none;"></div>
                        </div>
                        
                        <!-- Attack vs Defense Comparison -->
                        <div class="stat-card" style="border: 2px solid var(--accent-amber);">
                            <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">⚔️ Attack vs Defense Analysis</h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                                Compare team attacking and defensive strengths
                            </p>
                            <div id="attackDefenseChart"></div>
                        </div>
                    </div><!-- End PL Stats Tab -->
                    
                    <!-- Simulation Tab - Pre-calculated Results -->
                    <div id="simulationTab" class="tab-content">
                        <!-- Simulation Header -->
                        <div class="stat-card" style="margin-bottom: 1.5rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(34, 211, 238, 0.1)); border: 2px solid var(--accent-emerald);">
                            <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                                <div>
                                    <h3 style="color: var(--accent-emerald); margin-bottom: 0.25rem;">📈 GW Simulation Results</h3>
                                    <p style="color: var(--text-secondary); font-size: 0.85rem;">Pre-calculated predictions from Python analysis</p>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center;">
                                    <input type="file" id="simulationFileInput" accept=".json" onchange="loadSimulationFile(event)" style="display: none;">
                                    <button onclick="document.getElementById('simulationFileInput').click()" class="btn-secondary" style="padding: 0.5rem 1rem;">
                                        📁 Load JSON File
                                    </button>
                                    <button onclick="useCurrentData()" class="btn-primary" style="padding: 0.5rem 1rem;">
                                        🔄 Use Current Data
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Simulation Results Container -->
                        <div id="simulationResults">
                            <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                                <div style="font-size: 3rem; margin-bottom: 1rem;">📊</div>
                                <p>No simulation data loaded yet.</p>
                                <p style="font-size: 0.85rem; margin-top: 0.5rem;">
                                    Load a JSON file or click "Use Current Data" to generate predictions.
                                </p>
                            </div>
                        </div>
                    </div><!-- End Simulation Tab -->
                    
                </div>
            </div>
        </div>
    </div>

    <!-- Database Client -->
    <script src="/static/js/db.js"></script>
    <!-- Data Service (cache → DB → sync) -->
    <script src="/static/js/dataService.js"></script>
    
    <script>
        // Teams with their EASY GAME gameweeks (GW21-38)
        // Data provided by user - these are the gameweeks where each team has favorable fixtures
        const teams = [
            'Arsenal', 'Villa', 'Bournemouth', 'Brentford', 'Brighton',
            'Chelsea', 'Palace', 'Everton', 'Fulham', 'City',
            'Liverpool', 'United', 'Newcastle', 'Forest', 'Spurs', 
            'West Ham', 'Sunderland', 'Burnley', 'Wolves', 'Leeds'
        ];
        
        // YOUR ANALYSIS: Easy games by team (your prediction after seeing teams in form)
        const yourAnalysis = {
            'Arsenal': [20, 22, 24, 25, 26, 29, 30, 31, 32, 35, 36, 37],
            'Everton': [21, 23, 24, 25, 29, 34, 37],
            'Sunderland': [23, 24, 27, 29, 30, 32, 34, 35],
            'City': [21, 23, 26, 28, 29, 30, 34, 35, 36],
            'Chelsea': [21, 22, 24, 25, 26, 27, 34, 36, 37, 38],
            'Palace': [24, 25, 26, 27, 30, 33, 35, 36],
            'Villa': [20, 22, 24, 26, 27, 28, 31, 32, 33, 34, 36],
            'Newcastle': [21, 22, 25, 28, 31, 33, 35, 36, 37, 38],
            'United': [20, 21, 24, 26, 32, 34, 37, 38],
            'Liverpool': [22, 27, 28, 29, 31, 32, 38],
            'Bournemouth': [24, 27, 30, 34, 38],
            'Spurs': [20, 22, 23, 31, 33, 34, 36, 37],
            'Brighton': [20, 28, 32, 36, 37],
            'Brentford': [21, 23, 28, 30, 31, 32, 33, 35],
            'West Ham': [20, 21, 25, 32, 34, 38],
            'Fulham': [22, 23, 29, 30, 31, 37],
            'Forest': [21, 25, 26, 30, 33],
            'Burnley': [25, 38],
            'Wolves': [20, 32, 35, 37, 38],
            'Leeds': [25, 29, 31, 37]
        };
        
        // OFFICIAL FDR DATA: From pre-season difficulty ratings (FDR 2 = easy)
        // GW21-38 FDR scores for each team (GW20 data kept for reference but not displayed)
        const officialFDR = {
            'City': {
                scores: {20:3, 21:3, 22:3, 23:2, 24:3, 25:4, 26:2, 27:3, 28:3, 29:2, 30:2, 31:3, 32:3, 33:4, 34:2, 35:3, 36:3, 37:3, 38:3},
                easy: [23, 26, 29, 30, 34]
            },
            'Arsenal': {
                scores: {20:4, 21:4, 22:3, 23:3, 24:3, 25:2, 26:3, 27:3, 28:3, 29:3, 30:2, 31:2, 32:3, 33:4, 34:3, 35:2, 36:3, 37:4, 38:3},
                easy: [25, 30, 31, 35]
            },
            'Villa': {
                scores: {20:2, 21:3, 22:2, 23:4, 24:3, 25:4, 26:3, 27:2, 28:2, 29:3, 30:3, 31:2, 32:3, 33:2, 34:3, 35:2, 36:2, 37:2, 38:3},
                easy: [20, 22, 27, 28, 31, 33, 35, 36, 37]
            },
            'Bournemouth': {
                scores: {20:4, 21:3, 22:3, 23:4, 24:2, 25:3, 26:3, 27:2, 28:2, 29:3, 30:2, 31:3, 32:3, 33:2, 34:3, 35:3, 36:2, 37:4, 38:4},
                easy: [24, 27, 28, 30, 33, 36]
            },
            'Brentford': {
                scores: {20:3, 21:2, 22:3, 23:2, 24:3, 25:4, 26:4, 27:3, 28:2, 29:4, 30:2, 31:3, 32:3, 33:4, 34:2, 35:3, 36:3, 37:4, 38:3},
                easy: [21, 23, 28, 30, 34]
            },
            'Brighton': {
                scores: {20:2, 21:4, 22:3, 23:3, 24:2, 25:3, 26:3, 27:3, 28:2, 29:4, 30:3, 31:4, 32:2, 33:3, 34:3, 35:4, 36:2, 37:3, 38:4},
                easy: [20, 24, 28, 32, 36]
            },
            'Burnley': {
                scores: {20:3, 21:3, 22:4, 23:3, 24:3, 25:2, 26:3, 27:3, 28:3, 29:3, 30:3, 31:3, 32:3, 33:3, 34:4, 35:3, 36:3, 37:5, 38:2},
                easy: [25, 38]
            },
            'Chelsea': {
                scores: {20:4, 21:3, 22:3, 23:3, 24:2, 25:2, 26:2, 27:2, 28:5, 29:3, 30:3, 31:3, 32:4, 33:3, 34:3, 35:2, 36:4, 37:3, 38:3},
                easy: [24, 25, 26, 27, 35]
            },
            'Palace': {
                scores: {20:4, 21:3, 22:3, 23:3, 24:3, 25:3, 26:2, 27:2, 28:3, 29:3, 30:2, 31:4, 32:3, 33:2, 34:4, 35:4, 36:2, 37:3, 38:4},
                easy: [26, 27, 30, 33, 36]
            },
            'Everton': {
                scores: {20:3, 21:2, 22:3, 23:2, 24:3, 25:3, 26:3, 27:3, 28:4, 29:2, 30:5, 31:3, 32:3, 33:4, 34:2, 35:4, 36:3, 37:2, 38:3},
                easy: [21, 23, 29, 34, 37]
            },
            'Fulham': {
                scores: {20:4, 21:3, 22:3, 23:3, 24:3, 25:2, 26:3, 27:2, 28:4, 29:3, 30:3, 31:3, 32:3, 33:4, 34:2, 35:4, 36:3, 37:2, 38:3},
                easy: [25, 27, 34, 37]
            },
            'Liverpool': {
                scores: {20:3, 21:5, 22:2, 23:4, 24:3, 25:4, 26:3, 27:3, 28:2, 29:2, 30:3, 31:3, 32:4, 33:3, 34:3, 35:3, 36:3, 37:3, 38:3},
                easy: [22, 28, 29]
            },
            'United': {
                scores: {20:3, 21:2, 22:4, 23:5, 24:2, 25:3, 26:2, 27:3, 28:3, 29:4, 30:3, 31:4, 32:2, 33:3, 34:3, 35:4, 36:3, 37:2, 38:3},
                easy: [21, 24, 26, 32, 37]
            },
            'Newcastle': {
                scores: {20:3, 21:2, 22:2, 23:3, 24:4, 25:3, 26:3, 27:4, 28:2, 29:3, 30:3, 31:2, 32:3, 33:2, 34:3, 35:3, 36:3, 37:3, 38:3},
                easy: [21, 22, 28, 31, 33]
            },
            'Forest': {
                scores: {20:3, 21:2, 22:2, 23:3, 24:3, 25:3, 26:3, 27:4, 28:2, 29:3, 30:3, 31:2, 32:3, 33:3, 34:5, 35:3, 36:3, 37:2, 38:3},
                easy: [21, 22, 28, 31, 37]
            },
            'Spurs': {
                scores: {20:2, 21:4, 22:2, 23:2, 24:4, 25:3, 26:3, 27:4, 28:3, 29:4, 30:4, 31:2, 32:3, 33:3, 34:2, 35:3, 36:2, 37:3, 38:2},
                easy: [20, 22, 23, 31, 34, 36, 38]
            },
            'Sunderland': {
                scores: {20:3, 21:3, 22:3, 23:2, 24:2, 25:5, 26:4, 27:2, 28:4, 29:3, 30:3, 31:4, 32:3, 33:3, 34:2, 35:2, 36:3, 37:3, 38:3},
                easy: [23, 24, 27, 34, 35]
            },
            'West Ham': {
                scores: {20:2, 21:2, 22:3, 23:2, 24:3, 25:2, 26:3, 27:3, 28:4, 29:3, 30:4, 31:3, 32:2, 33:3, 34:2, 35:3, 36:4, 37:4, 38:2},
                easy: [20, 21, 23, 25, 32, 34, 38]
            },
            'Wolves': {
                scores: {20:2, 21:3, 22:3, 23:4, 24:3, 25:3, 26:3, 27:3, 28:3, 29:4, 30:3, 31:4, 32:2, 33:3, 34:3, 35:2, 36:3, 37:2, 38:2},
                easy: [20, 32, 35, 37, 38]
            },
            'Leeds': {
                scores: {20:3, 21:2, 22:3, 23:3, 24:3, 25:2, 26:4, 27:3, 28:3, 29:2, 30:3, 31:2, 32:4, 33:3, 34:3, 35:5, 36:3, 37:2, 38:3},
                easy: [21, 25, 29, 31, 37]
            }
        };
        
        // FIXTURES: Opponent for each team in each gameweek (H = Home, A = Away)
        // CORRECTED FIXTURE DATA - parsed from user's official source
        const fixtures = {
            'City': {20:'CHE(H)', 21:'BHA(H)', 22:'MUN(A)', 23:'WOL(H)', 24:'TOT(A)', 25:'LIV(A)', 26:'FUL(H)', 27:'NEW(H)', 28:'LEE(A)', 29:'NFO(H)', 30:'WHU(A)', 31:'CRY(H)', 32:'CHE(A)', 33:'ARS(H)', 34:'BUR(A)', 35:'EVE(A)', 36:'BRE(H)', 37:'BOU(A)', 38:'AVL(H)'},
            'Arsenal': {20:'BOU(A)', 21:'LIV(H)', 22:'NFO(A)', 23:'MUN(H)', 24:'LEE(A)', 25:'SUN(H)', 26:'BRE(A)', 27:'TOT(A)', 28:'CHE(H)', 29:'BHA(A)', 30:'EVE(H)', 31:'WOL(A)', 32:'BOU(H)', 33:'MCI(A)', 34:'NEW(H)', 35:'FUL(H)', 36:'WHU(A)', 37:'BUR(H)', 38:'CRY(A)'},
            'Villa': {20:'NFO(H)', 21:'CRY(A)', 22:'EVE(H)', 23:'NEW(A)', 24:'BRE(H)', 25:'BOU(A)', 26:'BHA(H)', 27:'LEE(H)', 28:'WOL(A)', 29:'CHE(H)', 30:'MUN(A)', 31:'WHU(H)', 32:'NFO(A)', 33:'MCI(A)', 34:'NEW(H)', 35:'FUL(H)', 36:'WHU(A)', 37:'BUR(H)', 38:'CRY(A)'},
            'Bournemouth': {20:'ARS(H)', 21:'TOT(H)', 22:'BHA(A)', 23:'LIV(H)', 24:'WOL(A)', 25:'AVL(H)', 26:'EVE(A)', 27:'WHU(A)', 28:'SUN(H)', 29:'BRE(H)', 30:'BUR(A)', 31:'MUN(H)', 32:'ARS(A)', 33:'SUN(H)', 34:'FUL(A)', 35:'TOT(H)', 36:'BUR(A)', 37:'LIV(H)', 38:'MCI(A)'},
            'Brentford': {20:'EVE(A)', 21:'SUN(H)', 22:'CHE(A)', 23:'NFO(H)', 24:'AVL(A)', 25:'NEW(A)', 26:'ARS(H)', 27:'BHA(H)', 28:'BUR(A)', 29:'BOU(A)', 30:'WOL(H)', 31:'LEE(A)', 32:'EVE(H)', 33:'FUL(H)', 34:'LEE(H)', 35:'CRY(H)', 36:'FUL(A)', 37:'MCI(H)', 38:'NFO(A)'},
            'Brighton': {20:'BUR(H)', 21:'MCI(A)', 22:'BOU(H)', 23:'FUL(A)', 24:'EVE(H)', 25:'CRY(H)', 26:'AVL(A)', 27:'BRE(A)', 28:'NFO(H)', 29:'ARS(H)', 30:'SUN(A)', 31:'LIV(H)', 32:'BUR(A)', 33:'TOT(A)', 34:'CHE(H)', 35:'NFO(H)', 36:'WOL(H)', 37:'LEE(A)', 38:'MUN(H)'},
            'Burnley': {20:'BHA(A)', 21:'MUN(H)', 22:'LIV(A)', 23:'TOT(H)', 24:'SUN(A)', 25:'WHU(H)', 26:'CRY(A)', 27:'CHE(A)', 28:'BRE(H)', 29:'EVE(A)', 30:'BOU(H)', 31:'FUL(A)', 32:'BHA(H)', 33:'NFO(A)', 34:'MCI(H)', 35:'LEE(A)', 36:'AVL(H)', 37:'ARS(A)', 38:'WOL(H)'},
            'Chelsea': {20:'MCI(A)', 21:'FUL(A)', 22:'BRE(H)', 23:'CRY(A)', 24:'WHU(H)', 25:'WOL(A)', 26:'LEE(H)', 27:'BUR(H)', 28:'ARS(A)', 29:'AVL(A)', 30:'NEW(H)', 31:'EVE(A)', 32:'MCI(H)', 33:'MUN(H)', 34:'BHA(A)', 35:'NFO(H)', 36:'LIV(A)', 37:'TOT(H)', 38:'SUN(A)'},
            'Palace': {20:'NEW(A)', 21:'AVL(H)', 22:'SUN(A)', 23:'CHE(H)', 24:'NFO(A)', 25:'BHA(A)', 26:'BUR(H)', 27:'WOL(H)', 28:'MUN(A)', 29:'TOT(A)', 30:'LEE(H)', 31:'MCI(A)', 32:'NEW(H)', 33:'WHU(H)', 34:'LIV(A)', 35:'BOU(A)', 36:'EVE(H)', 37:'BRE(A)', 38:'ARS(H)'},
            'Everton': {20:'BRE(H)', 21:'WOL(H)', 22:'AVL(A)', 23:'LEE(H)', 24:'BHA(A)', 25:'FUL(A)', 26:'BOU(H)', 27:'MUN(H)', 28:'NFO(H)', 29:'BUR(H)', 30:'ARS(A)', 31:'CHE(H)', 32:'BRE(A)', 33:'LIV(H)', 34:'WHU(A)', 35:'MCI(H)', 36:'CRY(A)', 37:'SUN(H)', 38:'TOT(H)'},
            'Fulham': {20:'LIV(H)', 21:'CHE(H)', 22:'LEE(A)', 23:'BHA(H)', 24:'MUN(A)', 25:'EVE(H)', 26:'BOU(H)', 27:'SUN(A)', 28:'NEW(A)', 29:'BUR(H)', 30:'ARS(A)', 31:'CHE(H)', 32:'BRE(A)', 33:'LIV(H)', 34:'WHU(A)', 35:'MCI(H)', 36:'CRY(H)', 37:'SUN(H)', 38:'TOT(A)'},
            'Liverpool': {20:'FUL(A)', 21:'ARS(A)', 22:'BUR(H)', 23:'BOU(A)', 24:'NEW(H)', 25:'MCI(H)', 26:'SUN(A)', 27:'NFO(A)', 28:'WHU(H)', 29:'WOL(A)', 30:'TOT(H)', 31:'BHA(A)', 32:'FUL(H)', 33:'EVE(A)', 34:'CRY(H)', 35:'MUN(A)', 36:'CHE(H)', 37:'AVL(A)', 38:'WHU(A)'},
            'United': {20:'LEE(A)', 21:'BUR(A)', 22:'MCI(H)', 23:'ARS(A)', 24:'FUL(H)', 25:'TOT(H)', 26:'WHU(A)', 27:'EVE(A)', 28:'CRY(H)', 29:'NEW(A)', 30:'AVL(H)', 31:'BOU(A)', 32:'LEE(H)', 33:'CHE(A)', 34:'BRE(H)', 35:'LIV(H)', 36:'SUN(A)', 37:'NFO(H)', 38:'BHA(A)'},
            'Newcastle': {20:'CRY(H)', 21:'LEE(H)', 22:'WOL(H)', 23:'AVL(H)', 24:'LIV(A)', 25:'BRE(H)', 26:'TOT(H)', 27:'MCI(A)', 28:'FUL(H)', 29:'MUN(H)', 30:'CHE(A)', 31:'SUN(H)', 32:'CRY(A)', 33:'BOU(A)', 34:'ARS(A)', 35:'BHA(H)', 36:'TOT(H)', 37:'WHU(H)', 38:'LEE(A)'},
            'Forest': {20:'AVL(A)', 21:'WHU(A)', 22:'ARS(H)', 23:'BRE(A)', 24:'CRY(H)', 25:'LIV(H)', 26:'WOL(H)', 27:'LIV(H)', 28:'EVE(H)', 29:'MCI(A)', 30:'CHE(A)', 31:'SUN(H)', 32:'CRY(A)', 33:'BOU(H)', 34:'ARS(H)', 35:'BHA(A)', 36:'NFO(A)', 37:'WHU(H)', 38:'FUL(A)'},
            'Spurs': {20:'SUN(H)', 21:'BOU(A)', 22:'WHU(H)', 23:'BUR(A)', 24:'MCI(H)', 25:'MUN(A)', 26:'NFO(A)', 27:'LIV(H)', 28:'BHA(A)', 29:'MCI(A)', 30:'LIV(A)', 31:'NFO(A)', 32:'AVL(H)', 33:'BUR(H)', 34:'SUN(A)', 35:'CHE(A)', 36:'NEW(H)', 37:'MUN(A)', 38:'BOU(H)'},
            'Sunderland': {20:'TOT(A)', 21:'BRE(A)', 22:'CRY(H)', 23:'WHU(A)', 24:'BUR(H)', 25:'ARS(A)', 26:'LIV(H)', 27:'FUL(H)', 28:'BOU(A)', 29:'LEE(A)', 30:'BHA(H)', 31:'NEW(A)', 32:'TOT(H)', 33:'AVL(A)', 34:'NFO(H)', 35:'WOL(A)', 36:'MUN(H)', 37:'EVE(A)', 38:'CHE(H)'},
            'West Ham': {20:'WOL(A)', 21:'NFO(H)', 22:'TOT(A)', 23:'SUN(H)', 24:'CHE(A)', 25:'BUR(A)', 26:'MUN(H)', 27:'BOU(H)', 28:'LIV(A)', 29:'FUL(A)', 30:'MCI(H)', 31:'AVL(A)', 32:'WOL(H)', 33:'CRY(A)', 34:'EVE(H)', 35:'BRE(A)', 36:'AVL(H)', 37:'NEW(A)', 38:'LEE(H)'},
            'Wolves': {20:'WHU(H)', 21:'EVE(A)', 22:'NEW(A)', 23:'MCI(A)', 24:'BOU(H)', 25:'CHE(H)', 26:'NFO(A)', 27:'CRY(A)', 28:'AVL(H)', 29:'LIV(H)', 30:'BRE(A)', 31:'ARS(H)', 32:'WHU(A)', 33:'LIV(H)', 34:'TOT(H)', 35:'SUN(H)', 36:'BHA(A)', 37:'FUL(A)', 38:'BUR(A)'},
            'Leeds': {20:'MUN(H)', 21:'NEW(A)', 22:'FUL(H)', 23:'EVE(A)', 24:'ARS(H)', 25:'NFO(H)', 26:'CHE(A)', 27:'SUN(A)', 28:'TOT(H)', 29:'WHU(H)', 30:'NFO(A)', 31:'BUR(H)', 32:'LIV(A)', 33:'BRE(A)', 34:'AVL(H)', 35:'ARS(A)', 36:'BOU(H)', 37:'WOL(A)', 38:'NEW(H)'}
        };
        
        // Team abbreviation mapping for display
        const teamAbbrev = {
            'Arsenal': 'ARS', 'Villa': 'AVL', 'Bournemouth': 'BOU', 'Brentford': 'BRE', 'Brighton': 'BHA',
            'Chelsea': 'CHE', 'Palace': 'CRY', 'Everton': 'EVE', 'Fulham': 'FUL', 'City': 'MCI',
            'Liverpool': 'LIV', 'United': 'MUN', 'Newcastle': 'NEW', 'Forest': 'NFO', 'Spurs': 'TOT',
            'West Ham': 'WHU', 'Sunderland': 'SUN', 'Burnley': 'BUR', 'Wolves': 'WOL', 'Leeds': 'LEE'
        };
        
        // Weight for combining analyses (0 = only your analysis, 1 = only official FDR)
        let fdrWeight = 0.5; // Default: 50% each
        
        // Gameweeks 21-38 (18 total)
        const gameweeks = Array.from({length: 18}, (_, i) => `GW${i + 21}`);
        const gwStart = 21;
        const gwEnd = 38;
        
        // Create weighted fixture data combining both sources
        function createWeightedFixtureData(weight = fdrWeight) {
            const data = {};
            teams.forEach(team => {
                const yourEasyGWs = new Set(yourAnalysis[team] || []);
                const officialData = officialFDR[team];
                data[team] = [];
                
                for (let gw = gwStart; gw <= gwEnd; gw++) {
                    // Your analysis: 2 = easy, 4 = hard
                    const yourScore = yourEasyGWs.has(gw) ? 2 : 4;
                    
                    // Official FDR: actual score (2-5)
                    const officialScore = officialData?.scores[gw] || 3;
                    
                    // Weighted combination
                    const combined = (yourScore * (1 - weight)) + (officialScore * weight);
                    
                    // Store the weighted score
                    data[team].push(combined);
                }
            });
            return data;
        }
        
        // Initialize fixture data with default weight
        let fixtureData = createWeightedFixtureData();
        
        // Function to update fixture data when weight changes
        function updateFixtureWeight(newWeight) {
            fdrWeight = newWeight;
            fixtureData = createWeightedFixtureData(newWeight);
            // Refresh current view
            renderFixtureGrid();
            renderOverlapAnalysis();
            if (typeof renderCharts === 'function') renderCharts();
        }
        
        // Easy threshold for weighted scores
        const EASY_THRESHOLD = 2.5;
        
        // Calculate easy games for each team
        function getEasyGames(team) {
            return fixtureData[team].map((fdr, idx) => ({
                gw: idx,
                fdr: fdr,
                isEasy: fdr <= EASY_THRESHOLD
            }));
        }
        
        // Get easy game weeks as a set
        function getEasyGameweeks(team) {
            return new Set(
                fixtureData[team]
                    .map((fdr, idx) => fdr <= EASY_THRESHOLD ? idx : -1)
                    .filter(idx => idx !== -1)
            );
        }
        
        // Calculate overlap between two teams
        function calculateOverlap(team1, team2) {
            const easy1 = getEasyGameweeks(team1);
            const easy2 = getEasyGameweeks(team2);
            
            let duplications = 0; // Both easy
            let empty = 0; // Neither easy
            let coverage = 0; // At least one easy
            
            for (let gw = 0; gw < gameweeks.length; gw++) {
                const has1 = easy1.has(gw);
                const has2 = easy2.has(gw);
                
                if (has1 && has2) duplications++;
                if (!has1 && !has2) empty++;
                if (has1 || has2) coverage++;
            }
            
            return { duplications, empty, coverage };
        }
        
        // Render fixture grid
        function renderFixtureGrid() {
            const container = document.getElementById('fixtureGrid');
            const editClass = editMode ? 'edit-mode' : '';
            let html = `<table class="fixture-table ${editClass}"><thead><tr><th>Team</th>`;
            
            gameweeks.forEach(gw => {
                html += `<th>${gw}</th>`;
            });
            html += '<th>Easy</th><th>Avg</th></tr></thead><tbody>';
            
            // Sort teams by number of easy games (descending)
            const sortedTeams = [...teams].sort((a, b) => {
                const easyA = fixtureData[a].filter(f => f <= 2.5).length;
                const easyB = fixtureData[b].filter(f => f <= 2.5).length;
                return easyB - easyA;
            });
            
            sortedTeams.forEach(team => {
                html += `<tr><td class="team-name">${team}</td>`;
                let easyCount = 0;
                let totalScore = 0;
                
                fixtureData[team].forEach((fdr, idx) => {
                    const gwNum = idx + gwStart;
                    const opponent = fixtures[team]?.[gwNum] || '???';
                    const hasOverride = manualOverrides[`${team}-${gwNum}`] !== undefined;
                    
                    // Color gradient based on weighted score
                    let className, bgColor;
                    if (fdr <= 2.5) {
                        className = 'easy';
                        easyCount++;
                    } else if (fdr <= 3.5) {
                        className = '';
                        bgColor = 'rgba(251, 191, 36, 0.3)'; // amber for medium
                    } else {
                        className = 'hard';
                    }
                    totalScore += fdr;
                    
                    // Add override indicator
                    const overrideStyle = hasOverride ? 'border: 2px solid var(--accent-violet);' : '';
                    const clickHandler = `onclick="handleCellClick('${team}', ${gwNum}, event)"`;
                    const styleAttr = `style="font-size: 0.65rem; padding: 0.3rem; ${bgColor ? `background: ${bgColor};` : ''} ${overrideStyle}"`;
                    html += `<td class="${className}" ${styleAttr} ${clickHandler} title="FDR: ${fdr.toFixed(1)}${hasOverride ? ' (Manual)' : ''}">${opponent}</td>`;
                });
                
                const avgScore = (totalScore / fixtureData[team].length).toFixed(2);
                const avgColor = avgScore <= 2.8 ? 'var(--easy-game)' : avgScore <= 3.2 ? 'var(--accent-amber)' : 'var(--hard-game)';
                
                html += `<td style="font-weight: 700; color: var(--easy-game)">${easyCount}</td>`;
                html += `<td style="font-weight: 700; color: ${avgColor}; font-family: 'JetBrains Mono', monospace;">${avgScore}</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        // Render easy games summary
        function renderEasyGamesSummary() {
            const container = document.getElementById('easyGamesSummary');
            let html = '<div class="overlap-grid">';
            
            const sortedTeams = [...teams].sort((a, b) => {
                const easyA = fixtureData[a].filter(f => f <= 2).length;
                const easyB = fixtureData[b].filter(f => f <= 2).length;
                return easyB - easyA;
            });
            
            sortedTeams.forEach(team => {
                const easyGWs = fixtureData[team]
                    .map((fdr, idx) => fdr <= 2 ? `GW${idx + gwStart}` : null)
                    .filter(gw => gw !== null);
                
                const easyCount = easyGWs.length;
                const hardCount = gameweeks.length - easyCount;
                
                html += `
                    <div class="overlap-card">
                        <div class="team-pair">${team}</div>
                        <div class="overlap-stats">
                            <div class="stat-item">
                                <div class="stat-value good">${easyCount}</div>
                                <div class="stat-label">Easy</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value bad">${hardCount}</div>
                                <div class="stat-label">Hard</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value neutral">${((easyCount/gameweeks.length)*100).toFixed(0)}%</div>
                                <div class="stat-label">Coverage</div>
                            </div>
                        </div>
                        <div style="margin-top: 0.75rem; font-size: 0.8rem; color: var(--text-muted);">
                            Easy GWs: ${easyGWs.join(', ')}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Render overlap analysis
        function renderOverlapAnalysis() {
            const container = document.getElementById('overlapResults');
            const overlaps = [];
            
            // Calculate all pair overlaps
            for (let i = 0; i < teams.length; i++) {
                for (let j = i + 1; j < teams.length; j++) {
                    const overlap = calculateOverlap(teams[i], teams[j]);
                    overlaps.push({
                        team1: teams[i],
                        team2: teams[j],
                        ...overlap,
                        score: overlap.coverage - overlap.empty + (overlap.duplications * 0.5)
                    });
                }
            }
            
            // Sort by coverage (descending), then by empty (ascending)
            overlaps.sort((a, b) => b.coverage - a.coverage || a.empty - b.empty);
            
            let html = '';
            overlaps.slice(0, 20).forEach((o, idx) => {
                html += `
                    <div class="overlap-card">
                        <div class="team-pair">
                            <span>#${idx + 1}</span>
                            ${o.team1} + ${o.team2}
                        </div>
                        <div class="overlap-stats">
                            <div class="stat-item">
                                <div class="stat-value good">${o.coverage}</div>
                                <div class="stat-label">Coverage</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value neutral">${o.duplications}</div>
                                <div class="stat-label">Both Easy</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value bad">${o.empty}</div>
                                <div class="stat-label">Empty GWs</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Create synergy heatmap data
            createSynergyHeatmap(overlaps);
        }
        
        // Create synergy heatmap
        function createSynergyHeatmap(overlaps) {
            const ctx = document.getElementById('synergyHeatmap').getContext('2d');
            
            // Create matrix data
            const matrix = {};
            teams.forEach(t1 => {
                matrix[t1] = {};
                teams.forEach(t2 => {
                    if (t1 === t2) {
                        matrix[t1][t2] = gameweeks.length; // Max coverage with self
                    } else {
                        const overlap = overlaps.find(o => 
                            (o.team1 === t1 && o.team2 === t2) || 
                            (o.team1 === t2 && o.team2 === t1)
                        );
                        matrix[t1][t2] = overlap ? overlap.coverage : 0;
                    }
                });
            });
            
            // Prepare data for chart
            const data = [];
            teams.forEach((t1, i) => {
                teams.forEach((t2, j) => {
                    data.push({
                        x: j,
                        y: i,
                        v: matrix[t1][t2]
                    });
                });
            });
            
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Coverage',
                        data: data,
                        backgroundColor: function(context) {
                            const value = context.raw.v;
                            const alpha = value / gameweeks.length;
                            return `rgba(16, 185, 129, ${alpha})`;
                        },
                        pointRadius: 15,
                        pointHoverRadius: 18
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const x = context.raw.x;
                                    const y = context.raw.y;
                                    return `${teams[y]} + ${teams[x]}: ${context.raw.v} GWs covered`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: -0.5,
                            max: teams.length - 0.5,
                            ticks: {
                                callback: function(value) {
                                    return teams[value] ? teams[value].substring(0, 3) : '';
                                },
                                stepSize: 1,
                                color: '#94a3b8'
                            },
                            grid: { color: '#334155' }
                        },
                        y: {
                            type: 'linear',
                            min: -0.5,
                            max: teams.length - 0.5,
                            ticks: {
                                callback: function(value) {
                                    return teams[value] ? teams[value].substring(0, 3) : '';
                                },
                                stepSize: 1,
                                color: '#94a3b8'
                            },
                            grid: { color: '#334155' }
                        }
                    }
                }
            });
        }
        
        // Update GW range display
        function updateGWRange() {
            const fromGW = parseInt(document.getElementById('paramFromGW').value);
            const toGW = parseInt(document.getElementById('paramToGW').value);
            const numGWs = Math.max(0, toGW - fromGW + 1);
            
            // Update max for minSuccess based on range
            document.getElementById('paramMinEasy').max = numGWs;
            
            const infoEl = document.getElementById('gwRangeInfo');
            if (infoEl) {
                infoEl.innerHTML = `📅 Analyzing <strong>GW${fromGW}</strong> to <strong>GW${toGW}</strong> (${numGWs} gameweeks)`;
            }
        }
        
        // Run N-K-D simulation - OPTIMIZED VERSION
        async function runSimulation() {
            const N = parseInt(document.getElementById('paramN').value); // Total players to select
            const K = parseInt(document.getElementById('paramK').value); // Min players with easy game per GW for success
            const D = parseInt(document.getElementById('paramD').value); // Max players from same team
            const minSuccess = parseInt(document.getElementById('paramMinEasy').value); // Min success GWs required
            const fromGW = parseInt(document.getElementById('paramFromGW').value) || 21; // Start GW
            const toGW = parseInt(document.getElementById('paramToGW').value) || 38; // End GW
            
            // Calculate GW indices relative to gwStart (21)
            const gwStartIdx = fromGW - gwStart;
            const gwEndIdx = toGW - gwStart;
            const selectedGWs = gameweeks.slice(gwStartIdx, gwEndIdx + 1);
            
            const statusEl = document.getElementById('simulationStatus');
            const resultsEl = document.getElementById('simulationResults');
            const progressEl = document.getElementById('simProgress');
            
            statusEl.style.display = 'block';
            statusEl.textContent = 'Generating player combinations...';
            resultsEl.innerHTML = '';
            
            // Calculate team scores FOR SELECTED GW RANGE
            const teamScores = {};
            teams.forEach(team => {
                let easyCount = 0;
                for (let gwIdx = gwStartIdx; gwIdx <= gwEndIdx; gwIdx++) {
                    if (fixtureData[team] && fixtureData[team][gwIdx] <= EASY_THRESHOLD) {
                        easyCount++;
                    }
                }
                teamScores[team] = easyCount;
            });
            
            // Sort teams by easy games (best first) - only consider top teams
            const sortedTeams = [...teams].sort((a, b) => teamScores[b] - teamScores[a]);
            
            // OPTIMIZATION: Only consider top 12 teams (reduces combinations dramatically)
            const topTeams = sortedTeams.slice(0, Math.min(12, sortedTeams.length));
            
            const validResults = [];
            let count = 0;
            const MAX_ITERATIONS = 100000; // Safety limit
            let stopped = false;
            
            function evaluateDistribution(dist) {
                const teamsUsed = Object.entries(dist).filter(([t, n]) => n > 0);
                const teamList = teamsUsed.map(([t]) => t);
                
                let successGWs = 0;
                let totalEasyPlayers = 0;
                const gwBreakdown = [];
                
                // Use selected GW range instead of all gameweeks
                for (let gwIdx = gwStartIdx; gwIdx <= gwEndIdx; gwIdx++) {
                    let easyPlayers = 0;
                    teamsUsed.forEach(([team, numPlayers]) => {
                        if (fixtureData[team] && fixtureData[team][gwIdx] <= EASY_THRESHOLD) {
                            easyPlayers += numPlayers;
                        }
                    });
                    
                    totalEasyPlayers += easyPlayers;
                    if (easyPlayers >= K) successGWs++;
                    gwBreakdown.push({ gw: `GW${gwIdx + gwStart}`, easy: easyPlayers });
                }
                
                const failedGWs = gwBreakdown.filter(g => g.easy < K).map(g => g.gw);
                
                return {
                    distribution: dist,
                    teams: teamList,
                    teamsWithCounts: teamsUsed.map(([t, n]) => `${t}×${n}`),
                    successGWs,
                    totalEasyPlayers,
                    failedGWs,
                    score: (successGWs * 1000) + totalEasyPlayers
                };
            }
            
            // Use iterative approach with stack instead of recursion
            const stack = [{ remaining: N, teamIdx: 0, dist: {} }];
            
            while (stack.length > 0 && !stopped) {
                if (count >= MAX_ITERATIONS) {
                    stopped = true;
                    break;
                }
                
                const { remaining, teamIdx, dist } = stack.pop();
                
                if (remaining === 0) {
                    const result = evaluateDistribution(dist);
                    if (result.successGWs >= minSuccess) {
                        validResults.push(result);
                    }
                    count++;
                    continue;
                }
                
                if (teamIdx >= topTeams.length) {
                    count++;
                    continue;
                }
                
                // Pruning
                const maxPossible = (topTeams.length - teamIdx) * D;
                if (maxPossible < remaining) {
                    count++;
                    continue;
                }
                
                const team = topTeams[teamIdx];
                
                // Try 0 to min(D, remaining) players from this team
                for (let numPlayers = 0; numPlayers <= Math.min(D, remaining); numPlayers++) {
                    const newDist = { ...dist };
                    if (numPlayers > 0) {
                        newDist[team] = numPlayers;
                    }
                    stack.push({ remaining: remaining - numPlayers, teamIdx: teamIdx + 1, dist: newDist });
                }
                
                count++;
                
                // Yield to browser every 5000 iterations
                if (count % 5000 === 0) {
                    const progress = Math.min(95, (count / MAX_ITERATIONS) * 100);
                    progressEl.style.width = progress + '%';
                    statusEl.textContent = `Processing... ${count.toLocaleString()} combinations checked, ${validResults.length} valid found`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            
            await new Promise(r => setTimeout(r, 10));
            
            // Sort by score
            validResults.sort((a, b) => b.score - a.score);
            
            // Deduplicate by team set (same teams, same counts)
            const seen = new Set();
            const uniqueResults = validResults.filter(r => {
                const key = r.teamsWithCounts.sort().join('|');
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
            
            statusEl.style.display = 'none';
            progressEl.style.width = '100%';
            
            // Display results
            const numGWs = gwEndIdx - gwStartIdx + 1;
            let html = `<p style="margin-bottom: 1rem; color: var(--text-secondary);">
                Found <strong>${uniqueResults.length}</strong> valid combinations of <strong>${N} players</strong> 
                (max ${D}/team) with <strong>≥${K} easy players</strong> in <strong>${minSuccess}+</strong> of <strong>${numGWs}</strong> gameweeks
                <br><span style="color: var(--accent-cyan);">📅 Range: GW${fromGW} → GW${toGW}</span>
            </p>`;
            
            if (uniqueResults.length === 0) {
                html += `<p style="color: var(--accent-rose);">No combinations found! Try:<br>
                • Lowering K (min easy players per GW)<br>
                • Lowering Min Success GWs<br>
                • Increasing D (max per team)<br>
                • Widening the GW range</p>`;
            }
            
            uniqueResults.slice(0, 50).forEach((r, idx) => {
                const teamStr = r.teamsWithCounts.join(', ');
                const failedStr = r.failedGWs.length > 0 
                    ? `<span style="color: var(--accent-rose);">Failed: ${r.failedGWs.slice(0, 5).join(', ')}${r.failedGWs.length > 5 ? '...' : ''}</span>` 
                    : '<span style="color: var(--easy-game);">✓ All GWs success!</span>';
                html += `
                    <div class="result-row">
                        <div class="result-rank">#${idx + 1}</div>
                        <div class="result-teams">
                            <div>${teamStr}</div>
                            <div style="font-size: 0.75rem; margin-top: 0.25rem;">${failedStr}</div>
                        </div>
                        <div class="result-score">
                            <div style="color: var(--easy-game);">${r.successGWs}/${gameweeks.length} success</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">${r.totalEasyPlayers} total easy</div>
                        </div>
                    </div>
                `;
            });
            
            resultsEl.innerHTML = html;
        }
        
        // Create charts
        function createCharts() {
            // Easy games bar chart
            const easyCtx = document.getElementById('easyGamesChart').getContext('2d');
            const easyData = teams.map(team => ({
                team,
                easy: fixtureData[team].filter(f => f <= 2).length,
                hard: fixtureData[team].filter(f => f > 2).length
            })).sort((a, b) => b.easy - a.easy);
            
            new Chart(easyCtx, {
                type: 'bar',
                data: {
                    labels: easyData.map(d => d.team),
                    datasets: [
                        {
                            label: 'Easy Games',
                            data: easyData.map(d => d.easy),
                            backgroundColor: '#10b981'
                        },
                        {
                            label: 'Hard/No Easy',
                            data: easyData.map(d => d.hard),
                            backgroundColor: '#ef4444'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            labels: { color: '#94a3b8' }
                        }
                    },
                    scales: {
                        x: { 
                            stacked: true,
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            stacked: true,
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        }
                    }
                }
            });
            
            // Difficulty trend chart
            const trendCtx = document.getElementById('difficultyTrendChart').getContext('2d');
            const avgDifficulty = gameweeks.map((_, idx) => {
                const sum = teams.reduce((acc, team) => acc + fixtureData[team][idx], 0);
                return (sum / teams.length).toFixed(2);
            });
            
            const easyTeamsPerGW = gameweeks.map((_, idx) => {
                return teams.filter(team => fixtureData[team][idx] <= 2).length;
            });
            
            new Chart(trendCtx, {
                type: 'line',
                data: {
                    labels: gameweeks,
                    datasets: [
                        {
                            label: 'Teams with Easy Games',
                            data: easyTeamsPerGW,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            fill: true,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            labels: { color: '#94a3b8' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        }
                    }
                }
            });
            
            // Coverage chart (how many teams needed for full coverage)
            const coverageCtx = document.getElementById('coverageChart').getContext('2d');
            const coverageData = [];
            
            for (let numTeams = 1; numTeams <= 10; numTeams++) {
                // Find best coverage with N teams
                let bestCoverage = 0;
                
                // Simple greedy approach
                const selectedTeams = [];
                const availableTeams = [...teams];
                
                for (let i = 0; i < numTeams; i++) {
                    let bestTeam = null;
                    let bestAddedCoverage = 0;
                    
                    availableTeams.forEach(team => {
                        let addedCoverage = 0;
                        for (let gw = 0; gw < gameweeks.length; gw++) {
                            const currentlyEasy = selectedTeams.some(t => fixtureData[t][gw] <= 2);
                            const teamEasy = fixtureData[team][gw] <= 2;
                            if (teamEasy && !currentlyEasy) addedCoverage++;
                        }
                        if (addedCoverage > bestAddedCoverage) {
                            bestAddedCoverage = addedCoverage;
                            bestTeam = team;
                        }
                    });
                    
                    if (bestTeam) {
                        selectedTeams.push(bestTeam);
                        availableTeams.splice(availableTeams.indexOf(bestTeam), 1);
                    }
                }
                
                // Calculate total coverage
                let totalCoverage = 0;
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    if (selectedTeams.some(t => fixtureData[t][gw] <= 2)) {
                        totalCoverage++;
                    }
                }
                
                coverageData.push({
                    teams: numTeams,
                    coverage: totalCoverage,
                    percent: ((totalCoverage / gameweeks.length) * 100).toFixed(1)
                });
            }
            
            new Chart(coverageCtx, {
                type: 'bar',
                data: {
                    labels: coverageData.map(d => `${d.teams} Team${d.teams > 1 ? 's' : ''}`),
                    datasets: [{
                        label: 'GWs Covered (%)',
                        data: coverageData.map(d => d.percent),
                        backgroundColor: 'rgba(34, 211, 238, 0.7)',
                        borderColor: '#22d3ee',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            labels: { color: '#94a3b8' }
                        }
                    },
                    scales: {
                        x: { 
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' }
                        },
                        y: { 
                            max: 100,
                            ticks: { 
                                color: '#94a3b8',
                                callback: v => v + '%'
                            },
                            grid: { color: '#334155' }
                        }
                    }
                }
            });
            
            // Correlation chart
            const corrCtx = document.getElementById('correlationChart').getContext('2d');
            
            // Calculate correlation-like metric between teams
            const correlations = teams.slice(0, 10).map(team => {
                const easyGWs = getEasyGameweeks(team);
                return {
                    team,
                    uniqueness: Array.from(easyGWs).filter(gw => {
                        return teams.filter(t => t !== team && fixtureData[t][gw] <= 2).length < 5;
                    }).length
                };
            }).sort((a, b) => b.uniqueness - a.uniqueness);
            
            new Chart(corrCtx, {
                type: 'radar',
                data: {
                    labels: correlations.map(c => c.team),
                    datasets: [{
                        label: 'Fixture Uniqueness Score',
                        data: correlations.map(c => c.uniqueness),
                        backgroundColor: 'rgba(139, 92, 246, 0.2)',
                        borderColor: '#8b5cf6',
                        borderWidth: 2,
                        pointBackgroundColor: '#8b5cf6'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            labels: { color: '#94a3b8' }
                        }
                    },
                    scales: {
                        r: {
                            ticks: { color: '#94a3b8' },
                            grid: { color: '#334155' },
                            pointLabels: { color: '#94a3b8' }
                        }
                    }
                }
            });
        }
        
        // Squad builder
        const squadSelection = {
            gk: [],
            def: [],
            mid: [],
            fwd: []
        };
        
        function renderSquadBuilder() {
            const container = document.getElementById('teamSelection');
            const positions = [
                { key: 'gk', name: 'Goalkeepers', max: 2, badge: 'gk' },
                { key: 'def', name: 'Defenders', max: 5, badge: 'def' },
                { key: 'mid', name: 'Midfielders', max: 5, badge: 'mid' },
                { key: 'fwd', name: 'Forwards', max: 3, badge: 'fwd' }
            ];
            
            let html = '';
            
            positions.forEach(pos => {
                html += `
                    <div class="position-section">
                        <div class="position-title">
                            <span class="position-badge ${pos.badge}">${pos.key.toUpperCase()}</span>
                            ${pos.name} (Select ${pos.max} teams)
                        </div>
                        <div class="player-checkboxes">
                `;
                
                teams.forEach(team => {
                    const easyCount = fixtureData[team].filter(f => f <= 2).length;
                    html += `
                        <label class="player-checkbox" data-position="${pos.key}" data-team="${team}">
                            <input type="checkbox" onchange="toggleTeamSelection('${pos.key}', '${team}', this)">
                            ${team} <span style="color: var(--easy-game)">(${easyCount})</span>
                        </label>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html;
        }
        
        function toggleTeamSelection(position, team, checkbox) {
            const label = checkbox.closest('.player-checkbox');
            const maxSlots = { gk: 2, def: 5, mid: 5, fwd: 3 };
            
            if (checkbox.checked) {
                if (squadSelection[position].length < maxSlots[position]) {
                    squadSelection[position].push(team);
                    label.classList.add('selected');
                } else {
                    checkbox.checked = false;
                    alert(`Maximum ${maxSlots[position]} ${position.toUpperCase()} allowed`);
                }
            } else {
                squadSelection[position] = squadSelection[position].filter(t => t !== team);
                label.classList.remove('selected');
            }
            
            updateSquadCounter();
        }
        
        function updateSquadCounter() {
            document.getElementById('gkCount').textContent = `${squadSelection.gk.length}/2`;
            document.getElementById('defCount').textContent = `${squadSelection.def.length}/5`;
            document.getElementById('midCount').textContent = `${squadSelection.mid.length}/5`;
            document.getElementById('fwdCount').textContent = `${squadSelection.fwd.length}/3`;
            
            const total = squadSelection.gk.length + squadSelection.def.length + 
                         squadSelection.mid.length + squadSelection.fwd.length;
            document.getElementById('totalCount').textContent = `${total}/15`;
        }
        
        function analyzeSquad() {
            const allTeams = [
                ...squadSelection.gk,
                ...squadSelection.def,
                ...squadSelection.mid,
                ...squadSelection.fwd
            ];
            
            if (allTeams.length === 0) {
                alert('Please select at least one team');
                return;
            }
            
            const uniqueTeams = [...new Set(allTeams)];
            
            // Calculate coverage
            let coverage = 0;
            const gwCoverage = [];
            
            for (let gw = 0; gw < gameweeks.length; gw++) {
                const easyTeams = allTeams.filter(team => fixtureData[team][gw] <= 2);
                if (easyTeams.length > 0) {
                    coverage++;
                    gwCoverage.push({ gw: gameweeks[gw], teams: easyTeams.length });
                } else {
                    gwCoverage.push({ gw: gameweeks[gw], teams: 0 });
                }
            }
            
            const analysisEl = document.getElementById('squadAnalysis');
            
            let html = `
                <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">Coverage Analysis</div>
                    <div style="color: var(--easy-game); font-size: 1.25rem; font-weight: 700;">
                        ${coverage}/${gameweeks.length} GWs (${((coverage/gameweeks.length)*100).toFixed(1)}%)
                    </div>
                    <div style="margin-top: 0.75rem; font-size: 0.85rem; color: var(--text-secondary);">
                        <div>Unique teams: ${uniqueTeams.length}</div>
                        <div style="margin-top: 0.5rem;">
                            Empty GWs: ${gwCoverage.filter(g => g.teams === 0).map(g => g.gw).join(', ') || 'None!'}
                        </div>
                    </div>
                </div>
            `;
            
            analysisEl.innerHTML = html;
        }
        
        // Auto Squad Optimizer - Greedy Algorithm
        async function runAutoOptimizer() {
            const defFwdWeight = parseFloat(document.getElementById('defFwdWeight').value);
            const midWeight = parseFloat(document.getElementById('midWeight').value);
            const gkWeight = parseFloat(document.getElementById('gkWeight').value);
            
            const resultsEl = document.getElementById('optimizerResults');
            resultsEl.innerHTML = '<div class="loading">Calculating optimal squad</div>';
            
            await new Promise(r => setTimeout(r, 50));
            
            // Calculate team scores (easy games count)
            const teamScores = {};
            teams.forEach(team => {
                const easyCount = fixtureData[team].filter(f => f <= 2).length;
                teamScores[team] = easyCount;
            });
            
            // Sort teams by score (descending)
            const sortedTeams = [...teams].sort((a, b) => teamScores[b] - teamScores[a]);
            
            // Position requirements - fill in priority order (DEF/FWD first)
            const posOrder = [
                { pos: 'fwd', count: 3, weight: defFwdWeight },
                { pos: 'def', count: 5, weight: defFwdWeight },
                { pos: 'mid', count: 5, weight: midWeight },
                { pos: 'gk', count: 2, weight: gkWeight }
            ];
            
            // Greedy fill with constraint checking
            const bestSquad = { gk: [], def: [], mid: [], fwd: [] };
            const teamCounts = {}; // Total players per team
            const positionCounts = { gk: {}, def: {}, mid: {}, fwd: {} }; // Players per team per position
            
            // For each position (in priority order)
            for (const { pos, count, weight } of posOrder) {
                // Calculate weighted score for each team considering coverage gaps
                const teamPriority = sortedTeams.map(team => {
                    const baseScore = teamScores[team] * weight;
                    
                    // Bonus for filling coverage gaps
                    let coverageBonus = 0;
                    const currentTeams = [...bestSquad.gk, ...bestSquad.def, ...bestSquad.mid, ...bestSquad.fwd];
                    for (let gw = 0; gw < gameweeks.length; gw++) {
                        const alreadyCovered = currentTeams.some(t => fixtureData[t][gw] <= 2);
                        const teamCovers = fixtureData[team][gw] <= 2;
                        if (!alreadyCovered && teamCovers) {
                            coverageBonus += 10; // Big bonus for new coverage
                        }
                    }
                    
                    return { team, score: baseScore + coverageBonus };
                }).sort((a, b) => b.score - a.score);
                
                // Fill this position
                for (const { team } of teamPriority) {
                    if (bestSquad[pos].length >= count) break;
                    
                    const totalForTeam = teamCounts[team] || 0;
                    const inThisPos = positionCounts[pos][team] || 0;
                    
                    // Check constraints: max 3 total, max 2 per position
                    if (totalForTeam >= 3) continue;
                    if (inThisPos >= 2) continue;
                    
                    // Add to squad
                    bestSquad[pos].push(team);
                    teamCounts[team] = totalForTeam + 1;
                    positionCounts[pos][team] = inThisPos + 1;
                }
            }
            
            // Display results
            const allTeams = [...bestSquad.gk, ...bestSquad.def, ...bestSquad.mid, ...bestSquad.fwd];
            
            if (allTeams.length < 15) {
                resultsEl.innerHTML = '<p style="color: var(--accent-rose);">Could not fill all positions! Try different weights.</p>';
                return;
            }
            const uniqueTeams = [...new Set(allTeams)];
            let coverage = 0;
            const emptyGWs = [];
            
            for (let gw = 0; gw < gameweeks.length; gw++) {
                if (allTeams.some(team => fixtureData[team][gw] <= 2)) {
                    coverage++;
                } else {
                    emptyGWs.push(gameweeks[gw]);
                }
            }
            
            // Use teamCounts from greedy fill
            const teamDistribution = teamCounts;
            
            let html = `
                <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(34, 211, 238, 0.15)); border-radius: 16px; padding: 1.5rem; border: 1px solid var(--easy-game);">
                    <h3 style="margin-bottom: 1rem; color: var(--easy-game);">🏆 Optimal Squad Found!</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                        <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--easy-game);">${coverage}/${gameweeks.length}</div>
                            <div style="color: var(--text-muted); font-size: 0.85rem;">GW Coverage</div>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--accent-cyan);">${uniqueTeams.length}</div>
                            <div style="color: var(--text-muted); font-size: 0.85rem;">Unique Teams</div>
                        </div>
                    </div>
                    
                    ${emptyGWs.length > 0 ? `<div style="background: rgba(239, 68, 68, 0.2); padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.85rem;">
                        <strong style="color: var(--accent-rose);">⚠️ Empty GWs:</strong> ${emptyGWs.join(', ')}
                    </div>` : `<div style="background: rgba(16, 185, 129, 0.2); padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.85rem; color: var(--easy-game);">
                        ✅ Full coverage! No empty gameweeks.
                    </div>`}
            `;
            
            // Position breakdown
            const posLabels = {
                gk: { name: '🧤 Goalkeepers', color: '#eab308' },
                def: { name: '🛡️ Defenders', color: '#3b82f6' },
                mid: { name: '⚡ Midfielders', color: '#22c55e' },
                fwd: { name: '⚽ Forwards', color: '#ef4444' }
            };
            
            for (const [pos, config] of Object.entries(posLabels)) {
                const posTeams = bestSquad[pos];
                html += `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: ${config.color};">${config.name}</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                `;
                
                posTeams.forEach(team => {
                    const easyCount = teamScores[team];
                    html += `
                        <span style="background: var(--bg-tertiary); padding: 0.5rem 0.75rem; border-radius: 8px; font-size: 0.85rem; border: 1px solid ${config.color}40;">
                            ${team} <span style="color: var(--easy-game);">(${easyCount})</span>
                        </span>
                    `;
                });
                
                html += '</div></div>';
            }
            
            // Team distribution
            html += `
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                    <div style="font-weight: 600; margin-bottom: 0.75rem;">📊 Team Distribution</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            `;
            
            const sortedDist = Object.entries(teamDistribution).sort((a, b) => b[1] - a[1]);
            sortedDist.forEach(([team, count]) => {
                const barColor = count === 3 ? 'var(--accent-rose)' : count === 2 ? 'var(--accent-amber)' : 'var(--accent-cyan)';
                html += `
                    <span style="background: var(--bg-secondary); padding: 0.4rem 0.75rem; border-radius: 6px; font-size: 0.8rem;">
                        ${team}: <strong style="color: ${barColor};">${count}</strong>
                    </span>
                `;
            });
            
            html += '</div></div>';
            
            // Position recommendations
            html += `
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                    <div style="font-weight: 600; margin-bottom: 0.75rem;">💡 Team Priority by Position</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
            `;
            
            // Show best teams for each position
            const topTeams = sortedTeams.slice(0, 8);
            html += `
                <div style="margin-bottom: 0.5rem;"><strong style="color: #ef4444;">FWD (×3):</strong> Pick from: ${topTeams.slice(0, 5).map(t => `${t} (${teamScores[t]})`).join(', ')}</div>
                <div style="margin-bottom: 0.5rem;"><strong style="color: #3b82f6;">DEF (×5):</strong> Pick from: ${topTeams.slice(0, 7).map(t => `${t} (${teamScores[t]})`).join(', ')}</div>
                <div style="margin-bottom: 0.5rem;"><strong style="color: #22c55e;">MID (×5):</strong> Fill gaps with: ${sortedTeams.slice(2, 10).map(t => `${t} (${teamScores[t]})`).join(', ')}</div>
                <div><strong style="color: #eab308;">GK (×2):</strong> Rotation pair: ${sortedTeams.slice(0, 4).map(t => `${t} (${teamScores[t]})`).join(', ')}</div>
            `;
            
            html += '</div></div></div>';
            
            resultsEl.innerHTML = html;
        }
        
        // Tab switching
        async function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
            
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
            
            // Initialize players manager when tab is shown
            if (tabId === 'players') {
                initPlayersManager();
            }
            
            // Initialize my squad analyzer when tab is shown
            if (tabId === 'mysquad') {
                initMySquadAnalyzer();
            }
            
            // Initialize league import when tab is shown
            if (tabId === 'leagueimport') {
                await initLeagueImport();
            }
            
            // Initialize free agents when tab is shown
            if (tabId === 'freeagents') {
                initFreeAgents();
            }
            
            // Auto-load predicted lineups when tab is shown
            if (tabId === 'lineups') {
                loadPredictedLineups();
            }
        }
        
        // ============================================
        // MANUAL FDR OVERRIDE SYSTEM
        // ============================================
        
        let editMode = false;
        let manualOverrides = JSON.parse(localStorage.getItem('fdrOverrides') || '{}');
        
        function toggleEditMode() {
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const table = document.querySelector('.fixture-table');
            
            if (editMode) {
                btn.innerHTML = '✅ Disable Edit Mode';
                btn.style.background = 'var(--accent-emerald)';
                btn.style.color = '#000';
                table?.classList.add('edit-mode');
            } else {
                btn.innerHTML = '✏️ Enable Edit Mode';
                btn.style.background = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-primary)';
                table?.classList.remove('edit-mode');
            }
            
            renderFixtureGrid();
        }
        
        function handleCellClick(team, gwNum, event) {
            if (!editMode) return;
            
            // Remove any existing popup
            document.querySelectorAll('.fdr-edit-popup').forEach(p => p.remove());
            
            const popup = document.createElement('div');
            popup.className = 'fdr-edit-popup';
            popup.style.left = event.pageX + 'px';
            popup.style.top = event.pageY + 'px';
            
            const currentOverride = manualOverrides[`${team}-${gwNum}`];
            
            popup.innerHTML = `
                <div style="margin-bottom: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                    ${team} - GW${gwNum}
                </div>
                <select onchange="setManualOverride('${team}', ${gwNum}, this.value); this.parentElement.remove();">
                    <option value="">-- Select FDR --</option>
                    <option value="1" ${currentOverride == 1 ? 'selected' : ''}>1 - Very Easy</option>
                    <option value="2" ${currentOverride == 2 ? 'selected' : ''}>2 - Easy</option>
                    <option value="3" ${currentOverride == 3 ? 'selected' : ''}>3 - Medium</option>
                    <option value="4" ${currentOverride == 4 ? 'selected' : ''}>4 - Hard</option>
                    <option value="5" ${currentOverride == 5 ? 'selected' : ''}>5 - Very Hard</option>
                    <option value="clear" style="color: var(--accent-rose);">🗑️ Clear Override</option>
                </select>
                <button onclick="this.parentElement.remove()" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; cursor: pointer;">✕</button>
            `;
            
            document.body.appendChild(popup);
            
            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                });
            }, 100);
        }
        
        function setManualOverride(team, gwNum, value) {
            const key = `${team}-${gwNum}`;
            
            if (value === 'clear' || value === '') {
                delete manualOverrides[key];
            } else {
                manualOverrides[key] = parseFloat(value);
            }
            
            localStorage.setItem('fdrOverrides', JSON.stringify(manualOverrides));
            
            // Update fixture data with overrides
            fixtureData = createWeightedFixtureData();
            applyManualOverrides();
            
            renderFixtureGrid();
            updateOverrideCount();
        }
        
        function applyManualOverrides() {
            Object.entries(manualOverrides).forEach(([key, value]) => {
                const [team, gw] = key.split('-');
                const gwNum = parseInt(gw);
                const idx = gwNum - gwStart;
                if (fixtureData[team] && idx >= 0 && idx < fixtureData[team].length) {
                    fixtureData[team][idx] = value;
                }
            });
        }
        
        function clearManualOverrides() {
            if (confirm('Clear all manual FDR overrides?')) {
                manualOverrides = {};
                localStorage.removeItem('fdrOverrides');
                fixtureData = createWeightedFixtureData();
                renderFixtureGrid();
                updateOverrideCount();
            }
        }
        
        function updateOverrideCount() {
            const count = Object.keys(manualOverrides).length;
            const el = document.getElementById('overrideCount');
            if (el) {
                el.textContent = count > 0 ? `(${count} manual override${count > 1 ? 's' : ''})` : '';
                el.style.color = count > 0 ? 'var(--accent-amber)' : 'var(--text-muted)';
            }
        }
        
        // ============================================
        // ALWAYS START PLAYERS SYSTEM
        // ============================================
        
        let alwaysStartPlayers = JSON.parse(localStorage.getItem('alwaysStartPlayers') || '[]');
        
        function initPlayersManager() {
            // Populate team filter - use ALL players including unlikely ones
            const teamFilter = document.getElementById('playerFilterTeam');
            if (teamFilter && teamFilter.options.length <= 1) {
                const playerTeams = [...new Set(allWishlistPlayers.map(p => p.team))].sort();
                playerTeams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team;
                    option.textContent = team;
                    teamFilter.appendChild(option);
                });
            }
            renderPlayersManager();
        }
        
        function renderPlayersManager() {
            const container = document.getElementById('playersManagerGrid');
            if (!container) return;
            
            const posFilter = document.getElementById('playerFilterPos')?.value || 'all';
            const teamFilter = document.getElementById('playerFilterTeam')?.value || 'all';
            const search = document.getElementById('playerSearch')?.value?.toLowerCase() || '';
            const showUnlikely = document.getElementById('showUnlikelyPlayers')?.checked || false;
            
            // Use ALL players, not just available ones
            let filtered = allWishlistPlayers.filter(p => {
                if (posFilter !== 'all' && p.position !== posFilter) return false;
                if (teamFilter !== 'all' && p.team !== teamFilter) return false;
                if (search && !p.name.toLowerCase().includes(search)) return false;
                // Filter unlikely players unless checkbox is checked
                if (!showUnlikely && p.playingChance <= 0) return false;
                return true;
            });
            
            // Sort: always-start first, then by rank
            filtered.sort((a, b) => {
                const aStart = alwaysStartPlayers.includes(a.rank);
                const bStart = alwaysStartPlayers.includes(b.rank);
                if (aStart && !bStart) return -1;
                if (!aStart && bStart) return 1;
                return a.rank - b.rank;
            });
            
            let html = '';
            filtered.forEach(p => {
                const isAlwaysStart = alwaysStartPlayers.includes(p.rank);
                const isUnlikely = p.playingChance <= 0;
                html += `
                    <div class="player-manager-card ${isAlwaysStart ? 'always-start' : ''} ${isUnlikely ? 'unlikely' : ''}" onclick="toggleAlwaysStart(${p.rank})">
                        <div class="player-rank">#${p.rank}</div>
                        <div class="player-info">
                            <div class="player-name">${p.name}${isUnlikely ? ' <span style="color: var(--accent-rose); font-size: 0.7rem;">⚠️</span>' : ''}</div>
                            <div class="player-meta">
                                <span class="pos-tag ${p.position.toLowerCase()}" style="font-size: 0.6rem; padding: 0.1rem 0.3rem;">${p.position}</span>
                                ${p.team} • Score: ${p.score}
                                ${isUnlikely ? '<span style="color: var(--accent-rose); font-size: 0.65rem; margin-left: 0.3rem;">Unlikely</span>' : ''}
                            </div>
                        </div>
                        <div class="star-toggle">⭐</div>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<div style="color: var(--text-muted); text-align: center; padding: 2rem;">No players found</div>';
            
            updateAlwaysStartDisplay();
        }
        
        function toggleAlwaysStart(rank) {
            const idx = alwaysStartPlayers.indexOf(rank);
            if (idx === -1) {
                alwaysStartPlayers.push(rank);
            } else {
                alwaysStartPlayers.splice(idx, 1);
            }
            
            localStorage.setItem('alwaysStartPlayers', JSON.stringify(alwaysStartPlayers));
            renderPlayersManager();
        }
        
        function updateAlwaysStartDisplay() {
            const countEl = document.getElementById('alwaysStartCount');
            const listEl = document.getElementById('alwaysStartList');
            
            if (countEl) {
                countEl.textContent = alwaysStartPlayers.length;
                countEl.style.color = alwaysStartPlayers.length > 0 ? 'var(--accent-emerald)' : 'var(--text-muted)';
            }
            
            if (listEl) {
                // Use ALL players so "unlikely" ones also show in the summary
                const players = allWishlistPlayers
                    .filter(p => alwaysStartPlayers.includes(p.rank))
                    .sort((a, b) => a.rank - b.rank);
                
                if (players.length === 0) {
                    listEl.innerHTML = '<em>No players marked as Always Start</em>';
                } else {
                    listEl.innerHTML = players.map(p => {
                        const isUnlikely = p.playingChance <= 0;
                        return `<span style="display: inline-block; background: var(--bg-secondary); padding: 0.2rem 0.5rem; border-radius: 4px; margin: 0.2rem; font-size: 0.75rem; ${isUnlikely ? 'opacity: 0.6; border: 1px dashed var(--accent-rose);' : ''}">
                            ⭐ ${p.name} (${p.position})${isUnlikely ? ' ⚠️' : ''}
                        </span>`;
                    }).join('');
                }
            }
        }
        
        function selectTopPlayers(n) {
            const sorted = [...availablePlayers].sort((a, b) => a.rank - b.rank);
            alwaysStartPlayers = sorted.slice(0, n).map(p => p.rank);
            localStorage.setItem('alwaysStartPlayers', JSON.stringify(alwaysStartPlayers));
            renderPlayersManager();
        }
        
        function clearAlwaysStart() {
            if (confirm('Clear all Always Start selections?')) {
                alwaysStartPlayers = [];
                localStorage.removeItem('alwaysStartPlayers');
                renderPlayersManager();
            }
        }
        
        // Check if player is marked as always-start
        function isAlwaysStartPlayer(player) {
            return alwaysStartPlayers.includes(player.rank);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize League Analyzer tab first (default tab)
            await initLeagueImport();
            
            // Apply manual overrides on load
            fixtureData = createWeightedFixtureData();
            applyManualOverrides();
            
            renderFixtureGrid();
            renderEasyGamesSummary();
            renderOverlapAnalysis();
            createCharts();
            renderSquadBuilder();
            updateOverrideCount();
        });
        
        // ============================================
        // MOCK DRAFT SIMULATOR
        // ============================================
        
        // Player wishlist data (from unified_wishlist.json)
        const wishlistPlayers = [
            { rank: 1, name: "Haaland", team: "City", position: "FWD", score: 153, playingChance: 100 },
            { rank: 2, name: "Gabriel", team: "Arsenal", position: "DEF", score: 97, playingChance: 100 },
            { rank: 3, name: "Ekitiké", team: "Liverpool", position: "FWD", score: 82, playingChance: 100 },
            { rank: 4, name: "Foden", team: "City", position: "MID", score: 93, playingChance: 100 },
            { rank: 5, name: "João Pedro", team: "Chelsea", position: "FWD", score: 81, playingChance: 100 },
            { rank: 6, name: "Saka", team: "Arsenal", position: "MID", score: 91, playingChance: 100 },
            { rank: 7, name: "B.Fernandes", team: "United", position: "MID", score: 99, playingChance: 0 },
            { rank: 8, name: "Rogers", team: "Villa", position: "MID", score: 93, playingChance: 100 },
            { rank: 9, name: "Guéhi", team: "Palace", position: "DEF", score: 95, playingChance: 100 },
            { rank: 10, name: "Bruno G.", team: "Newcastle", position: "MID", score: 96, playingChance: 100 },
            { rank: 11, name: "Watkins", team: "Villa", position: "FWD", score: 72, playingChance: 100 },
            { rank: 12, name: "Chalobah", team: "Chelsea", position: "DEF", score: 95, playingChance: 100 },
            { rank: 13, name: "Kudus", team: "Spurs", position: "MID", score: 71, playingChance: 100 },
            { rank: 14, name: "Semenyo", team: "Bournemouth", position: "MID", score: 113, playingChance: 100 },
            { rank: 15, name: "Saliba", team: "Arsenal", position: "DEF", score: 53, playingChance: 100 },
            { rank: 16, name: "Raya", team: "Arsenal", position: "GK", score: 79, playingChance: 100 },
            { rank: 17, name: "Rice", team: "Arsenal", position: "MID", score: 102, playingChance: 50 },
            { rank: 18, name: "Woltemade", team: "Newcastle", position: "FWD", score: 72, playingChance: 100 },
            { rank: 19, name: "Keane", team: "Everton", position: "DEF", score: 91, playingChance: 75 },
            { rank: 20, name: "Mateta", team: "Palace", position: "FWD", score: 67, playingChance: 100 },
            { rank: 21, name: "Tarkowski", team: "Everton", position: "DEF", score: 93, playingChance: 100 },
            { rank: 22, name: "Gakpo", team: "Liverpool", position: "MID", score: 66, playingChance: 100 },
            { rank: 23, name: "Thiago", team: "Brentford", position: "FWD", score: 89, playingChance: 100 },
            { rank: 24, name: "Wilson", team: "Fulham", position: "MID", score: 85, playingChance: 100 },
            { rank: 25, name: "Lacroix", team: "Palace", position: "DEF", score: 85, playingChance: 100 },
            { rank: 26, name: "Calafiori", team: "Arsenal", position: "DEF", score: 77, playingChance: 75 },
            { rank: 27, name: "J.Timber", team: "Arsenal", position: "DEF", score: 95, playingChance: 100 },
            { rank: 28, name: "Neto", team: "Chelsea", position: "MID", score: 81, playingChance: 100 },
            { rank: 29, name: "Virgil", team: "Liverpool", position: "DEF", score: 66, playingChance: 100 },
            { rank: 30, name: "Senesi", team: "Bournemouth", position: "DEF", score: 81, playingChance: 100 },
            { rank: 31, name: "Cunha", team: "United", position: "MID", score: 55, playingChance: 100 },
            { rank: 32, name: "Mbeumo", team: "United", position: "MID", score: 74, playingChance: 0 },
            { rank: 33, name: "Gyökeres", team: "Arsenal", position: "FWD", score: 50, playingChance: 100 },
            { rank: 34, name: "Palmer", team: "Chelsea", position: "MID", score: 33, playingChance: 100 },
            { rank: 35, name: "Dalot", team: "United", position: "DEF", score: 62, playingChance: 100 },
            { rank: 36, name: "Cucurella", team: "Chelsea", position: "DEF", score: 72, playingChance: 75 },
            { rank: 37, name: "Mitchell", team: "Palace", position: "DEF", score: 73, playingChance: 100 },
            { rank: 38, name: "Minteh", team: "Brighton", position: "MID", score: 79, playingChance: 75 },
            { rank: 39, name: "Cherki", team: "City", position: "MID", score: 66, playingChance: 100 },
            { rank: 40, name: "James", team: "Chelsea", position: "DEF", score: 81, playingChance: 100 },
            { rank: 41, name: "Konaté", team: "Liverpool", position: "DEF", score: 64, playingChance: 100 },
            { rank: 42, name: "Fofana", team: "Chelsea", position: "DEF", score: 41, playingChance: 100 },
            { rank: 43, name: "Bowen", team: "West Ham", position: "FWD", score: 84, playingChance: 100 },
            { rank: 44, name: "Enzo", team: "Chelsea", position: "MID", score: 80, playingChance: 100 },
            { rank: 45, name: "Grealish", team: "Everton", position: "MID", score: 67, playingChance: 100 },
            { rank: 46, name: "Szoboszlai", team: "Liverpool", position: "MID", score: 63, playingChance: 100 },
            { rank: 47, name: "Calvert-Lewin", team: "Leeds", position: "FWD", score: 78, playingChance: 100 },
            { rank: 48, name: "Gravenberch", team: "Liverpool", position: "MID", score: 84, playingChance: 100 },
            { rank: 49, name: "Reijnders", team: "City", position: "MID", score: 65, playingChance: 100 },
            { rank: 50, name: "Wissa", team: "Newcastle", position: "FWD", score: 9, playingChance: 100 },
            { rank: 51, name: "Kerkez", team: "Liverpool", position: "DEF", score: 41, playingChance: 100 },
            { rank: 52, name: "Wirtz", team: "Liverpool", position: "MID", score: 55, playingChance: 100 },
            { rank: 53, name: "Gordon", team: "Newcastle", position: "MID", score: 47, playingChance: 100 },
            { rank: 54, name: "Muñoz", team: "Palace", position: "DEF", score: 89, playingChance: 0 },
            { rank: 55, name: "Rúben", team: "City", position: "DEF", score: 84, playingChance: 100 },
            { rank: 56, name: "Pickford", team: "Everton", position: "GK", score: 86, playingChance: 100 },
            { rank: 57, name: "Roefs", team: "Sunderland", position: "GK", score: 83, playingChance: 100 },
            { rank: 58, name: "Donnarumma", team: "City", position: "GK", score: 59, playingChance: 100 },
            { rank: 59, name: "Sánchez", team: "Chelsea", position: "GK", score: 72, playingChance: 100 },
            { rank: 60, name: "Henderson", team: "Palace", position: "GK", score: 67, playingChance: 100 },
            { rank: 61, name: "Matheus N.", team: "City", position: "DEF", score: 80, playingChance: 100 },
            { rank: 62, name: "O'Reilly", team: "City", position: "DEF", score: 75, playingChance: 100 },
            { rank: 63, name: "Evanilson", team: "Bournemouth", position: "FWD", score: 49, playingChance: 100 },
            { rank: 64, name: "Gvardiol", team: "City", position: "DEF", score: 75, playingChance: 100 },
            { rank: 65, name: "Caicedo", team: "Chelsea", position: "MID", score: 67, playingChance: 0 },
            { rank: 66, name: "Schär", team: "Newcastle", position: "DEF", score: 40, playingChance: 100 },
            { rank: 67, name: "Cash", team: "Villa", position: "DEF", score: 76, playingChance: 0 },
            { rank: 68, name: "Ndiaye", team: "Everton", position: "MID", score: 73, playingChance: 0 },
            { rank: 69, name: "Richarlison", team: "Spurs", position: "FWD", score: 70, playingChance: 100 },
            { rank: 70, name: "Schade", team: "Brentford", position: "MID", score: 70, playingChance: 100 },
            { rank: 71, name: "Šeško", team: "United", position: "FWD", score: 40, playingChance: 100 },
            { rank: 72, name: "Van de Ven", team: "Spurs", position: "DEF", score: 76, playingChance: 100 },
            { rank: 73, name: "Trossard", team: "Arsenal", position: "MID", score: 77, playingChance: 100 },
            { rank: 74, name: "Digne", team: "Villa", position: "DEF", score: 54, playingChance: 100 },
            { rank: 75, name: "Martinez", team: "Villa", position: "GK", score: 60, playingChance: 100 },
            { rank: 76, name: "Collins", team: "Brentford", position: "DEF", score: 57, playingChance: 100 },
            { rank: 77, name: "Dewsbury-Hall", team: "Everton", position: "MID", score: 75, playingChance: 25 },
            { rank: 78, name: "Pope", team: "Newcastle", position: "GK", score: 57, playingChance: 100 },
            { rank: 79, name: "Bradley", team: "Liverpool", position: "DEF", score: 22, playingChance: 100 },
            { rank: 80, name: "Konsa", team: "Villa", position: "DEF", score: 53, playingChance: 100 },
            { rank: 81, name: "Lammens", team: "United", position: "GK", score: 38, playingChance: 100 },
            { rank: 82, name: "Doku", team: "City", position: "MID", score: 59, playingChance: 25 },
            { rank: 83, name: "Tonali", team: "Newcastle", position: "MID", score: 46, playingChance: 100 },
            { rank: 84, name: "Frimpong", team: "Liverpool", position: "DEF", score: 16, playingChance: 100 },
            { rank: 85, name: "O'Brien", team: "Everton", position: "DEF", score: 65, playingChance: 100 },
            { rank: 86, name: "Garner", team: "Everton", position: "MID", score: 85, playingChance: 100 },
            { rank: 87, name: "Casemiro", team: "United", position: "MID", score: 76, playingChance: 100 },
            { rank: 88, name: "Mykolenko", team: "Everton", position: "DEF", score: 54, playingChance: 100 },
            { rank: 89, name: "Dorgu", team: "United", position: "DEF", score: 45, playingChance: 100 },
            { rank: 90, name: "Shaw", team: "United", position: "DEF", score: 44, playingChance: 100 },
            { rank: 91, name: "Thiaw", team: "Newcastle", position: "DEF", score: 59, playingChance: 100 },
            { rank: 92, name: "Vicario", team: "Spurs", position: "GK", score: 67, playingChance: 100 },
            { rank: 93, name: "Amad", team: "United", position: "MID", score: 56, playingChance: 0 },
            { rank: 94, name: "Livramento", team: "Newcastle", position: "DEF", score: 47, playingChance: 25 },
            { rank: 95, name: "Joelinton", team: "Newcastle", position: "MID", score: 40, playingChance: 100 },
            { rank: 96, name: "Kelleher", team: "Brentford", position: "GK", score: 60, playingChance: 100 },
            { rank: 97, name: "Hall", team: "Newcastle", position: "DEF", score: 32, playingChance: 100 },
            { rank: 98, name: "Gusto", team: "Chelsea", position: "DEF", score: 69, playingChance: 100 },
            { rank: 99, name: "L.Paquetá", team: "West Ham", position: "MID", score: 67, playingChance: 100 },
            { rank: 100, name: "Petrović", team: "Bournemouth", position: "GK", score: 55, playingChance: 100 },
            { rank: 101, name: "Richards", team: "Palace", position: "DEF", score: 75, playingChance: 50 },
            { rank: 102, name: "Pedro Porro", team: "Spurs", position: "DEF", score: 60, playingChance: 100 },
            { rank: 103, name: "Sarr", team: "Palace", position: "MID", score: 52, playingChance: 0 },
            { rank: 104, name: "Xhaka", team: "Sunderland", position: "MID", score: 77, playingChance: 100 },
            { rank: 105, name: "Anderson", team: "Forest", position: "MID", score: 76, playingChance: 100 },
            { rank: 106, name: "A.Becker", team: "Liverpool", position: "GK", score: 45, playingChance: 100 },
            { rank: 107, name: "Welbeck", team: "Brighton", position: "FWD", score: 63, playingChance: 100 },
            { rank: 108, name: "Romero", team: "Spurs", position: "DEF", score: 59, playingChance: 100 },
            { rank: 109, name: "Andersen", team: "Fulham", position: "DEF", score: 68, playingChance: 100 },
            { rank: 110, name: "Verbruggen", team: "Brighton", position: "GK", score: 58, playingChance: 100 },
            { rank: 111, name: "Gibbs-White", team: "Forest", position: "MID", score: 64, playingChance: 100 },
            { rank: 112, name: "Areola", team: "West Ham", position: "GK", score: 40, playingChance: 100 },
            { rank: 113, name: "Van Hecke", team: "Brighton", position: "DEF", score: 69, playingChance: 100 },
            { rank: 114, name: "Leno", team: "Fulham", position: "GK", score: 58, playingChance: 100 },
            { rank: 115, name: "Lewis-Potter", team: "Brentford", position: "DEF", score: 53, playingChance: 100 },
            { rank: 116, name: "Mukiele", team: "Sunderland", position: "DEF", score: 74, playingChance: 100 },
            { rank: 117, name: "Alderete", team: "Sunderland", position: "DEF", score: 67, playingChance: 100 },
            { rank: 118, name: "Raúl", team: "Fulham", position: "FWD", score: 55, playingChance: 100 },
            { rank: 119, name: "Igor Jesus", team: "Forest", position: "FWD", score: 40, playingChance: 100 },
            { rank: 120, name: "Brobbey", team: "Sunderland", position: "FWD", score: 28, playingChance: 100 },
            { rank: 121, name: "Delap", team: "Chelsea", position: "FWD", score: 14, playingChance: 100 },
            { rank: 122, name: "Kolo Muani", team: "Spurs", position: "FWD", score: 18, playingChance: 100 },
            { rank: 123, name: "Barry", team: "Everton", position: "FWD", score: 34, playingChance: 100 },
            { rank: 124, name: "Kroupi.Jr", team: "Bournemouth", position: "FWD", score: 42, playingChance: 100 },
            { rank: 125, name: "Strand Larsen", team: "Wolves", position: "FWD", score: 31, playingChance: 100 },
            { rank: 126, name: "Beto", team: "Everton", position: "FWD", score: 30, playingChance: 100 },
            { rank: 127, name: "Sels", team: "Forest", position: "GK", score: 40, playingChance: 100 },
            { rank: 128, name: "Dúbravka", team: "Burnley", position: "GK", score: 59, playingChance: 100 }
        ];
        
        // Filter available players (>0% chance)
        const availablePlayers = wishlistPlayers.filter(p => p.playingChance > 0);
        
        // All players including "Unlikely to play" - for Players Manager
        const allWishlistPlayers = [...wishlistPlayers];
        
        // ============================================
        // PLAYER PREFERENCE LISTS FOR DIFFERENT STRATEGIES
        // ============================================
        
        // Top 6 teams for "big team" strategy
        const TOP_TEAMS = ['Liverpool', 'City', 'Arsenal', 'Chelsea', 'Palace', 'United'];
        
        // Strategy 1: By Rank (original list)
        const listByRank = [...availablePlayers].sort((a, b) => a.rank - b.rank);
        
        // Strategy 2: By Score (pure score chasing)
        const listByScore = [...availablePlayers].sort((a, b) => b.score - a.score);
        
        // Strategy 3: FWD First (prioritize forwards then by rank)
        const listFwdFirst = [...availablePlayers].sort((a, b) => {
            // Position priority: FWD > MID > DEF > GK
            const posPriority = { 'FWD': 0, 'MID': 1, 'DEF': 2, 'GK': 3 };
            const posCompare = posPriority[a.position] - posPriority[b.position];
            if (posCompare !== 0) return posCompare;
            return a.rank - b.rank;
        });
        
        // Strategy 4: Top Teams First (big 6 players first, then rest by rank)
        const listTopTeamsFirst = [...availablePlayers].sort((a, b) => {
            const aIsTop = TOP_TEAMS.includes(a.team) ? 0 : 1;
            const bIsTop = TOP_TEAMS.includes(b.team) ? 0 : 1;
            if (aIsTop !== bIsTop) return aIsTop - bIsTop;
            return a.rank - b.rank;
        });
        
        // All strategy lists
        const STRATEGY_LISTS = {
            'byRank': { name: 'By Rank', list: listByRank, description: 'Your rankings' },
            'byScore': { name: 'By Score', list: listByScore, description: 'Pure score chasing' },
            'fwdFirst': { name: 'FWD First', list: listFwdFirst, description: 'Forwards priority' },
            'topTeams': { name: 'Top 6 Teams', list: listTopTeamsFirst, description: 'Big team bias' }
        };
        
        // Generate all strategy combinations for 8-team league
        const STRATEGY_COMBINATIONS = [
            // Homogeneous strategies (all teams use same strategy)
            { name: 'All Rank-Based', strategies: Array(8).fill('byRank') },
            { name: 'All Score-Chasers', strategies: Array(8).fill('byScore') },
            { name: 'All FWD Hunters', strategies: Array(8).fill('fwdFirst') },
            { name: 'All Big Team Bias', strategies: Array(8).fill('topTeams') },
            // Mixed strategies (more realistic)
            { name: 'Mixed - Realistic', strategies: ['byRank', 'byScore', 'fwdFirst', 'topTeams', 'byRank', 'byScore', 'fwdFirst', 'topTeams'] },
            { name: 'Mixed - Score Heavy', strategies: ['byScore', 'byScore', 'byScore', 'byRank', 'byScore', 'fwdFirst', 'byScore', 'topTeams'] },
            { name: 'Mixed - FWD Heavy', strategies: ['fwdFirst', 'fwdFirst', 'byRank', 'fwdFirst', 'byScore', 'fwdFirst', 'topTeams', 'fwdFirst'] },
            { name: 'Mixed - Big Team Heavy', strategies: ['topTeams', 'topTeams', 'topTeams', 'byRank', 'topTeams', 'byScore', 'topTeams', 'fwdFirst'] },
            // You vs specific mix
            { name: 'You vs Score Chasers', strategies: ['byRank', 'byScore', 'byScore', 'byScore', 'byScore', 'byScore', 'byScore', 'byScore'] },
            { name: 'You vs FWD Hunters', strategies: ['byRank', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst'] },
            { name: 'You vs Big Team Fans', strategies: ['byRank', 'topTeams', 'topTeams', 'topTeams', 'topTeams', 'topTeams', 'topTeams', 'topTeams'] }
        ];
        
        // Function to get player by strategy
        function getPlayerByStrategy(strategyKey, availableList, excludeRanks = []) {
            const strategyList = STRATEGY_LISTS[strategyKey]?.list || listByRank;
            for (const player of strategyList) {
                if (!excludeRanks.includes(player.rank) && availableList.some(p => p.rank === player.rank)) {
                    return player;
                }
            }
            return availableList[0]; // Fallback
        }
        
        // Group players by position
        const playersByPosition = {
            GK: availablePlayers.filter(p => p.position === 'GK'),
            DEF: availablePlayers.filter(p => p.position === 'DEF'),
            MID: availablePlayers.filter(p => p.position === 'MID'),
            FWD: availablePlayers.filter(p => p.position === 'FWD')
        };
        
        // Pre-compute optimal N-K-D combinations for DEF and GK
        function computeOptimalTeamCombos(position, N, K, D) {
            const posPlayers = playersByPosition[position];
            const teamsByEasy = {};
            
            // Get unique teams with their easy game counts
            posPlayers.forEach(p => {
                if (!teamsByEasy[p.team]) {
                    teamsByEasy[p.team] = fixtureData[p.team] ? 
                        fixtureData[p.team].filter(f => f <= 2).length : 0;
                }
            });
            
            // Get unique teams sorted by easy games
            const uniqueTeams = [...new Set(posPlayers.map(p => p.team))];
            const sortedTeams = uniqueTeams.sort((a, b) => (teamsByEasy[b] || 0) - (teamsByEasy[a] || 0));
            
            // Generate valid distributions
            const validCombos = [];
            
            function generate(remaining, teamIdx, dist) {
                if (remaining === 0) {
                    // Evaluate this distribution
                    const teamsUsed = Object.entries(dist).filter(([t, n]) => n > 0);
                    let successGWs = 0;
                    
                    for (let gw = 0; gw < gameweeks.length; gw++) {
                        let easyPlayers = 0;
                        teamsUsed.forEach(([team, numPlayers]) => {
                            if (fixtureData[team] && fixtureData[team][gw] <= 2) {
                                easyPlayers += numPlayers;
                            }
                        });
                        if (easyPlayers >= K) successGWs++;
                    }
                    
                    validCombos.push({
                        distribution: { ...dist },
                        teams: teamsUsed.map(([t]) => t),
                        successGWs,
                        score: successGWs
                    });
                    return;
                }
                
                if (teamIdx >= sortedTeams.length) return;
                
                const maxPossible = (sortedTeams.length - teamIdx) * D;
                if (maxPossible < remaining) return;
                
                const team = sortedTeams[teamIdx];
                
                for (let n = Math.min(D, remaining); n >= 0; n--) {
                    const newDist = { ...dist };
                    if (n > 0) newDist[team] = n;
                    generate(remaining - n, teamIdx + 1, newDist);
                }
            }
            
            generate(N, 0, {});
            
            // Sort by success GWs
            validCombos.sort((a, b) => b.successGWs - a.successGWs);
            
            return validCombos.slice(0, 20); // Top 20 combinations
        }
        
        // Pre-compute optimal combos
        const optimalDEFCombos = computeOptimalTeamCombos('DEF', 5, 3, 2);
        const optimalGKCombos = computeOptimalTeamCombos('GK', 2, 1, 1);
        
        // Gaussian random (Box-Muller transform)
        function gaussianRandom(mean, sigma) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + z * sigma;
        }
        
        // Opponent pick model - picks based on Gaussian distribution around lower ranks
        // Get strategy array from selection
        function getStrategyArray(strategyKey) {
            const strategies = {
                'mixed': ['byRank', 'byScore', 'fwdFirst', 'topTeams', 'byRank', 'byScore', 'fwdFirst', 'topTeams'],
                'allRank': Array(8).fill('byRank'),
                'allScore': Array(8).fill('byScore'),
                'allFwd': Array(8).fill('fwdFirst'),
                'allTopTeams': Array(8).fill('topTeams'),
                'scoreHeavy': ['byScore', 'byScore', 'byScore', 'byRank', 'byScore', 'fwdFirst', 'byScore', 'topTeams'],
                'fwdHeavy': ['fwdFirst', 'fwdFirst', 'byRank', 'fwdFirst', 'byScore', 'fwdFirst', 'topTeams', 'fwdFirst'],
                'topTeamHeavy': ['topTeams', 'topTeams', 'topTeams', 'byRank', 'topTeams', 'byScore', 'topTeams', 'fwdFirst'],
                'vsScore': ['byRank', 'byScore', 'byScore', 'byScore', 'byScore', 'byScore', 'byScore', 'byScore'],
                'vsFwd': ['byRank', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst', 'fwdFirst'],
                'vsTopTeams': ['byRank', 'topTeams', 'topTeams', 'topTeams', 'topTeams', 'topTeams', 'topTeams', 'topTeams']
            };
            return strategies[strategyKey] || strategies['mixed'];
        }
        
        // Get sorted list based on strategy
        function getSortedByStrategy(availablePlayers, strategyKey) {
            switch (strategyKey) {
                case 'byScore':
                    return [...availablePlayers].sort((a, b) => b.score - a.score);
                case 'fwdFirst':
                    return [...availablePlayers].sort((a, b) => {
                        const posPriority = { 'FWD': 0, 'MID': 1, 'DEF': 2, 'GK': 3 };
                        const posCompare = posPriority[a.position] - posPriority[b.position];
                        if (posCompare !== 0) return posCompare;
                        return a.rank - b.rank;
                    });
                case 'topTeams':
                    return [...availablePlayers].sort((a, b) => {
                        const aIsTop = TOP_TEAMS.includes(a.team) ? 0 : 1;
                        const bIsTop = TOP_TEAMS.includes(b.team) ? 0 : 1;
                        if (aIsTop !== bIsTop) return aIsTop - bIsTop;
                        return a.rank - b.rank;
                    });
                case 'byRank':
                default:
                    return [...availablePlayers].sort((a, b) => a.rank - b.rank);
            }
        }
        
        function opponentPick(availablePlayers, baseSigma, roundNum = 0, strategyKey = 'byRank') {
            if (availablePlayers.length === 0) return null;
            
            // Sort based on strategy
            const sorted = getSortedByStrategy(availablePlayers, strategyKey);
            
            // HAALAND RULE: If Haaland is available, ALWAYS pick him. No exceptions.
            const haaland = sorted.find(p => p.name === 'Haaland');
            if (haaland) {
                return haaland;
            }
            
            // Round 1: Very low variance (top players are obvious picks)
            if (roundNum === 0) {
                const r = Math.random();
                let idx = 0;
                if (r > 0.95) idx = 1; // 5% chance to pick 2nd best
                idx = Math.min(idx, sorted.length - 1);
                return sorted[idx];
            }
            
            // Round 2: Low variance
            if (roundNum === 1) {
                const r = Math.random();
                let idx = 0;
                if (r > 0.90) idx = 1;
                else if (r > 0.98) idx = 2;
                idx = Math.min(idx, sorted.length - 1);
                return sorted[idx];
            }
            
            // Rounds 3-5: Some variance
            if (roundNum <= 4) {
                let idx = Math.round(Math.abs(gaussianRandom(0, 0.8)));
                idx = Math.max(0, Math.min(sorted.length - 1, idx));
                return sorted[idx];
            }
            
            // Later rounds: More variance
            let idx = Math.round(Math.abs(gaussianRandom(0, 1.2)));
            idx = Math.max(0, Math.min(sorted.length - 1, idx));
            
            return sorted[idx];
        }
        
        // Draft state class
        class DraftState {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.available = [...availablePlayers];
                this.mySquad = { GK: [], DEF: [], MID: [], FWD: [] };
                this.opponentSquads = Array(7).fill(null).map(() => ({ GK: [], DEF: [], MID: [], FWD: [] }));
                this.teamCounts = {}; // My team's player count per club
            }
            
            canPick(player) {
                const maxPos = { GK: 2, DEF: 5, MID: 5, FWD: 3 };
                if (this.mySquad[player.position].length >= maxPos[player.position]) return false;
                if ((this.teamCounts[player.team] || 0) >= 3) return false;
                return true;
            }
            
            pick(player, isMe = true) {
                this.available = this.available.filter(p => p.rank !== player.rank);
                
                if (isMe) {
                    this.mySquad[player.position].push(player);
                    this.teamCounts[player.team] = (this.teamCounts[player.team] || 0) + 1;
                } else {
                    // Assign to random opponent
                    const oppIdx = Math.floor(Math.random() * 7);
                    this.opponentSquads[oppIdx][player.position].push(player);
                }
            }
            
            getTotalPicked() {
                return Object.values(this.mySquad).flat().length;
            }
            
            getSquadScore() {
                const allPlayers = Object.values(this.mySquad).flat();
                return allPlayers.reduce((sum, p) => sum + p.score, 0);
            }
            
            getFixtureCoverage() {
                const allPlayers = Object.values(this.mySquad).flat();
                const myTeams = [...new Set(allPlayers.map(p => p.team))];
                let coverage = 0;
                
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    if (myTeams.some(team => fixtureData[team] && fixtureData[team][gw] <= 2)) {
                        coverage++;
                    }
                }
                return coverage;
            }
        }
        
        // User pick strategy
        function userPickStrategy(state, roundNum) {
            const { mySquad, available } = state;
            const totalPicked = state.getTotalPicked();
            
            // Position needs
            const needs = {
                GK: 2 - mySquad.GK.length,
                DEF: 5 - mySquad.DEF.length,
                MID: 5 - mySquad.MID.length,
                FWD: 3 - mySquad.FWD.length
            };
            
            // Priority strategy based on round
            // Early rounds: FWD (top 10), MID (top 5)
            // Mid rounds: DEF (N-K-D optimal)
            // Late rounds: GK (rotation pair)
            
            const remainingPicks = 15 - totalPicked;
            
            // Get available players by position
            const availByPos = {
                GK: available.filter(p => p.position === 'GK' && state.canPick(p)),
                DEF: available.filter(p => p.position === 'DEF' && state.canPick(p)),
                MID: available.filter(p => p.position === 'MID' && state.canPick(p)),
                FWD: available.filter(p => p.position === 'FWD' && state.canPick(p))
            };
            
            // HAALAND RULE: If Haaland is available, ALWAYS pick him. No exceptions.
            const haaland = available.find(p => p.name === 'Haaland' && state.canPick(p));
            if (haaland) {
                return haaland;
            }
            
            // PRIORITY 1: Top FWDs (if we need FWDs and top 10 available)
            if (needs.FWD > 0 && mySquad.FWD.length < 2) {
                const topFWDs = availByPos.FWD.filter(p => p.rank <= 25);
                if (topFWDs.length > 0) {
                    return topFWDs.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // PRIORITY 2: Top MID (if we need MIDs and top 5 available)
            if (needs.MID > 0 && mySquad.MID.length < 1) {
                const topMIDs = availByPos.MID.filter(p => p.rank <= 15);
                if (topMIDs.length > 0) {
                    return topMIDs.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // PRIORITY 3: Get optimal DEF from N-K-D teams
            if (needs.DEF > 0) {
                // Find which optimal teams we still need players from
                const optimalTeams = optimalDEFCombos[0]?.teams || [];
                const optimalDEFs = availByPos.DEF.filter(p => optimalTeams.includes(p.team));
                if (optimalDEFs.length > 0) {
                    return optimalDEFs.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // PRIORITY 4: Fill remaining MIDs
            if (needs.MID > 0) {
                if (availByPos.MID.length > 0) {
                    return availByPos.MID.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // PRIORITY 5: Get GKs from optimal rotation
            if (needs.GK > 0) {
                const optimalGKTeams = optimalGKCombos[0]?.teams || [];
                const optimalGKs = availByPos.GK.filter(p => optimalGKTeams.includes(p.team));
                if (optimalGKs.length > 0) {
                    return optimalGKs.sort((a, b) => a.rank - b.rank)[0];
                }
                if (availByPos.GK.length > 0) {
                    return availByPos.GK.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // PRIORITY 6: Fill remaining FWDs
            if (needs.FWD > 0) {
                if (availByPos.FWD.length > 0) {
                    return availByPos.FWD.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // PRIORITY 7: Fill remaining DEFs
            if (needs.DEF > 0) {
                if (availByPos.DEF.length > 0) {
                    return availByPos.DEF.sort((a, b) => a.rank - b.rank)[0];
                }
            }
            
            // Fallback: pick best available that we can use
            const allAvail = available.filter(p => state.canPick(p));
            if (allAvail.length > 0) {
                return allAvail.sort((a, b) => a.rank - b.rank)[0];
            }
            
            return null;
        }
        
        // Run single draft simulation
        function runSingleDraft(myPosition, sigma, strategyKey = 'mixed') {
            const state = new DraftState();
            const numTeams = 8;
            const numRounds = 15;
            const picksRecord = [];
            
            // Get strategy array for opponents
            const strategies = getStrategyArray(strategyKey);
            
            for (let round = 0; round < numRounds; round++) {
                // Snake draft order
                const isEvenRound = round % 2 === 0;
                const order = isEvenRound 
                    ? Array.from({ length: numTeams }, (_, i) => i + 1)
                    : Array.from({ length: numTeams }, (_, i) => numTeams - i);
                
                for (const pos of order) {
                    if (pos === myPosition) {
                        // My pick
                        const pick = userPickStrategy(state, round);
                        if (pick) {
                            state.pick(pick, true);
                            picksRecord.push({ round, pick, pickNum: (round * numTeams) + order.indexOf(pos) + 1 });
                        }
                    } else {
                        // Opponent pick - use their assigned strategy
                        const oppStrategy = strategies[pos - 1]; // pos is 1-8, array is 0-7
                        const availForOpp = state.available.filter(p => p.playingChance > 0);
                        const pick = opponentPick(availForOpp, sigma, round, oppStrategy);
                        if (pick) {
                            state.pick(pick, false);
                        }
                    }
                }
            }
            
            // Calculate easy games per GW
            const easyGamesPerGW = [];
            const allPlayers = Object.values(state.mySquad).flat();
            for (let gw = 0; gw < gameweeks.length; gw++) {
                let easyCount = 0;
                allPlayers.forEach(p => {
                    if (fixtureData[p.team] && fixtureData[p.team][gw] <= 2) {
                        easyCount++;
                    }
                });
                easyGamesPerGW.push(easyCount);
            }
            
            // Calculate min, max, avg easy players per GW
            const minEasy = Math.min(...easyGamesPerGW);
            const maxEasy = Math.max(...easyGamesPerGW);
            const avgEasy = easyGamesPerGW.reduce((a, b) => a + b, 0) / easyGamesPerGW.length;
            
            return {
                squad: state.mySquad,
                score: state.getSquadScore(),
                coverage: state.getFixtureCoverage(),
                picks: picksRecord,
                teamCounts: state.teamCounts,
                easyGamesPerGW,
                minEasy,
                maxEasy,
                avgEasy
            };
        }
        
        // Run Monte Carlo simulation
        async function runMockDraft() {
            const positionSelect = document.getElementById('draftPosition').value;
            const numSims = parseInt(document.getElementById('numSimulations').value);
            const sigma = parseFloat(document.getElementById('opponentSigma').value);
            
            const statusEl = document.getElementById('draftStatus');
            const progressEl = document.getElementById('draftProgress');
            const resultsSection = document.getElementById('draftResultsSection');
            const strategySection = document.getElementById('draftStrategySection');
            const availabilitySection = document.getElementById('playerAvailabilitySection');
            
            statusEl.style.display = 'block';
            statusEl.textContent = 'Running simulations';
            progressEl.style.width = '0%';
            
            const positions = positionSelect === 'all' 
                ? [1, 2, 3, 4, 5, 6, 7, 8] 
                : [parseInt(positionSelect)];
            
            const results = {};
            const playerAvailability = {}; // Track when each player is available
            
            // Initialize availability tracking for top 50 players
            availablePlayers.slice(0, 50).forEach(p => {
                playerAvailability[p.rank] = { player: p, availableCount: {}, pickedCount: 0 };
                for (let pos = 1; pos <= 8; pos++) {
                    playerAvailability[p.rank].availableCount[pos] = 0;
                }
            });
            
            let totalSims = positions.length * numSims;
            let completed = 0;
            
            for (const pos of positions) {
                const posResults = [];
                const strategyKey = document.getElementById('opponentStrategy')?.value || 'mixed';
                
                for (let sim = 0; sim < numSims; sim++) {
                    const result = runSingleDraft(pos, sigma, strategyKey);
                    posResults.push(result);
                    
                    // Track availability at first pick
                    result.picks.forEach((pickInfo, idx) => {
                        if (idx === 0 && playerAvailability[pickInfo.pick.rank]) {
                            playerAvailability[pickInfo.pick.rank].pickedCount++;
                        }
                    });
                    
                    completed++;
                    if (completed % 100 === 0) {
                        progressEl.style.width = `${(completed / totalSims) * 100}%`;
                        statusEl.textContent = `Running simulations... ${completed}/${totalSims}`;
                        await new Promise(r => setTimeout(r, 0));
                    }
                }
                
                // Aggregate results for this position
                const avgScore = posResults.reduce((sum, r) => sum + r.score, 0) / numSims;
                const avgCoverage = posResults.reduce((sum, r) => sum + r.coverage, 0) / numSims;
                
                // Count goal achievements
                let top2FWDCount = 0;
                let top5MIDCount = 0;
                
                posResults.forEach(r => {
                    const fwdRanks = r.squad.FWD.map(p => p.rank);
                    const top10FWDs = fwdRanks.filter(rank => rank <= 25).length;
                    if (top10FWDs >= 2) top2FWDCount++;
                    
                    const midRanks = r.squad.MID.map(p => p.rank);
                    const top5MIDs = midRanks.filter(rank => rank <= 15).length;
                    if (top5MIDs >= 1) top5MIDCount++;
                });
                
                // Find most common picks
                const pickFrequency = {};
                posResults.forEach(r => {
                    r.picks.forEach((pickInfo, idx) => {
                        const key = `${idx}_${pickInfo.pick.rank}`;
                        if (!pickFrequency[key]) {
                            pickFrequency[key] = { pick: pickInfo.pick, round: idx, count: 0 };
                        }
                        pickFrequency[key].count++;
                    });
                });
                
                // Best picks per round
                const bestPicksPerRound = [];
                for (let round = 0; round < 15; round++) {
                    const roundPicks = Object.values(pickFrequency)
                        .filter(pf => pf.round === round)
                        .sort((a, b) => b.count - a.count)
                        .slice(0, 5);
                    bestPicksPerRound.push(roundPicks);
                }
                
                results[pos] = {
                    position: pos,
                    avgScore,
                    avgCoverage,
                    top2FWDProb: (top2FWDCount / numSims * 100).toFixed(1),
                    top5MIDProb: (top5MIDCount / numSims * 100).toFixed(1),
                    bestPicksPerRound,
                    sampleSquad: posResults[0].squad
                };
            }
            
            statusEl.style.display = 'none';
            progressEl.style.width = '100%';
            
            // Display results
            displayDraftResults(results, positions);
            displayDraftStrategy(results, positions);
            displayPlayerAvailability(playerAvailability, numSims);
            
            resultsSection.style.display = 'block';
            strategySection.style.display = 'block';
            availabilitySection.style.display = 'block';
        }
        
        function displayDraftResults(results, positions) {
            const container = document.getElementById('draftPositionRankings');
            
            // Sort positions by average score
            const sortedPositions = [...positions].sort((a, b) => 
                results[b].avgScore - results[a].avgScore
            );
            
            let html = '';
            
            sortedPositions.forEach((pos, idx) => {
                const r = results[pos];
                const rankClass = idx === 0 ? 'gold' : idx === 1 ? 'silver' : idx === 2 ? 'bronze' : 'normal';
                const isBest = idx === 0;
                
                html += `
                    <div class="draft-position-card ${isBest ? 'best' : ''}">
                        <div style="display: flex; align-items: center;">
                            <div class="draft-rank-badge ${rankClass}">${idx + 1}</div>
                            <div>
                                <div style="font-weight: 600; font-size: 1.1rem;">Draft Position ${pos}</div>
                                <div style="color: var(--text-secondary); font-size: 0.85rem;">
                                    Pick order: ${pos}, ${17-pos}, ${16+pos}, ${33-pos}...
                                </div>
                            </div>
                        </div>
                        
                        <div class="draft-metrics">
                            <div class="draft-metric">
                                <div class="draft-metric-value" style="color: var(--accent-cyan);">${r.avgScore.toFixed(0)}</div>
                                <div class="draft-metric-label">Avg Score</div>
                            </div>
                            <div class="draft-metric">
                                <div class="draft-metric-value" style="color: var(--easy-game);">${r.avgCoverage.toFixed(1)}</div>
                                <div class="draft-metric-label">GW Coverage</div>
                            </div>
                            <div class="draft-metric">
                                <div class="draft-metric-value" style="color: var(--accent-amber);">${r.top2FWDProb}%</div>
                                <div class="draft-metric-label">2 Top FWDs</div>
                            </div>
                            <div class="draft-metric">
                                <div class="draft-metric-value" style="color: var(--accent-violet);">${r.top5MIDProb}%</div>
                                <div class="draft-metric-label">1 Top MID</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function displayDraftStrategy(results, positions) {
            const container = document.getElementById('draftStrategy');
            
            // Show strategy for best position or selected position
            const bestPos = positions.sort((a, b) => results[b].avgScore - results[a].avgScore)[0];
            const r = results[bestPos];
            
            let html = `
                <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 10px;">
                    <strong style="color: var(--accent-cyan);">Recommended Strategy for Position ${bestPos}</strong>
                </div>
                
                <table class="pick-strategy-table">
                    <thead>
                        <tr>
                            <th>Round</th>
                            <th>Pick #</th>
                            <th>Best Picks (by frequency)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            r.bestPicksPerRound.forEach((roundPicks, roundIdx) => {
                const pickNum = roundIdx % 2 === 0 
                    ? roundIdx * 8 + bestPos 
                    : roundIdx * 8 + (9 - bestPos);
                
                html += `
                    <tr>
                        <td style="font-weight: 600;">Round ${roundIdx + 1}</td>
                        <td style="color: var(--accent-cyan);">#${pickNum}</td>
                        <td>
                `;
                
                roundPicks.forEach(rp => {
                    const prob = (rp.count / parseInt(document.getElementById('numSimulations').value) * 100).toFixed(0);
                    const probClass = prob >= 50 ? 'high-prob' : prob >= 25 ? 'med-prob' : 'low-prob';
                    
                    html += `
                        <span class="player-card-mini ${probClass}">
                            <span style="font-weight: 600;">${rp.pick.name}</span>
                            <span style="color: var(--text-muted);">${rp.pick.position}</span>
                            <span style="color: var(--easy-game);">${prob}%</span>
                        </span>
                    `;
                });
                
                html += `</td></tr>`;
            });
            
            html += `</tbody></table>`;
            
            // Sample squad
            html += `
                <div style="margin-top: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Sample Draft Result</h3>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
            `;
            
            const posColors = {
                GK: { bg: '#eab308', text: '#000' },
                DEF: { bg: '#3b82f6', text: '#fff' },
                MID: { bg: '#22c55e', text: '#000' },
                FWD: { bg: '#ef4444', text: '#fff' }
            };
            
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                html += `
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 10px;">
                        <div style="font-weight: 600; margin-bottom: 0.75rem; color: ${posColors[pos].text}; background: ${posColors[pos].bg}; padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">${pos}</div>
                        <div style="font-size: 0.85rem;">
                `;
                
                r.sampleSquad[pos].forEach(p => {
                    html += `<div style="margin-bottom: 0.25rem;">${p.name} <span style="color: var(--text-muted);">(${p.team})</span></div>`;
                });
                
                html += `</div></div>`;
            });
            
            html += `</div></div>`;
            
            container.innerHTML = html;
        }
        
        function displayPlayerAvailability(availability, numSims) {
            const container = document.getElementById('playerAvailability');
            
            // Sort by rank
            const sorted = Object.values(availability).sort((a, b) => a.player.rank - b.player.rank);
            
            let html = `
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Probability of each player being available at your first pick, by draft position.
                </p>
                
                <div style="display: grid; gap: 0.5rem;">
            `;
            
            sorted.slice(0, 30).forEach(item => {
                const p = item.player;
                const pickRate = (item.pickedCount / numSims * 100).toFixed(1);
                
                html += `
                    <div style="display: flex; align-items: center; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 8px;">
                        <div style="width: 40px; font-weight: 600; color: var(--accent-cyan);">#${p.rank}</div>
                        <div style="flex: 1; margin-right: 1rem;">
                            <div style="font-weight: 500;">${p.name}</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">${p.team} • ${p.position}</div>
                        </div>
                        <div style="width: 150px;">
                            <div style="font-size: 0.8rem; margin-bottom: 0.25rem;">
                                Selected: <span style="color: var(--easy-game);">${pickRate}%</span>
                            </div>
                            <div class="availability-bar">
                                <div class="availability-fill" style="width: ${pickRate}%; background: var(--easy-game);"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            container.innerHTML = html;
        }
        
        // ============================================
        // DRAFT SUB-TAB SWITCHING
        // ============================================
        
        function showDraftSubtab(subtabId) {
            document.querySelectorAll('.draft-subtab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.draft-subtab').forEach(el => el.classList.remove('active'));
            
            document.getElementById(subtabId).classList.add('active');
            event.target.classList.add('active');
        }
        
        // ============================================
        // LIVE DRAFT SIMULATOR
        // ============================================
        
        let liveDraftState = null;
        let currentFilter = 'all';
        
        class LiveDraftState {
            constructor(myPosition) {
                this.myPosition = myPosition;
                this.currentRound = 0;
                this.currentPickInRound = 0;
                this.totalPicks = 0;
                this.available = [...availablePlayers];
                this.mySquad = { GK: [], DEF: [], MID: [], FWD: [] };
                // Track ALL 8 teams by draft position (1-8)
                this.allTeamSquads = {};
                for (let i = 1; i <= 8; i++) {
                    this.allTeamSquads[i] = { GK: [], DEF: [], MID: [], FWD: [] };
                }
                this.teamCounts = {};
                this.draftLog = [];
                this.isMyTurn = false;
            }
            
            canPick(player) {
                const maxPos = { GK: 2, DEF: 5, MID: 5, FWD: 3 };
                if (this.mySquad[player.position].length >= maxPos[player.position]) return false;
                if ((this.teamCounts[player.team] || 0) >= 3) return false;
                return true;
            }
            
            pick(player, isMe = true) {
                this.available = this.available.filter(p => p.rank !== player.rank);
                
                const currentPicker = this.getCurrentPicker();
                const teamName = isMe ? 'You (Pos ' + this.myPosition + ')' : `Team ${currentPicker}`;
                
                // Add to the appropriate team's squad
                this.allTeamSquads[currentPicker][player.position].push(player);
                
                if (isMe) {
                    this.mySquad[player.position].push(player);
                    this.teamCounts[player.team] = (this.teamCounts[player.team] || 0) + 1;
                }
                
                this.draftLog.push({
                    round: this.currentRound + 1,
                    pick: this.totalPicks + 1,
                    team: teamName,
                    draftPosition: currentPicker,
                    player: player,
                    isUser: isMe
                });
                
                this.totalPicks++;
            }
            
            getCurrentOpponentIndex() {
                // Map pick position to opponent index (0-6)
                const pickOrder = this.getPickOrder();
                const currentPicker = pickOrder[this.currentPickInRound];
                if (currentPicker === this.myPosition) return -1;
                return currentPicker > this.myPosition ? currentPicker - 2 : currentPicker - 1;
            }
            
            getPickOrder() {
                const isEvenRound = this.currentRound % 2 === 0;
                return isEvenRound 
                    ? Array.from({ length: 8 }, (_, i) => i + 1)
                    : Array.from({ length: 8 }, (_, i) => 8 - i);
            }
            
            getCurrentPicker() {
                return this.getPickOrder()[this.currentPickInRound];
            }
            
            advancePick() {
                this.currentPickInRound++;
                if (this.currentPickInRound >= 8) {
                    this.currentRound++;
                    this.currentPickInRound = 0;
                }
                this.isMyTurn = this.getCurrentPicker() === this.myPosition;
            }
            
            isDraftComplete() {
                return this.currentRound >= 15;
            }
            
            getTotalPicked() {
                return Object.values(this.mySquad).flat().length;
            }
            
            getSquadScore() {
                return Object.values(this.mySquad).flat().reduce((sum, p) => sum + p.score, 0);
            }
            
            getFixtureCoverage() {
                const myTeams = [...new Set(Object.values(this.mySquad).flat().map(p => p.team))];
                let coverage = 0;
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    if (myTeams.some(team => fixtureData[team] && fixtureData[team][gw] <= 2)) {
                        coverage++;
                    }
                }
                return coverage;
            }
            
            getUniqueTeams() {
                return [...new Set(Object.values(this.mySquad).flat().map(p => p.team))].length;
            }
        }
        
        function startLiveDraft(randomPosition = false) {
            let position = parseInt(document.getElementById('liveDraftPosition').value);
            
            if (randomPosition) {
                position = Math.floor(Math.random() * 8) + 1;
                document.getElementById('liveDraftPosition').value = position;
            }
            
            liveDraftState = new LiveDraftState(position);
            liveDraftState.isMyTurn = liveDraftState.getCurrentPicker() === position;
            
            document.getElementById('liveDraftArea').style.display = 'block';
            document.getElementById('allTeamsResults').style.display = 'none'; // Hide previous results
            
            updateLiveDraftUI();
            
            // If first pick isn't ours, simulate opponent picks
            if (!liveDraftState.isMyTurn) {
                simulateOpponentPicks();
            }
        }
        
        function updateLiveDraftUI() {
            if (!liveDraftState) return;
            
            // Update status banner
            document.getElementById('currentRound').textContent = liveDraftState.currentRound + 1;
            document.getElementById('currentPick').textContent = liveDraftState.totalPicks + 1;
            
            const turnInfo = document.getElementById('turnInfo');
            const banner = document.getElementById('draftStatusBanner');
            
            if (liveDraftState.isDraftComplete()) {
                turnInfo.textContent = '🏆 Draft Complete!';
                turnInfo.className = 'draft-turn-info';
                banner.className = 'draft-status-banner';
            } else if (liveDraftState.isMyTurn) {
                turnInfo.textContent = '🎯 YOUR TURN - Pick a player!';
                turnInfo.className = 'draft-turn-info your-turn';
                banner.className = 'draft-status-banner my-turn';
            } else {
                turnInfo.textContent = `⏳ Team ${liveDraftState.getCurrentPicker()} is picking...`;
                turnInfo.className = 'draft-turn-info opponent-turn';
                banner.className = 'draft-status-banner';
            }
            
            // Update available players
            renderAvailablePlayers();
            
            // Update recommendations
            updateRecommendations();
            
            // Update my squad
            updateMySquadUI();
            
            // Update draft log
            updateDraftLog();
        }
        
        function renderAvailablePlayers() {
            const container = document.getElementById('availablePlayersList');
            const filtered = currentFilter === 'all' 
                ? liveDraftState.available 
                : liveDraftState.available.filter(p => p.position === currentFilter);
            
            // Get recommended players
            const recommendations = getRecommendedPlayers();
            const recommendedRanks = new Set(recommendations.map(r => r.rank));
            
            let html = '';
            filtered.slice(0, 50).forEach(p => {
                const canPick = liveDraftState.canPick(p);
                const isRecommended = recommendedRanks.has(p.rank);
                const teamEasyGames = fixtureData[p.team] ? fixtureData[p.team].filter(f => f <= 2).length : 0;
                
                html += `
                    <div class="player-draft-card ${isRecommended ? 'recommended' : ''}" 
                         onclick="pickPlayer(${p.rank})"
                         style="${!canPick ? 'opacity: 0.5; pointer-events: none;' : ''}">
                        <div class="player-rank">#${p.rank}</div>
                        <div class="player-info">
                            <div class="player-name">${p.name}</div>
                            <div class="player-team">${p.team}</div>
                        </div>
                        <span class="player-pos ${p.position.toLowerCase()}">${p.position}</span>
                        <span class="player-score">${p.score}</span>
                        <span class="easy-games-badge" title="Easy games">${teamEasyGames}🎯</span>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<p style="color: var(--text-muted);">No players available</p>';
        }
        
        function filterPlayers(filter) {
            currentFilter = filter;
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            renderAvailablePlayers();
        }
        
        function getRecommendedPlayers() {
            if (!liveDraftState) return [];
            
            const { mySquad, available } = liveDraftState;
            const recommendations = [];
            
            // Position needs
            const needs = {
                GK: 2 - mySquad.GK.length,
                DEF: 5 - mySquad.DEF.length,
                MID: 5 - mySquad.MID.length,
                FWD: 3 - mySquad.FWD.length
            };
            
            // Get available by position
            const availByPos = {
                GK: available.filter(p => p.position === 'GK' && liveDraftState.canPick(p)),
                DEF: available.filter(p => p.position === 'DEF' && liveDraftState.canPick(p)),
                MID: available.filter(p => p.position === 'MID' && liveDraftState.canPick(p)),
                FWD: available.filter(p => p.position === 'FWD' && liveDraftState.canPick(p))
            };
            
            // Top FWDs if needed
            if (needs.FWD > 0 && mySquad.FWD.length < 2) {
                const topFWDs = availByPos.FWD.filter(p => p.rank <= 30).slice(0, 3);
                topFWDs.forEach(p => recommendations.push(p));
            }
            
            // Top MIDs if needed
            if (needs.MID > 0 && mySquad.MID.length < 1) {
                const topMIDs = availByPos.MID.filter(p => p.rank <= 20).slice(0, 2);
                topMIDs.forEach(p => recommendations.push(p));
            }
            
            // DEFs from optimal teams
            if (needs.DEF > 0) {
                const optimalTeams = optimalDEFCombos[0]?.teams || [];
                const optimalDEFs = availByPos.DEF.filter(p => optimalTeams.includes(p.team)).slice(0, 3);
                optimalDEFs.forEach(p => recommendations.push(p));
            }
            
            // Add best overall available
            const bestAvail = available.filter(p => liveDraftState.canPick(p)).slice(0, 3);
            bestAvail.forEach(p => {
                if (!recommendations.find(r => r.rank === p.rank)) {
                    recommendations.push(p);
                }
            });
            
            return recommendations.slice(0, 5);
        }
        
        function updateRecommendations() {
            if (!liveDraftState || liveDraftState.isDraftComplete()) {
                document.getElementById('recommendationsContent').innerHTML = '<p style="color: var(--text-muted);">Draft complete!</p>';
                return;
            }
            
            const { mySquad, available } = liveDraftState;
            const needs = {
                GK: 2 - mySquad.GK.length,
                DEF: 5 - mySquad.DEF.length,
                MID: 5 - mySquad.MID.length,
                FWD: 3 - mySquad.FWD.length
            };
            
            const recommendations = getRecommendedPlayers();
            
            // Top recommendation
            const topPick = recommendations[0];
            if (topPick) {
                document.getElementById('topRecommendation').innerHTML = `
                    <div class="player-draft-card recommended" onclick="pickPlayer(${topPick.rank})" style="cursor: pointer;">
                        <div class="player-rank">#${topPick.rank}</div>
                        <div class="player-info">
                            <div class="player-name">${topPick.name}</div>
                            <div class="player-team">${topPick.team}</div>
                        </div>
                        <span class="player-pos ${topPick.position.toLowerCase()}">${topPick.position}</span>
                        <span class="player-score">${topPick.score}</span>
                    </div>
                `;
            }
            
            // Position needs
            let posHtml = '<div style="font-size: 0.85rem;">';
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const urgency = needs[pos] > 0 ? (15 - liveDraftState.getTotalPicked() <= needs[pos] * 2 ? '🔴' : '🟡') : '✅';
                posHtml += `<div>${urgency} <strong>${pos}:</strong> Need ${needs[pos]} more</div>`;
            });
            posHtml += '</div>';
            document.getElementById('positionRecommendations').innerHTML = posHtml;
            
            // Fixture coverage analysis
            const currentCoverage = liveDraftState.getFixtureCoverage();
            const myTeams = [...new Set(Object.values(mySquad).flat().map(p => p.team))];
            const uncoveredGWs = [];
            for (let gw = 0; gw < gameweeks.length; gw++) {
                if (!myTeams.some(team => fixtureData[team] && fixtureData[team][gw] <= 2)) {
                    uncoveredGWs.push(`GW${gw + gwStart}`);
                }
            }
            
            let fixtureHtml = `<div style="font-size: 0.85rem;">
                <div>Current coverage: <strong style="color: var(--easy-game);">${currentCoverage}/19</strong></div>
            `;
            if (uncoveredGWs.length > 0 && uncoveredGWs.length <= 5) {
                fixtureHtml += `<div style="color: var(--accent-rose);">Uncovered: ${uncoveredGWs.join(', ')}</div>`;
                
                // Suggest teams that cover these GWs
                const coveringTeams = teams.filter(team => {
                    return uncoveredGWs.some(gw => {
                        const gwIdx = parseInt(gw.replace('GW', '')) - gwStart;
                        return fixtureData[team] && fixtureData[team][gwIdx] <= 2;
                    });
                }).slice(0, 3);
                fixtureHtml += `<div style="color: var(--accent-amber);">Target: ${coveringTeams.join(', ')}</div>`;
            }
            fixtureHtml += '</div>';
            document.getElementById('fixtureRecommendations').innerHTML = fixtureHtml;
            
            // Risk analysis
            const picksRemaining = 15 - liveDraftState.getTotalPicked();
            const riskyPositions = Object.entries(needs).filter(([pos, need]) => need > 0 && picksRemaining <= need * 3);
            let riskHtml = '<div style="font-size: 0.85rem;">';
            if (riskyPositions.length > 0) {
                riskHtml += `<div style="color: var(--accent-rose);">⚠️ Fill ${riskyPositions.map(([p]) => p).join(', ')} soon!</div>`;
            } else {
                riskHtml += '<div style="color: var(--easy-game);">✅ On track with position needs</div>';
            }
            riskHtml += `<div>Picks remaining: ${picksRemaining}</div>`;
            riskHtml += '</div>';
            document.getElementById('riskAnalysis').innerHTML = riskHtml;
        }
        
        function updateMySquadUI() {
            if (!liveDraftState) return;
            
            const { mySquad } = liveDraftState;
            
            // Update position counts and players
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const max = { GK: 2, DEF: 5, MID: 5, FWD: 3 }[pos];
                document.getElementById(`my${pos}Count`).textContent = `${mySquad[pos].length}/${max}`;
                
                const playersHtml = mySquad[pos].map(p => `
                    <div class="pos-player">${p.name} <span style="color: var(--text-muted);">(${p.team})</span></div>
                `).join('');
                document.getElementById(`my${pos}Players`).innerHTML = playersHtml || '<span style="color: var(--text-muted);">-</span>';
            });
            
            // Update stats
            document.getElementById('myTotalScore').textContent = liveDraftState.getSquadScore();
            document.getElementById('myGWCoverage').textContent = `${liveDraftState.getFixtureCoverage()}/19`;
            document.getElementById('myUniqueTeams').textContent = liveDraftState.getUniqueTeams();
        }
        
        function updateDraftLog() {
            if (!liveDraftState) return;
            
            const container = document.getElementById('draftLog');
            let html = '';
            
            liveDraftState.draftLog.slice(-20).reverse().forEach(entry => {
                html += `
                    <div class="draft-log-entry ${entry.isUser ? 'user-pick' : 'opponent-pick'}">
                        <span class="log-round">R${entry.round} #${entry.pick}</span>
                        <span class="log-team">${entry.team}</span>
                        <span class="log-player">${entry.player.name} (${entry.player.position})</span>
                    </div>
                `;
            });
            
            container.innerHTML = html || '<span style="color: var(--text-muted);">No picks yet</span>';
        }
        
        function pickPlayer(rank) {
            if (!liveDraftState || !liveDraftState.isMyTurn) return;
            
            const player = liveDraftState.available.find(p => p.rank === rank);
            if (!player || !liveDraftState.canPick(player)) return;
            
            liveDraftState.pick(player, true);
            liveDraftState.advancePick();
            
            updateLiveDraftUI();
            
            // If draft is complete after our pick, show all teams
            if (liveDraftState.isDraftComplete()) {
                displayAllTeamsResults();
                return;
            }
            
            // Simulate opponent picks until it's our turn again or draft ends
            if (!liveDraftState.isMyTurn) {
                setTimeout(simulateOpponentPicks, 500);
            }
        }
        
        async function simulateOpponentPicks() {
            const sigma = 12;
            const scoreWeight = parseInt(document.getElementById('liveScoreWeight')?.value || 50) / 100;
            
            while (!liveDraftState.isDraftComplete() && !liveDraftState.isMyTurn) {
                await new Promise(r => setTimeout(r, 300));
                
                const availForOpp = liveDraftState.available.filter(p => p.playingChance > 0);
                const pick = opponentPickWithScoreWeight(availForOpp, sigma, liveDraftState.currentRound, scoreWeight);
                
                if (pick) {
                    liveDraftState.pick(pick, false);
                }
                
                liveDraftState.advancePick();
                updateLiveDraftUI();
            }
            
            // If draft is complete, show all teams
            if (liveDraftState.isDraftComplete()) {
                displayAllTeamsResults();
            }
        }
        
        // Opponent pick with score weight - combines rank and player score
        function opponentPickWithScoreWeight(availablePlayers, baseSigma, roundNum, scoreWeight) {
            if (availablePlayers.length === 0) return null;
            
            // HAALAND RULE: If Haaland is available, ALWAYS pick him
            const haaland = availablePlayers.find(p => p.name === 'Haaland');
            if (haaland) {
                return haaland;
            }
            
            // Calculate combined score for each player
            // Combined = (1 - scoreWeight) * rankScore + scoreWeight * playerScore
            // Normalize both to 0-100 scale
            const maxRank = Math.max(...availablePlayers.map(p => p.rank));
            const maxScore = Math.max(...availablePlayers.map(p => p.score));
            
            const playersWithCombinedScore = availablePlayers.map(p => {
                const rankScore = 100 - (p.rank / maxRank * 100); // Lower rank = higher score
                const normalizedPlayerScore = (p.score / maxScore) * 100;
                const combinedScore = (1 - scoreWeight) * rankScore + scoreWeight * normalizedPlayerScore;
                return { ...p, combinedScore };
            });
            
            // Sort by combined score (descending)
            playersWithCombinedScore.sort((a, b) => b.combinedScore - a.combinedScore);
            
            // Apply variance based on round
            let idx = 0;
            if (roundNum === 0) {
                // Round 1: Very low variance
                const r = Math.random();
                if (r > 0.95) idx = 1;
            } else if (roundNum === 1) {
                const r = Math.random();
                if (r > 0.90) idx = 1;
                else if (r > 0.98) idx = 2;
            } else if (roundNum <= 4) {
                idx = Math.round(Math.abs(gaussianRandom(0, 0.8)));
            } else {
                idx = Math.round(Math.abs(gaussianRandom(0, 1.2)));
            }
            
            idx = Math.min(idx, playersWithCombinedScore.length - 1);
            return playersWithCombinedScore[idx];
        }
        
        // Display all 8 teams after draft completes
        function displayAllTeamsResults() {
            const container = document.getElementById('allTeamsResults');
            const grid = document.getElementById('allTeamsGrid');
            
            if (!liveDraftState || !liveDraftState.isDraftComplete()) return;
            
            container.style.display = 'block';
            
            let html = '';
            
            for (let pos = 1; pos <= 8; pos++) {
                const squad = liveDraftState.allTeamSquads[pos];
                const isUser = pos === liveDraftState.myPosition;
                const allPlayers = [...squad.GK, ...squad.DEF, ...squad.MID, ...squad.FWD];
                const totalScore = allPlayers.reduce((sum, p) => sum + p.score, 0);
                
                // Calculate fixture coverage
                const teamsList = [...new Set(allPlayers.map(p => p.team))];
                let coverage = 0;
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    if (teamsList.some(team => fixtureData[team] && fixtureData[team][gw] <= 2)) {
                        coverage++;
                    }
                }
                
                html += `
                    <div class="team-result-card ${isUser ? 'user-team' : ''}">
                        <div class="team-header">
                            <span class="team-name">${isUser ? '⭐ You' : 'Team'} #${pos}</span>
                            <span class="team-score">${totalScore} pts</span>
                        </div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                            Coverage: ${coverage}/19 GWs | Teams: ${teamsList.length}
                        </div>
                        <div class="team-players">
                `;
                
                // Sort players by position then by rank
                const sortedPlayers = [...squad.GK, ...squad.DEF, ...squad.MID, ...squad.FWD];
                sortedPlayers.forEach(p => {
                    html += `
                        <div class="player-row">
                            <span>${p.name} <span style="color: var(--text-muted);">(${p.team})</span></span>
                            <span class="pos-tag ${p.position.toLowerCase()}">${p.position}</span>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            grid.innerHTML = html;
        }
        
        // ============================================
        // ALL POSITIONS COMPARISON
        // ============================================
        
        async function runAllPositionsComparison() {
            const statusEl = document.getElementById('allPosStatus');
            const progressEl = document.getElementById('allPosProgress');
            const resultsSection = document.getElementById('allPosResultsSection');
            const bestSquadsSection = document.getElementById('bestSquadsSection');
            
            statusEl.style.display = 'block';
            statusEl.textContent = 'Running simulations for all positions...';
            progressEl.style.width = '0%';
            
            const numSims = 1000;
            const sigma = 12;
            const results = {};
            const bestSquads = {};
            
            for (let pos = 1; pos <= 8; pos++) {
                statusEl.textContent = `Simulating position ${pos}/8...`;
                progressEl.style.width = `${(pos - 1) / 8 * 100}%`;
                
                const posResults = [];
                let bestScore = 0;
                let bestSquad = null;
                const strategyKey = document.getElementById('opponentStrategy')?.value || 'mixed';
                
                for (let sim = 0; sim < numSims; sim++) {
                    const result = runSingleDraft(pos, sigma, strategyKey);
                    posResults.push(result);
                    
                    if (result.score > bestScore) {
                        bestScore = result.score;
                        bestSquad = result.squad;
                    }
                    
                    if (sim % 100 === 0) {
                        await new Promise(r => setTimeout(r, 0));
                    }
                }
                
                // Calculate stats
                const avgScore = posResults.reduce((sum, r) => sum + r.score, 0) / numSims;
                const avgCoverage = posResults.reduce((sum, r) => sum + r.coverage, 0) / numSims;
                
                // Calculate fixture coverage stats (easy players per GW)
                const avgMinEasy = posResults.reduce((sum, r) => sum + r.minEasy, 0) / numSims;
                const avgMaxEasy = posResults.reduce((sum, r) => sum + r.maxEasy, 0) / numSims;
                const avgAvgEasy = posResults.reduce((sum, r) => sum + r.avgEasy, 0) / numSims;
                
                // Count GWs with at least 3 easy players (ideal for rotation)
                let gwsWith3Plus = 0;
                posResults.forEach(r => {
                    const gws3Plus = r.easyGamesPerGW.filter(e => e >= 3).length;
                    gwsWith3Plus += gws3Plus;
                });
                const avgGWsWith3Plus = gwsWith3Plus / numSims;
                
                // Count goal achievements
                let top2FWDCount = 0;
                let top5MIDCount = 0;
                
                posResults.forEach(r => {
                    const fwdRanks = r.squad.FWD.map(p => p.rank);
                    if (fwdRanks.filter(rank => rank <= 25).length >= 2) top2FWDCount++;
                    
                    const midRanks = r.squad.MID.map(p => p.rank);
                    if (midRanks.filter(rank => rank <= 15).length >= 1) top5MIDCount++;
                });
                
                // Find most common first picks
                const firstPicks = {};
                posResults.forEach(r => {
                    if (r.picks.length > 0) {
                        const name = r.picks[0].pick.name;
                        firstPicks[name] = (firstPicks[name] || 0) + 1;
                    }
                });
                const topFirstPicks = Object.entries(firstPicks)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([name, count]) => `${name} (${(count/numSims*100).toFixed(0)}%)`);
                
                results[pos] = {
                    position: pos,
                    avgScore,
                    avgCoverage,
                    avgMinEasy,
                    avgMaxEasy, 
                    avgAvgEasy,
                    avgGWsWith3Plus,
                    top2FWDProb: (top2FWDCount / numSims * 100).toFixed(1),
                    top5MIDProb: (top5MIDCount / numSims * 100).toFixed(1),
                    topFirstPicks
                };
                
                bestSquads[pos] = bestSquad;
            }
            
            progressEl.style.width = '100%';
            statusEl.style.display = 'none';
            
            // Display results
            displayAllPositionsResults(results);
            displayBestSquads(bestSquads);
            
            resultsSection.style.display = 'block';
            bestSquadsSection.style.display = 'block';
        }
        
        function displayAllPositionsResults(results) {
            const container = document.getElementById('allPositionsResults');
            
            // Find best position - balance score AND fixture coverage
            const sortedPositions = Object.values(results).sort((a, b) => {
                // Combined score: 60% player score, 40% fixture optimization
                const scoreA = a.avgScore + (a.avgGWsWith3Plus * 20);
                const scoreB = b.avgScore + (b.avgGWsWith3Plus * 20);
                return scoreB - scoreA;
            });
            const bestPos = sortedPositions[0].position;
            
            // Summary section
            let html = `
                <div style="background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px; margin-bottom: 1.5rem;">
                    <h3 style="color: var(--accent-cyan); margin-bottom: 1rem;">📊 Summary Analysis</h3>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; font-size: 0.9rem;">
                        <div>
                            <strong style="color: var(--accent-amber);">🎯 Best Overall:</strong> Position ${bestPos}
                        </div>
                        <div>
                            <strong style="color: var(--easy-game);">📈 Best Fixtures:</strong> Position ${Object.values(results).sort((a,b) => b.avgGWsWith3Plus - a.avgGWsWith3Plus)[0].position}
                        </div>
                        <div>
                            <strong style="color: var(--accent-violet);">⚡ Best Score:</strong> Position ${Object.values(results).sort((a,b) => b.avgScore - a.avgScore)[0].position}
                        </div>
                    </div>
                </div>
            `;
            
            html += '<div class="all-pos-grid">';
            
            for (let pos = 1; pos <= 8; pos++) {
                const r = results[pos];
                const isBest = pos === bestPos;
                
                // Calculate correct snake pick order
                const picks = [];
                for (let round = 0; round < 15; round++) {
                    const isEvenRound = round % 2 === 0;
                    const pickNum = isEvenRound ? (round * 8 + pos) : (round * 8 + (9 - pos));
                    if (picks.length < 4) picks.push(pickNum);
                }
                const pickOrder = picks.join(', ') + '...';
                
                html += `
                    <div class="pos-comparison-card ${isBest ? 'best' : ''}">
                        <div class="pos-number">${isBest ? '👑 ' : ''}#${pos}</div>
                        <div class="pos-pick-order">Picks: ${pickOrder}</div>
                        
                        <div class="pos-comparison-metrics">
                            <div class="pos-metric">
                                <div class="pos-metric-value" style="color: var(--accent-cyan);">${r.avgScore.toFixed(0)}</div>
                                <div class="pos-metric-label">Avg Score</div>
                            </div>
                            <div class="pos-metric">
                                <div class="pos-metric-value" style="color: var(--easy-game);">${r.avgCoverage.toFixed(1)}/19</div>
                                <div class="pos-metric-label">GW Coverage</div>
                            </div>
                            <div class="pos-metric">
                                <div class="pos-metric-value" style="color: var(--accent-amber);">${r.avgGWsWith3Plus.toFixed(1)}</div>
                                <div class="pos-metric-label">GWs w/ 3+ Easy</div>
                            </div>
                            <div class="pos-metric">
                                <div class="pos-metric-value" style="color: var(--accent-violet);">${r.avgAvgEasy.toFixed(1)}</div>
                                <div class="pos-metric-label">Avg Easy/GW</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 0.75rem; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px; font-size: 0.75rem;">
                            <div style="display: flex; justify-content: space-between;">
                                <span>Min Easy/GW: <strong>${r.avgMinEasy.toFixed(1)}</strong></span>
                                <span>Max Easy/GW: <strong>${r.avgMaxEasy.toFixed(1)}</strong></span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 0.25rem;">
                                <span>P(2 Top FWD): <strong style="color: var(--accent-amber);">${r.top2FWDProb}%</strong></span>
                                <span>P(1 Top MID): <strong style="color: var(--accent-violet);">${r.top5MIDProb}%</strong></span>
                            </div>
                        </div>
                        
                        <div class="pos-typical-players">
                            <h5>Typical 1st Pick:</h5>
                            <div>${r.topFirstPicks.join(', ')}</div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function displayBestSquads(bestSquads) {
            const container = document.getElementById('bestSquadsGrid');
            
            let html = '<div class="best-squads-grid">';
            
            for (let pos = 1; pos <= 8; pos++) {
                const squad = bestSquads[pos];
                if (!squad) continue;
                
                const allPlayers = Object.values(squad).flat();
                const totalScore = allPlayers.reduce((sum, p) => sum + p.score, 0);
                
                // Calculate easy games per GW for this squad
                const easyGamesPerGW = [];
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    let easyCount = 0;
                    allPlayers.forEach(p => {
                        if (fixtureData[p.team] && fixtureData[p.team][gw] <= 2) {
                            easyCount++;
                        }
                    });
                    easyGamesPerGW.push(easyCount);
                }
                
                const minEasy = Math.min(...easyGamesPerGW);
                const maxEasy = Math.max(...easyGamesPerGW);
                const avgEasy = (easyGamesPerGW.reduce((a, b) => a + b, 0) / easyGamesPerGW.length).toFixed(1);
                const gwsWith3Plus = easyGamesPerGW.filter(e => e >= 3).length;
                
                // Get unique teams
                const uniqueTeams = [...new Set(allPlayers.map(p => p.team))];
                
                html += `
                    <div class="best-squad-card">
                        <h4>Position ${pos} - Score: ${totalScore}</h4>
                        
                        <div style="background: var(--bg-secondary); padding: 0.5rem; border-radius: 6px; margin-bottom: 0.75rem; font-size: 0.75rem;">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem;">
                                <span>Easy/GW: <strong style="color: var(--easy-game);">${avgEasy}</strong></span>
                                <span>GWs ≥3: <strong style="color: var(--accent-amber);">${gwsWith3Plus}/19</strong></span>
                                <span>Min: <strong>${minEasy}</strong> Max: <strong>${maxEasy}</strong></span>
                                <span>Teams: <strong>${uniqueTeams.length}</strong></span>
                            </div>
                        </div>
                        
                        <div class="best-squad-list">
                `;
                
                ['GK', 'DEF', 'MID', 'FWD'].forEach(posType => {
                    squad[posType].forEach(p => {
                        const teamEasy = fixtureData[p.team] ? fixtureData[p.team].filter(f => f <= 2).length : 0;
                        html += `
                            <div class="best-squad-item">
                                <span>${p.name} <span style="color: var(--text-muted); font-size: 0.7rem;">(${p.team})</span></span>
                                <span style="color: var(--easy-game); font-size: 0.7rem;">${teamEasy}🎯</span>
                            </div>
                        `;
                    });
                });
                
                html += '</div></div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // ============================================
        // FULL DRAFT CONTROLLER - AI SUGGESTIONS
        // ============================================
        
        let fullDraftState = null;
        let fullDraftFilter = 'all';
        
        class FullDraftController {
            constructor() {
                this.teams = Array(8).fill(null).map(() => ({
                    GK: [], DEF: [], MID: [], FWD: []
                }));
                this.teamCounts = Array(8).fill(null).map(() => ({}));
                this.available = [...availablePlayers];
                this.currentRound = 0;
                this.currentPick = 0; // 0-7 within round
                this.totalPicks = 0;
                this.pickHistory = [];
            }
            
            getCurrentTeamIndex() {
                // Snake draft
                const isEvenRound = this.currentRound % 2 === 0;
                return isEvenRound ? this.currentPick : (7 - this.currentPick);
            }
            
            getTeamNeeds(teamIdx) {
                const squad = this.teams[teamIdx];
                return {
                    GK: 2 - squad.GK.length,
                    DEF: 5 - squad.DEF.length,
                    MID: 5 - squad.MID.length,
                    FWD: 3 - squad.FWD.length
                };
            }
            
            canPick(player, teamIdx) {
                const squad = this.teams[teamIdx];
                const needs = this.getTeamNeeds(teamIdx);
                
                // Position check
                if (needs[player.position] <= 0) return false;
                
                // Team limit (max 3 from same team)
                const teamCount = this.teamCounts[teamIdx][player.team] || 0;
                if (teamCount >= 3) return false;
                
                return true;
            }
            
            pick(player) {
                const teamIdx = this.getCurrentTeamIndex();
                const squad = this.teams[teamIdx];
                
                squad[player.position].push(player);
                this.teamCounts[teamIdx][player.team] = (this.teamCounts[teamIdx][player.team] || 0) + 1;
                this.available = this.available.filter(p => p.rank !== player.rank);
                
                this.pickHistory.push({
                    round: this.currentRound,
                    team: teamIdx,
                    player: player,
                    pickNum: this.totalPicks + 1
                });
                
                this.totalPicks++;
                this.currentPick++;
                
                if (this.currentPick >= 8) {
                    this.currentPick = 0;
                    this.currentRound++;
                }
            }
            
            isComplete() {
                return this.currentRound >= 15;
            }
            
            // Calculate AI score for a player pick
            calculatePickScore(player, teamIdx) {
                const rankWeight = (parseFloat(document.getElementById('fullDraftRankWeight')?.value) || 60) / 100;
                const scoreWeight = 1 - rankWeight;
                
                // Normalize rank (1-128 -> 0-100, lower rank = higher score)
                const maxRank = 128;
                const rankScore = ((maxRank - player.rank) / maxRank) * 100;
                
                // Normalize player score (0-153 -> 0-100)
                const maxScore = 153;
                const normalizedScore = (player.score / maxScore) * 100;
                
                // Base combined score
                let combinedScore = (rankScore * rankWeight) + (normalizedScore * scoreWeight);
                
                // Fixture coverage bonus - how many new GWs does this player cover?
                const currentTeams = this.getAllTeamsUsed(teamIdx);
                let newCoverageBonus = 0;
                
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    const alreadyCovered = currentTeams.some(t => fixtureData[t] && fixtureData[t][gw] <= EASY_THRESHOLD);
                    const playerCovers = fixtureData[player.team] && fixtureData[player.team][gw] <= EASY_THRESHOLD;
                    if (!alreadyCovered && playerCovers) {
                        newCoverageBonus += 3; // Bonus for new coverage
                    }
                }
                
                // Team diversity bonus (penalize if already have 2 from this team)
                const teamCount = this.teamCounts[teamIdx][player.team] || 0;
                const diversityPenalty = teamCount * 5;
                
                // Position priority (fill scarce positions first)
                const needs = this.getTeamNeeds(teamIdx);
                const totalNeeds = needs.GK + needs.DEF + needs.MID + needs.FWD;
                const positionNeed = needs[player.position];
                const positionBonus = (positionNeed / (totalNeeds || 1)) * 10;
                
                return combinedScore + newCoverageBonus - diversityPenalty + positionBonus;
            }
            
            getAllTeamsUsed(teamIdx) {
                const squad = this.teams[teamIdx];
                const allPlayers = [...squad.GK, ...squad.DEF, ...squad.MID, ...squad.FWD];
                return [...new Set(allPlayers.map(p => p.team))];
            }
            
            getTopSuggestions(count = 5) {
                const teamIdx = this.getCurrentTeamIndex();
                const validPlayers = this.available.filter(p => this.canPick(p, teamIdx));
                
                // Score each player
                const scored = validPlayers.map(p => ({
                    player: p,
                    aiScore: this.calculatePickScore(p, teamIdx)
                }));
                
                // Sort by AI score
                scored.sort((a, b) => b.aiScore - a.aiScore);
                
                return scored.slice(0, count);
            }
            
            // Calculate final N-K-D stats for a team
            getTeamNKDStats(teamIdx) {
                const squad = this.teams[teamIdx];
                const allPlayers = [...squad.GK, ...squad.DEF, ...squad.MID, ...squad.FWD];
                const playerTeams = allPlayers.map(p => p.team);
                
                // Count easy players per GW
                let successGWs = 0;
                const easyPerGW = [];
                
                for (let gw = 0; gw < gameweeks.length; gw++) {
                    let easyCount = 0;
                    allPlayers.forEach(p => {
                        if (fixtureData[p.team] && fixtureData[p.team][gw] <= EASY_THRESHOLD) {
                            easyCount++;
                        }
                    });
                    easyPerGW.push(easyCount);
                    if (easyCount >= 11) successGWs++; // K=11 for 15-11-3
                }
                
                // Max from one team
                const teamCounts = {};
                playerTeams.forEach(t => teamCounts[t] = (teamCounts[t] || 0) + 1);
                const maxFromOneTeam = Math.max(...Object.values(teamCounts));
                
                return {
                    N: allPlayers.length,
                    successGWs,
                    maxFromTeam: maxFromOneTeam,
                    avgEasy: (easyPerGW.reduce((a, b) => a + b, 0) / easyPerGW.length).toFixed(1),
                    minEasy: Math.min(...easyPerGW),
                    maxEasy: Math.max(...easyPerGW),
                    totalScore: allPlayers.reduce((sum, p) => sum + p.score, 0)
                };
            }
        }
        
        function startFullDraft() {
            fullDraftState = new FullDraftController();
            fullDraftFilter = 'all';
            
            document.getElementById('fullDraftStatus').style.display = 'block';
            document.getElementById('fullDraftResults').style.display = 'none';
            document.getElementById('autoCompleteBtn').style.display = 'inline-block';
            
            // Bind rank weight slider
            document.getElementById('fullDraftRankWeight').oninput = function() {
                document.getElementById('fullDraftRankWeightVal').textContent = this.value + '%';
                renderFullDraftUI();
            };
            
            renderFullDraftUI();
        }
        
        function renderFullDraftUI() {
            if (!fullDraftState || fullDraftState.isComplete()) {
                if (fullDraftState?.isComplete()) {
                    showFullDraftResults();
                }
                return;
            }
            
            const teamIdx = fullDraftState.getCurrentTeamIndex();
            
            // Update header
            document.getElementById('fullDraftRound').textContent = `Round ${fullDraftState.currentRound + 1}`;
            document.getElementById('fullDraftTeam').textContent = `Team ${teamIdx + 1}`;
            document.getElementById('fullDraftPickNum').textContent = fullDraftState.totalPicks + 1;
            
            // Render suggestions
            const suggestions = fullDraftState.getTopSuggestions(5);
            let suggestionsHtml = '';
            suggestions.forEach((s, i) => {
                const p = s.player;
                const teamEasy = fixtureData[p.team] ? fixtureData[p.team].filter(f => f <= EASY_THRESHOLD).length : 0;
                suggestionsHtml += `
                    <div class="suggestion-card ${i === 0 ? 'top-pick' : ''}" onclick="fullDraftPick(${p.rank})">
                        <div class="suggestion-rank">#${p.rank}</div>
                        <div class="suggestion-info">
                            <div class="suggestion-name">${p.name}</div>
                            <div class="suggestion-meta">
                                <span class="pos-tag ${p.position.toLowerCase()}" style="font-size: 0.6rem; padding: 0.1rem 0.3rem;">${p.position}</span>
                                ${p.team} • ${teamEasy} easy GWs
                            </div>
                        </div>
                        <div class="suggestion-score">
                            <div class="suggestion-score-main">${s.aiScore.toFixed(1)}</div>
                            <div class="suggestion-score-sub">Score: ${p.score}</div>
                        </div>
                    </div>
                `;
            });
            document.getElementById('fullDraftSuggestions').innerHTML = suggestionsHtml;
            
            // Render available players
            renderFullDraftAvailable();
            
            // Render all teams
            renderFullDraftTeams();
        }
        
        function renderFullDraftAvailable() {
            if (!fullDraftState) return;
            
            const teamIdx = fullDraftState.getCurrentTeamIndex();
            let filtered = fullDraftState.available;
            
            if (fullDraftFilter !== 'all') {
                filtered = filtered.filter(p => p.position === fullDraftFilter);
            }
            
            // Sort by rank
            filtered.sort((a, b) => a.rank - b.rank);
            
            let html = '';
            filtered.slice(0, 50).forEach(p => {
                const canPick = fullDraftState.canPick(p, teamIdx);
                const opacity = canPick ? '1' : '0.4';
                const cursor = canPick ? 'pointer' : 'not-allowed';
                
                html += `
                    <div class="available-player-row" style="opacity: ${opacity}; cursor: ${cursor};" 
                         onclick="${canPick ? `fullDraftPick(${p.rank})` : ''}">
                        <span style="font-family: 'JetBrains Mono', monospace; font-size: 0.7rem; color: var(--text-muted); min-width: 30px;">#${p.rank}</span>
                        <span class="pos-tag ${p.position.toLowerCase()}" style="font-size: 0.6rem; padding: 0.1rem 0.3rem;">${p.position}</span>
                        <span style="flex: 1; font-size: 0.85rem;">${p.name}</span>
                        <span style="font-size: 0.7rem; color: var(--text-muted);">${p.team}</span>
                        <span style="font-size: 0.75rem; color: var(--accent-emerald); min-width: 30px; text-align: right;">${p.score}</span>
                    </div>
                `;
            });
            
            if (filtered.length > 50) {
                html += `<div style="text-align: center; color: var(--text-muted); padding: 0.5rem;">+${filtered.length - 50} more...</div>`;
            }
            
            document.getElementById('fullDraftAvailable').innerHTML = html;
        }
        
        function renderFullDraftTeams() {
            if (!fullDraftState) return;
            
            const currentTeamIdx = fullDraftState.getCurrentTeamIndex();
            let html = '';
            
            for (let i = 0; i < 8; i++) {
                const squad = fullDraftState.teams[i];
                const allPlayers = [...squad.GK, ...squad.DEF, ...squad.MID, ...squad.FWD];
                const isCurrent = i === currentTeamIdx && !fullDraftState.isComplete();
                
                const playerList = allPlayers.length > 0 
                    ? allPlayers.map(p => `${p.name}`).join(', ')
                    : '<em>No picks yet</em>';
                
                html += `
                    <div class="mini-team-card ${isCurrent ? 'current' : ''}">
                        <div class="mini-team-header">
                            Team ${i + 1} ${isCurrent ? '⬅️' : ''} 
                            <span style="float: right; font-size: 0.7rem; color: var(--text-muted);">${allPlayers.length}/15</span>
                        </div>
                        <div class="mini-team-players">${playerList}</div>
                    </div>
                `;
            }
            
            document.getElementById('fullDraftTeams').innerHTML = html;
        }
        
        function filterFullDraft(pos) {
            fullDraftFilter = pos;
            
            // Update active button
            document.querySelectorAll('.pos-filter').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.pos === pos);
            });
            
            renderFullDraftAvailable();
        }
        
        function fullDraftPick(rank) {
            if (!fullDraftState || fullDraftState.isComplete()) return;
            
            const player = fullDraftState.available.find(p => p.rank === rank);
            if (!player) return;
            
            const teamIdx = fullDraftState.getCurrentTeamIndex();
            if (!fullDraftState.canPick(player, teamIdx)) return;
            
            fullDraftState.pick(player);
            renderFullDraftUI();
        }
        
        async function autoCompleteDraft() {
            if (!fullDraftState) return;
            
            document.getElementById('autoCompleteBtn').disabled = true;
            document.getElementById('autoCompleteBtn').textContent = '⏳ Running...';
            
            while (!fullDraftState.isComplete()) {
                const suggestions = fullDraftState.getTopSuggestions(1);
                if (suggestions.length > 0) {
                    fullDraftState.pick(suggestions[0].player);
                }
                
                // Yield to UI every 8 picks (1 round)
                if (fullDraftState.totalPicks % 8 === 0) {
                    renderFullDraftUI();
                    await new Promise(r => setTimeout(r, 10));
                }
            }
            
            document.getElementById('autoCompleteBtn').disabled = false;
            document.getElementById('autoCompleteBtn').textContent = '⚡ Auto-Complete';
            
            renderFullDraftUI();
        }
        
        function showFullDraftResults() {
            document.getElementById('fullDraftStatus').style.display = 'none';
            document.getElementById('fullDraftResults').style.display = 'block';
            
            let html = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">';
            
            // Collect stats and sort by total score
            const teamStats = [];
            for (let i = 0; i < 8; i++) {
                const stats = fullDraftState.getTeamNKDStats(i);
                teamStats.push({ teamIdx: i, ...stats });
            }
            teamStats.sort((a, b) => b.totalScore - a.totalScore);
            
            teamStats.forEach((stats, rank) => {
                const squad = fullDraftState.teams[stats.teamIdx];
                const allPlayers = [...squad.GK, ...squad.DEF, ...squad.MID, ...squad.FWD];
                
                // N-K-D success check
                const nkdSuccess = stats.N === 15 && stats.successGWs >= 10 && stats.maxFromTeam <= 3;
                const nkdColor = nkdSuccess ? 'var(--accent-emerald)' : 'var(--accent-rose)';
                
                html += `
                    <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 10px; border-left: 4px solid ${rank === 0 ? 'var(--accent-amber)' : 'var(--border-color)'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                            <h4 style="margin: 0; color: ${rank === 0 ? 'var(--accent-amber)' : 'var(--text-primary)'};">
                                ${rank === 0 ? '🥇' : rank === 1 ? '🥈' : rank === 2 ? '🥉' : '#' + (rank + 1)} Team ${stats.teamIdx + 1}
                            </h4>
                            <span style="font-weight: 700; font-size: 1.2rem; color: var(--accent-cyan);">${stats.totalScore}</span>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; font-size: 0.75rem;">
                            <div style="background: var(--bg-tertiary); padding: 0.4rem; border-radius: 4px; text-align: center;">
                                <div style="color: var(--text-muted);">Avg Easy</div>
                                <div style="color: var(--easy-game); font-weight: 700;">${stats.avgEasy}</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 0.4rem; border-radius: 4px; text-align: center;">
                                <div style="color: var(--text-muted);">GWs ≥11</div>
                                <div style="color: ${nkdColor}; font-weight: 700;">${stats.successGWs}/19</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 0.4rem; border-radius: 4px; text-align: center;">
                                <div style="color: var(--text-muted);">Max/Team</div>
                                <div style="color: ${stats.maxFromTeam <= 3 ? 'var(--easy-game)' : 'var(--accent-rose)'}; font-weight: 700;">${stats.maxFromTeam}</div>
                            </div>
                        </div>
                        
                        <div style="font-size: 0.7rem; color: var(--text-muted);">
                            ${['GK', 'DEF', 'MID', 'FWD'].map(pos => 
                                squad[pos].map(p => `<span style="color: var(--text-secondary);">${p.name}</span>`).join(', ')
                            ).filter(s => s).join(' • ')}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Add summary
            const best = teamStats[0];
            html += `
                <div style="margin-top: 1.5rem; padding: 1rem; background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.1)); border-radius: 10px; border: 1px solid var(--accent-amber);">
                    <h4 style="color: var(--accent-amber); margin-bottom: 0.5rem;">🏆 Best Team: Team ${best.teamIdx + 1}</h4>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">
                        Total Score: <strong>${best.totalScore}</strong> • 
                        Avg Easy/GW: <strong>${best.avgEasy}</strong> • 
                        Success GWs: <strong>${best.successGWs}/19</strong> • 
                        Max from team: <strong>${best.maxFromTeam}</strong>
                    </div>
                </div>
            `;
            
            document.getElementById('fullDraftFinalResults').innerHTML = html;
        }
        
        // ============================================
        // MY SQUAD ANALYZER
        // ============================================
        
        let mySquadInitialized = false;
        let mySquadPlayers = {
            GK: [null, null],
            DEF: [null, null, null, null, null],
            MID: [null, null, null, null, null],
            FWD: [null, null, null]
        };
        
        // Your squad from the image
        const yourSquadFromImage = {
            GK: [
                { name: 'Pickford', team: 'Everton' },
                { name: 'Areola', team: 'West Ham' }
            ],
            DEF: [
                { name: 'Schär', team: 'Newcastle' },
                { name: 'Saliba', team: 'Arsenal' },
                { name: 'Cash', team: 'Villa' },
                { name: 'Chalobah', team: 'Chelsea' },
                { name: 'Fofana', team: 'Chelsea' }
            ],
            MID: [
                { name: 'Rice', team: 'Arsenal' },
                { name: 'Gravenberch', team: 'Liverpool' },
                { name: 'Cunha', team: 'United' },
                { name: 'Grealish', team: 'Everton' },
                { name: 'Sarr', team: 'Palace' }
            ],
            FWD: [
                { name: 'Brobbey', team: 'Sunderland' },
                { name: 'João Pedro', team: 'Chelsea' },
                { name: 'Richarlison', team: 'Spurs' }
            ]
        };
        
        function initMySquadAnalyzer() {
            if (mySquadInitialized) return;
            mySquadInitialized = true;
            
            // Render squad input dropdowns for each position
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const container = document.getElementById(`squad${pos}`);
                const count = pos === 'GK' ? 2 : (pos === 'FWD' ? 3 : 5);
                
                let html = '';
                for (let i = 0; i < count; i++) {
                    const playersForPos = allWishlistPlayers.filter(p => p.position === pos);
                    html += `
                        <div style="margin-bottom: 0.5rem;">
                            <select id="squad${pos}${i}" onchange="updateSquadPlayer('${pos}', ${i}, this.value)"
                                style="width: 100%; padding: 0.5rem; border-radius: 6px; border: 1px solid var(--border-color); 
                                       background: var(--bg-secondary); color: var(--text-primary); font-size: 0.85rem;">
                                <option value="">-- Select ${pos} ${i + 1} --</option>
                                ${playersForPos.map(p => `<option value="${p.name}">${p.name} (${p.team}) - Rank ${p.rank}</option>`).join('')}
                            </select>
                        </div>
                    `;
                }
                container.innerHTML = html;
            });
        }
        
        function updateSquadPlayer(position, index, playerName) {
            if (!playerName) {
                mySquadPlayers[position][index] = null;
                return;
            }
            
            const player = allWishlistPlayers.find(p => p.name === playerName);
            mySquadPlayers[position][index] = player || null;
        }
        
        function loadUserSquadFromImage() {
            // Load the squad from the image you shared
            Object.entries(yourSquadFromImage).forEach(([pos, players]) => {
                players.forEach((squadPlayer, i) => {
                    // Find matching player in wishlist
                    const wishlistPlayer = allWishlistPlayers.find(p => 
                        p.name.toLowerCase().includes(squadPlayer.name.toLowerCase()) ||
                        squadPlayer.name.toLowerCase().includes(p.name.toLowerCase())
                    );
                    
                    // Also try to match by team if name doesn't work
                    const byTeamAndPos = allWishlistPlayers.find(p =>
                        p.position === pos && 
                        p.team === squadPlayer.team &&
                        p.name.toLowerCase().includes(squadPlayer.name.split(' ')[0].toLowerCase())
                    );
                    
                    const found = wishlistPlayer || byTeamAndPos;
                    
                    if (found) {
                        mySquadPlayers[pos][i] = found;
                        const select = document.getElementById(`squad${pos}${i}`);
                        if (select) {
                            // Find option with matching name
                            for (let opt of select.options) {
                                if (opt.value && opt.value.toLowerCase().includes(squadPlayer.name.toLowerCase().substring(0, 4))) {
                                    select.value = opt.value;
                                    break;
                                }
                            }
                        }
                    } else {
                        // Create a placeholder player if not in wishlist
                        mySquadPlayers[pos][i] = {
                            name: squadPlayer.name,
                            team: squadPlayer.team,
                            position: pos,
                            rank: 999,
                            score: 50,
                            playingChance: 100
                        };
                    }
                });
            });
            
            // Analyze immediately after loading
            analyzeMySquad();
        }
        
        function clearMySquad() {
            mySquadPlayers = {
                GK: [null, null],
                DEF: [null, null, null, null, null],
                MID: [null, null, null, null, null],
                FWD: [null, null, null]
            };
            
            // Reset all selects
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const count = pos === 'GK' ? 2 : (pos === 'FWD' ? 3 : 5);
                for (let i = 0; i < count; i++) {
                    const select = document.getElementById(`squad${pos}${i}`);
                    if (select) select.value = '';
                }
            });
            
            document.getElementById('squadAnalysisResults').style.display = 'none';
        }
        
        function analyzeMySquad() {
            // Flatten all players
            const allPlayers = [
                ...mySquadPlayers.GK,
                ...mySquadPlayers.DEF,
                ...mySquadPlayers.MID,
                ...mySquadPlayers.FWD
            ].filter(p => p !== null);
            
            if (allPlayers.length === 0) {
                alert('Please select at least some players first!');
                return;
            }
            
            document.getElementById('squadAnalysisResults').style.display = 'block';
            
            // Calculate basic stats
            const totalScore = allPlayers.reduce((sum, p) => sum + (p.score || 0), 0);
            const avgRank = (allPlayers.reduce((sum, p) => sum + (p.rank || 0), 0) / allPlayers.length).toFixed(1);
            
            document.getElementById('squadTotalScore').textContent = totalScore;
            document.getElementById('squadAvgRank').textContent = avgRank;
            
            // Calculate fixture coverage
            const gameweeks = Array.from({ length: 19 }, (_, i) => 20 + i);
            const coverageByGW = {};
            const defCoverageByGW = {};
            
            gameweeks.forEach(gw => {
                coverageByGW[gw] = { easy: 0, players: [] };
                defCoverageByGW[gw] = { easy: 0, players: [] };
            });
            
            // Calculate easy games for each player
            allPlayers.forEach(player => {
                const teamEasyGames = yourAnalysis[player.team] || [];
                gameweeks.forEach(gw => {
                    if (teamEasyGames.includes(gw)) {
                        coverageByGW[gw].easy++;
                        coverageByGW[gw].players.push(player.name);
                    }
                });
            });
            
            // DEF only coverage
            const defPlayers = mySquadPlayers.DEF.filter(p => p !== null);
            defPlayers.forEach(player => {
                const teamEasyGames = yourAnalysis[player.team] || [];
                gameweeks.forEach(gw => {
                    if (teamEasyGames.includes(gw)) {
                        defCoverageByGW[gw].easy++;
                        defCoverageByGW[gw].players.push(player.name);
                    }
                });
            });
            
            // Calculate N-K-D stats
            const easyPerGW = gameweeks.map(gw => coverageByGW[gw].easy);
            const avgEasy = (easyPerGW.reduce((a, b) => a + b, 0) / gameweeks.length).toFixed(1);
            const gwsWith11Plus = easyPerGW.filter(e => e >= 11).length;
            
            document.getElementById('squadAvgEasy').textContent = avgEasy;
            document.getElementById('squadEasyGWs').textContent = gwsWith11Plus;
            
            // Team distribution
            const teamCounts = {};
            allPlayers.forEach(p => {
                teamCounts[p.team] = (teamCounts[p.team] || 0) + 1;
            });
            
            const maxFromTeam = Math.max(...Object.values(teamCounts));
            const minK = Math.min(...easyPerGW);
            
            // N-K-D display
            document.getElementById('nkdN').textContent = allPlayers.length;
            document.getElementById('nkdK').textContent = minK;
            document.getElementById('nkdD').textContent = maxFromTeam;
            
            // N-K-D Verdict
            const targetK = 11;
            const targetD = 3;
            let nkdVerdict = '';
            let nkdClass = '';
            
            if (minK >= targetK && maxFromTeam <= targetD) {
                nkdVerdict = '✅ EXCELLENT! Your squad meets the optimal 15-11-3 criteria.';
                nkdClass = 'background: rgba(16, 185, 129, 0.2); border: 1px solid var(--accent-emerald);';
            } else if (minK >= targetK - 2 && maxFromTeam <= targetD) {
                nkdVerdict = '🟡 GOOD. Close to optimal, but some GWs have fewer than 11 easy fixtures.';
                nkdClass = 'background: rgba(245, 158, 11, 0.2); border: 1px solid var(--accent-amber);';
            } else {
                nkdVerdict = `⚠️ NEEDS IMPROVEMENT. Min easy/GW: ${minK} (target: 11), Max from team: ${maxFromTeam} (target: ≤3)`;
                nkdClass = 'background: rgba(239, 68, 68, 0.2); border: 1px solid var(--accent-rose);';
            }
            
            document.getElementById('nkdVerdict').innerHTML = nkdVerdict;
            document.getElementById('nkdVerdict').style.cssText = nkdClass;
            
            // DEF Analysis
            const defEasyPerGW = gameweeks.map(gw => defCoverageByGW[gw].easy);
            const defSuccessGWs = defEasyPerGW.filter(e => e >= 3).length;
            const defTeamCounts = {};
            defPlayers.forEach(p => {
                defTeamCounts[p.team] = (defTeamCounts[p.team] || 0) + 1;
            });
            const defMaxFromTeam = Math.max(...Object.values(defTeamCounts), 0);
            
            document.getElementById('defN').textContent = defPlayers.length;
            document.getElementById('defSuccessGWs').textContent = defSuccessGWs;
            document.getElementById('defMaxTeam').textContent = defMaxFromTeam;
            
            // DEF Coverage Chart
            let defChartHtml = '<div style="display: flex; gap: 2px; flex-wrap: wrap;">';
            gameweeks.forEach(gw => {
                const count = defCoverageByGW[gw].easy;
                const bgColor = count >= 3 ? 'var(--accent-emerald)' : count >= 2 ? 'var(--accent-amber)' : 'var(--accent-rose)';
                defChartHtml += `
                    <div style="width: 35px; text-align: center; padding: 0.25rem; border-radius: 4px; 
                                background: ${bgColor}; color: #000; font-size: 0.7rem;" 
                         title="GW${gw}: ${count} DEF with easy games\n${defCoverageByGW[gw].players.join(', ')}">
                        <div style="font-weight: bold;">${gw}</div>
                        <div>${count}</div>
                    </div>
                `;
            });
            defChartHtml += '</div>';
            document.getElementById('defCoverageChart').innerHTML = defChartHtml;
            
            // DEF Verdict
            let defVerdict = '';
            let defClass = '';
            
            if (defSuccessGWs >= 17 && defMaxFromTeam <= 2) {
                defVerdict = '✅ EXCELLENT DEF rotation! Great coverage with proper diversity.';
                defClass = 'background: rgba(16, 185, 129, 0.2); border: 1px solid var(--accent-emerald);';
            } else if (defSuccessGWs >= 14) {
                defVerdict = `🟡 GOOD DEF coverage. ${19 - defSuccessGWs} GWs have fewer than 3 easy defenders.`;
                defClass = 'background: rgba(245, 158, 11, 0.2); border: 1px solid var(--accent-amber);';
            } else {
                defVerdict = `⚠️ DEF COVERAGE WEAK. Only ${defSuccessGWs}/19 GWs have 3+ defenders with easy games.`;
                defClass = 'background: rgba(239, 68, 68, 0.2); border: 1px solid var(--accent-rose);';
            }
            
            document.getElementById('defVerdict').innerHTML = defVerdict;
            document.getElementById('defVerdict').style.cssText = defClass;
            
            // Fixture Coverage Heatmap
            let coverageHtml = `
                <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem;">
                    <tr style="background: var(--bg-tertiary);">
                        <th style="padding: 0.5rem; text-align: left; position: sticky; left: 0; background: var(--bg-tertiary);">GW</th>
                        ${gameweeks.map(gw => `<th style="padding: 0.3rem; min-width: 40px;">${gw}</th>`).join('')}
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; font-weight: bold; position: sticky; left: 0; background: var(--bg-secondary);">Easy</td>
                        ${gameweeks.map(gw => {
                            const count = coverageByGW[gw].easy;
                            const bgColor = count >= 11 ? 'rgba(16, 185, 129, 0.6)' : 
                                          count >= 8 ? 'rgba(245, 158, 11, 0.6)' : 'rgba(239, 68, 68, 0.6)';
                            return `<td style="padding: 0.3rem; text-align: center; background: ${bgColor}; font-weight: bold;" 
                                        title="${coverageByGW[gw].players.join(', ')}">${count}</td>`;
                        }).join('')}
                    </tr>
                </table>
            `;
            document.getElementById('squadFixtureCoverage').innerHTML = coverageHtml;
            
            // Team Distribution
            let teamDistHtml = '';
            const sortedTeams = Object.entries(teamCounts).sort((a, b) => b[1] - a[1]);
            sortedTeams.forEach(([team, count]) => {
                const teamPlayers = allPlayers.filter(p => p.team === team);
                const isOverLimit = count > 3;
                teamDistHtml += `
                    <div style="padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; 
                                border: 2px solid ${isOverLimit ? 'var(--accent-rose)' : 'var(--border-color)'};">
                        <div style="font-weight: 600; color: ${isOverLimit ? 'var(--accent-rose)' : 'var(--text-primary)'};">
                            ${team} (${count})
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">
                            ${teamPlayers.map(p => p.name).join(', ')}
                        </div>
                    </div>
                `;
            });
            document.getElementById('teamDistribution').innerHTML = teamDistHtml;
            
            // Generate improvement suggestions
            generateImprovementSuggestions(allPlayers, coverageByGW, defCoverageByGW, teamCounts, gameweeks);
        }
        
        function generateImprovementSuggestions(allPlayers, coverageByGW, defCoverageByGW, teamCounts, gameweeks) {
            let suggestions = [];
            
            // Find weak gameweeks (< 11 easy)
            const weakGWs = gameweeks.filter(gw => coverageByGW[gw].easy < 11);
            if (weakGWs.length > 0) {
                const worstGW = weakGWs.reduce((worst, gw) => 
                    coverageByGW[gw].easy < coverageByGW[worst].easy ? gw : worst, weakGWs[0]);
                
                // Find teams with easy games in weak GWs
                const helpfulTeams = teams.filter(team => {
                    const teamEasyGames = yourAnalysis[team] || [];
                    return weakGWs.some(gw => teamEasyGames.includes(gw));
                });
                
                // Find best teams to add (covering most weak GWs)
                const teamCoverage = helpfulTeams.map(team => {
                    const teamEasyGames = yourAnalysis[team] || [];
                    const coversWeakGWs = weakGWs.filter(gw => teamEasyGames.includes(gw)).length;
                    return { team, coversWeakGWs };
                }).sort((a, b) => b.coversWeakGWs - a.coversWeakGWs);
                
                const currentTeams = new Set(allPlayers.map(p => p.team));
                const newTeamOptions = teamCoverage.filter(t => !currentTeams.has(t.team)).slice(0, 3);
                
                suggestions.push({
                    type: 'weak_gws',
                    priority: 'high',
                    title: `⚠️ ${weakGWs.length} GWs with fewer than 11 easy fixtures`,
                    detail: `Worst: GW${worstGW} (only ${coverageByGW[worstGW].easy} easy)`,
                    recommendation: newTeamOptions.length > 0 
                        ? `Consider adding players from: ${newTeamOptions.map(t => `<strong>${t.team}</strong> (covers ${t.coversWeakGWs} weak GWs)`).join(', ')}`
                        : 'Consider swapping players from double-stacked teams for better coverage.'
                });
            }
            
            // DEF weak gameweeks (< 3 easy)
            const defWeakGWs = gameweeks.filter(gw => defCoverageByGW[gw].easy < 3);
            if (defWeakGWs.length > 0) {
                const defPlayers = mySquadPlayers.DEF.filter(p => p !== null);
                const defTeams = new Set(defPlayers.map(p => p.team));
                
                // Find best DEF teams to add
                const defHelpfulTeams = teams.filter(team => !defTeams.has(team)).map(team => {
                    const teamEasyGames = yourAnalysis[team] || [];
                    const coversDefWeakGWs = defWeakGWs.filter(gw => teamEasyGames.includes(gw)).length;
                    return { team, coversDefWeakGWs };
                }).filter(t => t.coversDefWeakGWs > 0).sort((a, b) => b.coversDefWeakGWs - a.coversDefWeakGWs).slice(0, 5);
                
                // Find DEF players from those teams
                const defRecommendations = defHelpfulTeams.map(t => {
                    const defFromTeam = allWishlistPlayers.filter(p => p.position === 'DEF' && p.team === t.team);
                    const bestDef = defFromTeam.sort((a, b) => a.rank - b.rank)[0];
                    return { ...t, player: bestDef };
                }).filter(t => t.player);
                
                suggestions.push({
                    type: 'def_rotation',
                    priority: 'high',
                    title: `🛡️ DEF Rotation Issues: ${defWeakGWs.length} GWs with <3 easy defenders`,
                    detail: `Weak GWs: ${defWeakGWs.slice(0, 5).join(', ')}${defWeakGWs.length > 5 ? '...' : ''}`,
                    recommendation: defRecommendations.length > 0
                        ? `Best DEF additions: ${defRecommendations.slice(0, 3).map(t => 
                            `<strong>${t.player.name}</strong> (${t.team}, Rank ${t.player.rank}, covers ${t.coversDefWeakGWs} weak GWs)`).join(', ')}`
                        : 'Current DEF coverage needs improvement. Look for defenders from teams with different fixture patterns.'
                });
            }
            
            // Team concentration warnings
            const overloadedTeams = Object.entries(teamCounts).filter(([team, count]) => count > 3);
            if (overloadedTeams.length > 0) {
                suggestions.push({
                    type: 'team_limit',
                    priority: 'medium',
                    title: `🏢 Team Concentration: ${overloadedTeams.length} team(s) over 3 players`,
                    detail: overloadedTeams.map(([team, count]) => `${team}: ${count} players`).join(', '),
                    recommendation: 'Consider diversifying to improve fixture coverage and reduce blank GW risk.'
                });
            }
            
            // Check for Chelsea triple-up (from your image)
            if (teamCounts['Chelsea'] && teamCounts['Chelsea'] >= 3) {
                const chelseaEasyGWs = yourAnalysis['Chelsea'] || [];
                const chelseaHardGWs = gameweeks.filter(gw => !chelseaEasyGWs.includes(gw));
                suggestions.push({
                    type: 'chelsea_heavy',
                    priority: 'medium',
                    title: '🔵 Chelsea Heavy: 3 players from same team',
                    detail: `Chelsea has ${chelseaEasyGWs.length} easy GWs but hard fixtures in GW${chelseaHardGWs.slice(0, 3).join(', ')}`,
                    recommendation: 'João Pedro, Chalobah, Fofana all share same fixture difficulty. Consider spreading to different teams.'
                });
            }
            
            // Position-specific advice
            const positionSuggestions = [];
            
            // Check GK rotation
            const gkPlayers = mySquadPlayers.GK.filter(p => p !== null);
            if (gkPlayers.length === 2) {
                const gkTeams = gkPlayers.map(p => p.team);
                let gkCoverage = 0;
                gameweeks.forEach(gw => {
                    const hasEasy = gkTeams.some(team => (yourAnalysis[team] || []).includes(gw));
                    if (hasEasy) gkCoverage++;
                });
                if (gkCoverage < 17) {
                    suggestions.push({
                        type: 'gk_rotation',
                        priority: 'low',
                        title: `🧤 GK Rotation: ${gkCoverage}/19 GWs covered`,
                        detail: `Current GKs: ${gkPlayers.map(p => `${p.name} (${p.team})`).join(', ')}`,
                        recommendation: 'Look for GK pairs that complement each other\'s fixtures better.'
                    });
                }
            }
            
            // Render suggestions
            let suggestionsHtml = '';
            if (suggestions.length === 0) {
                suggestionsHtml = `
                    <div style="padding: 1.5rem; text-align: center; background: rgba(16, 185, 129, 0.1); border-radius: 8px;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">🎉</div>
                        <div style="color: var(--accent-emerald); font-weight: 600;">Great squad! No major issues detected.</div>
                    </div>
                `;
            } else {
                suggestions.sort((a, b) => {
                    const priorityOrder = { high: 0, medium: 1, low: 2 };
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                });
                
                suggestions.forEach(s => {
                    const priorityColor = s.priority === 'high' ? 'var(--accent-rose)' : 
                                         s.priority === 'medium' ? 'var(--accent-amber)' : 'var(--text-muted)';
                    suggestionsHtml += `
                        <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 0.75rem;
                                    border-left: 3px solid ${priorityColor};">
                            <div style="font-weight: 600; margin-bottom: 0.5rem;">${s.title}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">${s.detail}</div>
                            <div style="font-size: 0.85rem; color: var(--accent-cyan);">
                                💡 ${s.recommendation}
                            </div>
                        </div>
                    `;
                });
            }
            
            document.getElementById('improvementSuggestions').innerHTML = suggestionsHtml;
        }

        // ============================================
        // LEAGUE IMPORT SYSTEM
        // ============================================
        
        // FPL Element ID to Player Mapping (will be populated from bootstrap data)
        let fplElementMap = {};
        let importedLeagueData = null;
        let importedElementStatus = null;
        let importedBootstrap = null;
        let importedPlayerDetails = null;
        
        // LocalStorage key for persisting data
        const STORAGE_KEY = 'fpl_league_data';
        const API_KEY_STORAGE = 'football_data_api_key';
        
        // ========== FOOTBALL-DATA.ORG API KEY FUNCTIONS ==========
        
        function saveFootballDataApiKey() {
            const keyInput = document.getElementById('footballDataApiKey');
            const statusDiv = document.getElementById('apiKeyStatus');
            const key = keyInput.value.trim();
            
            if (!key) {
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = '<span style="color: var(--accent-rose);">❌ Please enter an API key</span>';
                return;
            }
            
            localStorage.setItem(API_KEY_STORAGE, key);
            statusDiv.style.display = 'block';
            statusDiv.innerHTML = '<span style="color: var(--accent-emerald);">✅ API key saved! Click "Test & Fetch Standings" to verify.</span>';
        }
        
        function loadFootballDataApiKey() {
            const saved = localStorage.getItem(API_KEY_STORAGE);
            if (saved) {
                const keyInput = document.getElementById('footballDataApiKey');
                if (keyInput) {
                    keyInput.value = saved;
                }
            }
            return saved;
        }
        
        async function testFootballDataApiKey() {
            const keyInput = document.getElementById('footballDataApiKey');
            const statusDiv = document.getElementById('apiKeyStatus');
            const key = keyInput?.value?.trim() || localStorage.getItem(API_KEY_STORAGE);
            
            if (!key) {
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = '<span style="color: var(--accent-rose);">❌ No API key found. Please enter your key first.</span>';
                return;
            }
            
            statusDiv.style.display = 'block';
            statusDiv.innerHTML = '<span style="color: var(--accent-cyan);">⏳ Fetching PL standings...</span>';
            
            try {
                const standings = await fetchStandingsFromFootballData(key);
                
                if (standings && standings.length > 0) {
                    // Save key since it works
                    localStorage.setItem(API_KEY_STORAGE, key);
                    
                    // Store standings globally
                    window.importedPLStandings = standings;
                    
                    // Update batch cache if initialized
                    if (batchAnalysisCache) {
                        batchAnalysisCache.plStandings = standings;
                        batchAnalysisCache.standingsSource = 'football-data.org';
                    }
                    
                    // Save to localStorage with league data
                    saveLeagueData();
                    
                    const top5 = standings.slice(0, 5).map(t => `${t.position}. ${t.short_name} (${t.points}pts, GF:${t.goalsFor})`).join(', ');
                    const totalGoals = standings.reduce((sum, t) => sum + (t.goalsFor || 0), 0);
                    statusDiv.innerHTML = `<span style="color: var(--accent-emerald);">✅ Success! Fetched ${standings.length} teams. Total goals: ${totalGoals}<br>Top 5: ${top5}</span>`;
                } else {
                    statusDiv.innerHTML = '<span style="color: var(--accent-rose);">❌ No standings data returned. Check API key.</span>';
                }
            } catch (error) {
                statusDiv.innerHTML = `<span style="color: var(--accent-rose);">❌ Error: ${error.message}</span>`;
            }
        }
        
        async function fetchStandingsFromFootballData(apiKey) {
            console.log('[Standings] Fetching from football-data.org...');
            
            const apiUrl = 'https://api.football-data.org/v4/competitions/PL/standings';
            
            // CORS proxies that can forward headers
            const corsProxies = [
                // Direct fetch first (works if running from a server)
                { url: apiUrl, direct: true },
                // corsproxy.io supports header forwarding
                { url: `https://corsproxy.io/?${encodeURIComponent(apiUrl)}`, direct: false },
                // allorigins as fallback (but may not forward auth headers)
                { url: `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl + '?apiKey=' + apiKey)}`, direct: false, noHeader: true }
            ];
            
            let lastError = null;
            
            for (const proxy of corsProxies) {
                try {
                    console.log('[Standings] Trying:', proxy.direct ? 'direct' : proxy.url.split('?')[0]);
                    
                    const fetchOptions = {};
                    if (!proxy.noHeader) {
                        fetchOptions.headers = { 'X-Auth-Token': apiKey };
                    }
                    
                    const response = await fetch(proxy.url, fetchOptions);
                    
                    if (!response.ok) {
                        console.warn('[Standings] Response not ok:', response.status);
                        continue;
                    }
                    
                    const data = await response.json();
                    
                    if (!data.standings) {
                        console.warn('[Standings] No standings in response');
                        continue;
                    }
                    
                    console.log('[Standings] ✅ Success via', proxy.direct ? 'direct' : 'proxy');
                    
                    // Parse the standings from football-data.org format
                    const table = data.standings?.[0]?.table || [];
                    
                    const standings = table.map(entry => ({
                        id: entry.team.id,
                        name: entry.team.name,
                        short_name: entry.team.tla || entry.team.shortName || entry.team.name.substring(0, 3).toUpperCase(),
                        position: entry.position,
                        played: entry.playedGames,
                        wins: entry.won,
                        draws: entry.draw,
                        losses: entry.lost,
                        goalsFor: entry.goalsFor,
                        goalsAgainst: entry.goalsAgainst,
                        goalDiff: entry.goalDifference,
                        points: entry.points,
                        cleanSheets: 0,
                        games: entry.playedGames
                    }));
                    
                    console.log('[Standings] Parsed standings:', standings.slice(0, 5).map(t => `${t.position}. ${t.short_name} (${t.points}pts, GF:${t.goalsFor}, GA:${t.goalsAgainst})`));
                    
                    return standings;
                    
                } catch (error) {
                    console.warn('[Standings] Fetch failed:', error.message);
                    lastError = error;
                }
            }
            
            throw lastError || new Error('All fetch attempts failed');
        }
        
        // Try to load saved data on init
        function loadSavedData() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    return data;
                }
            } catch(e) {
                console.log('Failed to load saved data:', e);
            }
            return null;
        }
        
        // Save data to localStorage
        function saveLeagueData() {
            try {
                const dataToSave = {
                    league: importedLeagueData,
                    elements: importedElementStatus,
                    bootstrap: importedBootstrap,
                    playerDetails: importedPlayerDetails,
                    plStandings: window.importedPLStandings || null,
                    plFixtures: window.importedPLFixtures || null,
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                return true;
            } catch(e) {
                console.log('Failed to save data:', e);
                return false;
            }
        }
        
        // Clear saved data
        function clearSavedData() {
            localStorage.removeItem(STORAGE_KEY);
            importedLeagueData = null;
            importedElementStatus = null;
            importedBootstrap = null;
            importedPlayerDetails = null;
            document.getElementById('savedDataStatus').style.display = 'none';
            document.getElementById('leagueAnalysisResults').style.display = 'none';
            document.getElementById('importStatus').style.display = 'none';
        }
        
        // FPL Team IDs to names - built dynamically from bootstrap data
        let fplTeamIdMap = {};
        
        // Build team ID map from bootstrap data
        function buildFplTeamIdMap() {
            if (importedBootstrap && importedBootstrap.teams && Array.isArray(importedBootstrap.teams)) {
                fplTeamIdMap = {};
                importedBootstrap.teams.forEach(team => {
                    // Use short_name for brevity (e.g., "ARS", "AVL") or name for full name
                    fplTeamIdMap[team.id] = team.short_name || team.name || 'Unknown';
                });
                console.log('Built fplTeamIdMap from bootstrap:', fplTeamIdMap);
            } else {
                // Fallback to hardcoded values if bootstrap not available
                fplTeamIdMap = {
                    1: 'ARS', 2: 'AVL', 3: 'BOU', 4: 'BRE',
                    5: 'BHA', 6: 'CHE', 7: 'CRY', 8: 'EVE',
                    9: 'FUL', 10: 'IPS', 11: 'LEI', 12: 'LIV',
                    13: 'MCI', 14: 'MUN', 15: 'NEW', 16: 'NFO',
                    17: 'SOU', 18: 'TOT', 19: 'WHU', 20: 'WOL'
                };
            }
        }
        
        // Initialize with fallback
        buildFplTeamIdMap();
        
        // Position IDs
        const fplPositionMap = {
            1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD'
        };
        
        // File upload handler
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const statusEl = document.getElementById('uploadStatus');
            statusEl.innerHTML = '<span style="color: var(--accent-amber);">📖 Reading file...</span>';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    document.getElementById('leagueDataInput').value = e.target.result;
                    statusEl.innerHTML = '<span style="color: var(--accent-emerald);">✅ File loaded: ' + file.name + '</span>';
                    
                    // Auto-process
                    setTimeout(() => processLeagueData(), 100);
                } catch (err) {
                    statusEl.innerHTML = '<span style="color: var(--accent-rose);">❌ Invalid JSON file</span>';
                }
            };
            reader.readAsText(file);
        }
        
        // Setup drag and drop
        function setupDropZone() {
            const dropZone = document.getElementById('dropZone');
            if (!dropZone) return;
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = 'var(--accent-emerald)';
                dropZone.style.background = 'rgba(16, 185, 129, 0.1)';
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = 'var(--border-color)';
                dropZone.style.background = 'var(--bg-tertiary)';
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = 'var(--border-color)';
                dropZone.style.background = 'var(--bg-tertiary)';
                
                const file = e.dataTransfer.files[0];
                if (file && file.name.endsWith('.json')) {
                    document.getElementById('jsonFileInput').files = e.dataTransfer.files;
                    handleFileUpload({ target: { files: [file] } });
                }
            });
        }
        
        // Player detail modal - UNIFIED COMPREHENSIVE VIEW
        async function showPlayerDetail(playerId) {
            // Try to get data via DataService (cache → DB → local)
            let bs = {};
            let history = [];
            
            if (typeof DataService !== 'undefined') {
                try {
                    const player = await DataService.getPlayer(playerId, true);
                    if (player && player.id) {
                        bs = player;
                        history = player.history || [];
                        console.log('[PlayerDetail] Loaded via DataService:', player.web_name);
                    }
                } catch (e) {
                    console.warn('[PlayerDetail] DataService fetch failed:', e);
                }
            }
            
            // Fall back to local data if DataService didn't work
            if (!bs.id) {
                const player = getPlayerById(playerId);
                const bootstrap = importedBootstrap?.elements?.find(e => e.id === playerId);
                const details = importedPlayerDetails?.[playerId];
                bs = bootstrap || {};
                history = details?.history || [];
            }
            
            if (!bs.id && !bs.web_name) {
                alert('Player data not found');
                return;
            }
            
            // Remove existing modal if any
            document.getElementById('playerModal')?.remove();
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'playerModal';
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:99999;overflow-y:auto;padding:2rem;';
            
            const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const pos = positionMap[bs.position] || fplPositionMap[bs.element_type] || 'MID';
            const teamName = bs.team_name || fplTeamIdMap[bs.team_id] || fplTeamIdMap[bs.team] || 'Unknown';
            
            // Calculate distribution from history
            const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
            const dist = calculateTightDistribution(scores);
            
            // Calculate form analysis
            let formTrend = 'STABLE';
            let recentAvg = 0;
            let seasonAvg = dist.expected || 0;
            
            if (scores.length >= 3) {
                const recent3 = scores.slice(-3);
                recentAvg = recent3.reduce((a, b) => a + b, 0) / recent3.length;
                
                if (scores.length >= 5) {
                    const prev5 = scores.slice(-8, -3);
                    const prev5Avg = prev5.length > 0 ? prev5.reduce((a, b) => a + b, 0) / prev5.length : seasonAvg;
                    if (recentAvg > prev5Avg * 1.2) formTrend = 'HOT';
                    else if (recentAvg < prev5Avg * 0.8) formTrend = 'COLD';
                }
            }
            
            // Get score color function
            const scoreColor = (pts) => {
                if (pts >= 10) return '#10b981';
                if (pts >= 6) return '#22d3ee';
                if (pts >= 3) return '#f1f5f9';
                if (pts > 0) return '#f59e0b';
                return '#f43f5e';
            };
            
            const trendIcons = { HOT: '🔥', COLD: '❄️', STABLE: '➖' };
            const trendColors = { HOT: '#10b981', COLD: '#f43f5e', STABLE: '#94a3b8' };
            
            // Build history table
            let historyHtml = '';
            if (history.length > 0) {
                historyHtml = '<div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;font-size:0.8rem;">';
                historyHtml += '<tr style="background:#1e293b;"><th style="padding:0.5rem;border:1px solid #334155;">GW</th><th style="padding:0.5rem;border:1px solid #334155;">Opp</th><th style="padding:0.5rem;border:1px solid #334155;">Pts</th><th style="padding:0.5rem;border:1px solid #334155;">Min</th><th style="padding:0.5rem;border:1px solid #334155;">G</th><th style="padding:0.5rem;border:1px solid #334155;">A</th><th style="padding:0.5rem;border:1px solid #334155;">CS</th><th style="padding:0.5rem;border:1px solid #334155;">Bonus</th></tr>';
                
                history.slice().reverse().forEach(gw => {
                    const oppTeam = gw.opponent_name || fplTeamIdMap[gw.opponent_id] || fplTeamIdMap[gw.opponent_team] || gw.opponent_team || '?';
                    const gwNum = gw.gameweek || gw.round || gw.event || '?';
                    const pts = gw.total_points || 0;
                    historyHtml += '<tr style="background:#111827;">' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;">GW' + gwNum + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;">' + (gw.was_home ? '' : '@') + oppTeam + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;color:' + scoreColor(pts) + ';font-weight:700;">' + pts + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;">' + (gw.minutes || 0) + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;color:#10b981;">' + (gw.goals_scored || 0) + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;color:#8b5cf6;">' + (gw.assists || 0) + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;color:#10b981;">' + (gw.clean_sheets || 0) + '</td>' +
                        '<td style="padding:0.5rem;border:1px solid #334155;text-align:center;">' + (gw.bonus || 0) + '</td>' +
                    '</tr>';
                });
                historyHtml += '</table></div>';
            }
            
            // Build recent scores badges
            const recentScoresHtml = scores.slice(-10).reverse().map(pts => 
                `<span style="display:inline-flex;align-items:center;justify-content:center;width:32px;height:32px;border-radius:6px;font-weight:600;background:${scoreColor(pts)}20;color:${scoreColor(pts)};border:1px solid ${scoreColor(pts)}50;">${pts}</span>`
            ).join('');
            
            modal.innerHTML = `
                <div style="max-width:950px;margin:0 auto;background:#111827;border-radius:16px;padding:2rem;border:2px solid ${posColors[pos]};">
                    <!-- Header -->
                    <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #334155;">
                        <div>
                            <div style="font-size:2rem;font-weight:700;">${bs.web_name || 'Unknown'}</div>
                            <div style="color:#94a3b8;">${bs.first_name || ''} ${bs.second_name || ''}</div>
                            <div style="margin-top:0.5rem;display:flex;align-items:center;gap:0.5rem;">
                                <span style="background:${posColors[pos]};color:#000;padding:0.25rem 0.75rem;border-radius:4px;font-weight:600;font-size:0.85rem;">${pos}</span>
                                <span style="color:#94a3b8;">${teamName}</span>
                                ${bs.news ? '<span style="color:#f59e0b;font-size:0.8rem;">⚠️ ' + (bs.chance_of_playing_next_round !== null ? bs.chance_of_playing_next_round + '%' : 'Doubt') + '</span>' : ''}
                            </div>
                        </div>
                        <div style="display:flex;gap:0.5rem;">
                            <button onclick="document.getElementById('playerModal').remove(); quickCompare(${bs.id || playerId})" style="background:#8b5cf6;border:none;padding:0.5rem 1rem;border-radius:8px;cursor:pointer;color:#fff;font-size:0.85rem;">⚖️ Compare</button>
                            <button onclick="document.getElementById('playerModal').remove()" style="background:#334155;border:none;padding:0.5rem 1rem;border-radius:8px;cursor:pointer;color:#fff;font-size:1.2rem;">✕</button>
                        </div>
                    </div>
                    
                    <!-- Two Column Layout -->
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-bottom:1.5rem;">
                        
                        <!-- Left: Distribution Dashboard -->
                        <div style="background:#1e293b;border-radius:12px;padding:1.25rem;">
                            <h4 style="color:#22d3ee;margin:0 0 1rem 0;font-size:1rem;">📊 Score Distribution</h4>
                            
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-bottom:1rem;">
                                <div>
                                    <div style="font-size:0.7rem;color:#64748b;">Expected Points</div>
                                    <div style="font-size:2rem;font-weight:700;color:#22d3ee;">${dist.expected.toFixed(1)}</div>
                                </div>
                                <div>
                                    <div style="font-size:0.7rem;color:#64748b;">80% Range</div>
                                    <div style="font-size:2rem;font-weight:700;color:#10b981;">${dist.ci_80[0]}-${dist.ci_80[1]}</div>
                                </div>
                            </div>
                            
                            <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:0.5rem;margin-bottom:1rem;">
                                <div style="text-align:center;padding:0.5rem;background:#0f172a;border-radius:6px;">
                                    <div style="font-size:0.65rem;color:#64748b;">Floor (15%)</div>
                                    <div style="font-size:1.1rem;font-weight:600;color:#f43f5e;">${dist.floor.toFixed(0)}</div>
                                </div>
                                <div style="text-align:center;padding:0.5rem;background:#0f172a;border-radius:6px;">
                                    <div style="font-size:0.65rem;color:#64748b;">Median</div>
                                    <div style="font-size:1.1rem;font-weight:600;">${Math.round(dist.expected)}</div>
                                </div>
                                <div style="text-align:center;padding:0.5rem;background:#0f172a;border-radius:6px;">
                                    <div style="font-size:0.65rem;color:#64748b;">Upside (85%)</div>
                                    <div style="font-size:1.1rem;font-weight:600;color:#10b981;">${dist.upside.toFixed(0)}</div>
                                </div>
                                <div style="text-align:center;padding:0.5rem;background:#0f172a;border-radius:6px;">
                                    <div style="font-size:0.65rem;color:#64748b;">Games</div>
                                    <div style="font-size:1.1rem;font-weight:600;">${scores.length}</div>
                                </div>
                            </div>
                            
                            <!-- Distribution Chart -->
                            <div style="height:150px;background:#0f172a;border-radius:8px;display:flex;align-items:flex-end;justify-content:center;gap:3px;padding:1rem 0.5rem;">
                                ${(() => {
                                    const probs = dist.probabilities || {};
                                    const entries = Object.entries(probs).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
                                    const maxProb = Math.max(...Object.values(probs), 0.01);
                                    const maxHeight = 120; // px
                                    
                                    // Fill in missing scores from 0 to max score
                                    const minScore = Math.min(...entries.map(e => parseInt(e[0])), 0);
                                    const maxScore = Math.max(...entries.map(e => parseInt(e[0])), 15);
                                    
                                    let html = '';
                                    for (let s = minScore; s <= Math.min(maxScore, 18); s++) {
                                        const prob = probs[s] || 0;
                                        const height = prob > 0 ? Math.max(4, (prob / maxProb) * maxHeight) : 2;
                                        const color = prob > 0 ? '#22d3ee' : '#334155';
                                        html += '<div style="display:flex;flex-direction:column;align-items:center;gap:2px;">' +
                                            '<div style="width:20px;height:' + height + 'px;background:' + color + ';border-radius:3px 3px 0 0;" title="' + s + ' pts: ' + (prob * 100).toFixed(1) + '%"></div>' +
                                            '<div style="font-size:0.6rem;color:#64748b;">' + s + '</div>' +
                                        '</div>';
                                    }
                                    return html;
                                })()}
                            </div>
                            <div style="text-align:center;font-size:0.7rem;color:#64748b;margin-top:0.25rem;">Score Probability Distribution (Points)</div>
                        </div>
                        
                        <!-- Right: Form & Season Stats -->
                        <div>
                            <!-- Form Analysis -->
                            <div style="background:#1e293b;border-radius:12px;padding:1.25rem;margin-bottom:1rem;">
                                <h4 style="color:#10b981;margin:0 0 1rem 0;font-size:1rem;">🔥 Form Analysis</h4>
                                
                                <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;margin-bottom:1rem;">
                                    <div style="background:#0f172a;padding:0.75rem;border-radius:8px;">
                                        <div style="font-size:0.65rem;color:#64748b;">Recent (3 games)</div>
                                        <div style="font-size:1.5rem;font-weight:700;color:#22d3ee;">${recentAvg.toFixed(1)}</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.75rem;border-radius:8px;">
                                        <div style="font-size:0.65rem;color:#64748b;">Season Avg</div>
                                        <div style="font-size:1.5rem;font-weight:700;">${seasonAvg.toFixed(1)}</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.75rem;border-radius:8px;">
                                        <div style="font-size:0.65rem;color:#64748b;">Trend</div>
                                        <div style="font-size:1rem;font-weight:600;color:${trendColors[formTrend]};">${trendIcons[formTrend]} ${formTrend}</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.75rem;border-radius:8px;">
                                        <div style="font-size:0.65rem;color:#64748b;">Consistency</div>
                                        <div style="font-size:1rem;font-weight:600;color:${dist.std <= 3 ? '#10b981' : dist.std <= 5 ? '#f59e0b' : '#f43f5e'};">${dist.std <= 3 ? 'High' : dist.std <= 5 ? 'Medium' : 'Low'}</div>
                                    </div>
                                </div>
                                
                                <div style="font-size:0.7rem;color:#64748b;margin-bottom:0.5rem;">Recent Scores</div>
                                <div style="display:flex;gap:0.25rem;flex-wrap:wrap;">
                                    ${recentScoresHtml || '<span style="color:#64748b;">No recent scores</span>'}
                                </div>
                            </div>
                            
                            <!-- Season Stats -->
                            <div style="background:#1e293b;border-radius:12px;padding:1.25rem;">
                                <h4 style="color:#f59e0b;margin:0 0 1rem 0;font-size:1rem;">📋 Season Stats</h4>
                                <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:0.5rem;">
                                    <div style="background:#0f172a;padding:0.5rem;border-radius:6px;text-align:center;">
                                        <div style="font-size:1.3rem;font-weight:700;color:#22d3ee;">${bs.total_points || 0}</div>
                                        <div style="font-size:0.6rem;color:#64748b;">Total Pts</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.5rem;border-radius:6px;text-align:center;">
                                        <div style="font-size:1.3rem;font-weight:700;color:#10b981;">${bs.goals_scored || 0}</div>
                                        <div style="font-size:0.6rem;color:#64748b;">Goals</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.5rem;border-radius:6px;text-align:center;">
                                        <div style="font-size:1.3rem;font-weight:700;color:#8b5cf6;">${bs.assists || 0}</div>
                                        <div style="font-size:0.6rem;color:#64748b;">Assists</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.5rem;border-radius:6px;text-align:center;">
                                        <div style="font-size:1.3rem;font-weight:700;color:#10b981;">${bs.clean_sheets || 0}</div>
                                        <div style="font-size:0.6rem;color:#64748b;">CS</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.5rem;border-radius:6px;text-align:center;">
                                        <div style="font-size:1.3rem;font-weight:700;">${bs.minutes || 0}</div>
                                        <div style="font-size:0.6rem;color:#64748b;">Minutes</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.5rem;border-radius:6px;text-align:center;">
                                        <div style="font-size:1.3rem;font-weight:700;color:#f59e0b;">${bs.bonus || 0}</div>
                                        <div style="font-size:0.6rem;color:#64748b;">Bonus</div>
                                    </div>
                                </div>
                                <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:0.5rem;margin-top:0.5rem;">
                                    <div style="background:#0f172a;padding:0.35rem;border-radius:4px;text-align:center;">
                                        <div style="font-size:0.9rem;font-weight:600;">${bs.bps || 0}</div>
                                        <div style="font-size:0.55rem;color:#64748b;">BPS</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.35rem;border-radius:4px;text-align:center;">
                                        <div style="font-size:0.9rem;font-weight:600;color:#f59e0b;">${bs.yellow_cards || 0}</div>
                                        <div style="font-size:0.55rem;color:#64748b;">YC</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.35rem;border-radius:4px;text-align:center;">
                                        <div style="font-size:0.9rem;font-weight:600;color:#f43f5e;">${bs.red_cards || 0}</div>
                                        <div style="font-size:0.55rem;color:#64748b;">RC</div>
                                    </div>
                                    <div style="background:#0f172a;padding:0.35rem;border-radius:4px;text-align:center;">
                                        <div style="font-size:0.9rem;font-weight:600;">${bs.saves || 0}</div>
                                        <div style="font-size:0.55rem;color:#64748b;">Saves</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    ${bs.news ? '<div style="background:rgba(245,158,11,0.1);border:1px solid #f59e0b;padding:0.75rem;border-radius:8px;margin-bottom:1rem;"><span style="color:#f59e0b;">⚠️ News:</span> ' + bs.news + '</div>' : ''}
                    
                    <!-- Gameweek History -->
                    <div style="background:#1e293b;border-radius:12px;padding:1.25rem;">
                        <h4 style="color:#22d3ee;margin:0 0 1rem 0;font-size:1rem;">📊 Gameweek History</h4>
                        ${historyHtml || '<div style="color:#64748b;text-align:center;padding:2rem;">No gameweek history available</div>'}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }
        
        async function initLeagueImport() {
            generateBookmarklet();
            setupDropZone();
            
            // Load saved football-data.org API key
            loadFootballDataApiKey();
            
            // If data is ALREADY loaded in globals, just re-render (tab switching case)
            if (importedLeagueData?.league && importedBootstrap?.elements?.length > 0) {
                console.log('[Init] Data already in globals, re-rendering...');
                renderLeagueAnalysis();
                return;
            }
            
            // Initialize DataService (cache → DB → sync)
            if (typeof DataService !== 'undefined') {
                const dbStatus = await DataService.init();
                console.log('[Init] DataService status:', dbStatus);
                
                // If DB has data, load it and render
                if (dbStatus.hasData) {
                    showDbDataStatus(dbStatus);
                    
                    // Load data from DB into global variables
                    const loaded = await loadDataFromDb();
                    if (loaded && importedLeagueData?.league) {
                        console.log('[Init] Auto-rendering from DB data');
                        
                        // Rebuild ownership map from loaded data
                        rebuildOwnershipMap();
                        
                        renderLeagueAnalysis();
                        return; // Skip localStorage loading since we have DB data
                    }
                }
            }
            
            // Check for server data files first
            checkServerDataFiles();
            
            // Try to load saved data from localStorage
            const savedData = loadSavedData();
            if (savedData) {
                importedLeagueData = savedData.league;
                importedElementStatus = savedData.elements;
                importedBootstrap = savedData.bootstrap;
                importedPlayerDetails = savedData.playerDetails;
                
                // Load PL standings and fixtures
                if (savedData.plStandings && savedData.plStandings.length > 0) {
                    window.importedPLStandings = savedData.plStandings;
                    console.log('[Init] Loaded saved PL standings:', savedData.plStandings.length, 'teams');
                }
                if (savedData.plFixtures && savedData.plFixtures.length > 0) {
                    window.importedPLFixtures = savedData.plFixtures;
                    console.log('[Init] Loaded saved PL fixtures:', savedData.plFixtures.length, 'fixtures');
                }
                
                if (importedBootstrap) {
                    buildFplTeamIdMap();
                    buildElementMap();
                }
                
                // Apply transactions to update squads with trades/waivers
                if (importedLeagueData?.squads && importedLeagueData?.transactions) {
                    applyTransactionsToSquads();
                }
                
                // Show saved data status
                const savedAt = savedData.savedAt ? new Date(savedData.savedAt) : null;
                const statusDiv = document.getElementById('savedDataStatus');
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                        <div>
                            <span style="color: var(--accent-emerald); font-weight: 600;">✅ Saved Data Loaded</span>
                            <span style="color: var(--text-muted); font-size: 0.85rem; margin-left: 0.5rem;">
                                Last updated: ${savedAt ? savedAt.toLocaleString() : 'Unknown'}
                            </span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="syncUpdates()" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet)); font-size: 0.85rem; font-weight: 600;">
                                🔄 Sync Updates
                            </button>
                            <button onclick="tryAutoImportFromClipboard()" style="padding: 0.5rem 1rem; background: var(--accent-violet); font-size: 0.85rem;">
                                📋 Import from Clipboard
                            </button>
                            <button onclick="renderLeagueAnalysis()" style="padding: 0.5rem 1rem; background: var(--accent-emerald); font-size: 0.85rem;">
                                📊 Show Analysis
                            </button>
                            <button onclick="clearSavedData()" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); font-size: 0.85rem;">
                                🗑️ Clear
                            </button>
                        </div>
                    </div>
                `;
                
                // Auto-render if we have league data
                if (importedLeagueData && importedLeagueData.league) {
                    renderLeagueAnalysis();
                }
            } else {
                // No saved data - try auto-loading from server
                autoLoadFromServerIfAvailable();
            }
            
            // Listen for tab focus to try auto-import from clipboard
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') {
                    tryAutoImportFromClipboard(true); // silent mode
                }
            });
        }
        
        // Show database data status
        function showDbDataStatus(dbStatus) {
            const statusDiv = document.getElementById('savedDataStatus');
            statusDiv.style.display = 'block';
            
            const tables = dbStatus.tables || {};
            statusDiv.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                    <div>
                        <span style="color: var(--accent-cyan); font-weight: 600;">🗄️ Database Ready</span>
                        <span style="color: var(--text-muted); font-size: 0.85rem; margin-left: 0.5rem;">
                            ${tables.pl_players || 0} players • ${tables.fpl_squads || 0} squad slots • ${tables.player_gameweeks || 0} GW records
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="syncUpdates()" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet)); font-size: 0.85rem; font-weight: 600;">
                            🔄 Sync Updates
                        </button>
                        <button onclick="renderLeagueAnalysis()" style="padding: 0.5rem 1rem; background: var(--accent-emerald); font-size: 0.85rem;">
                            📊 Show Analysis
                        </button>
                        <button onclick="showDebugPanel()" style="padding: 0.5rem 1rem; background: var(--accent-amber); font-size: 0.85rem;">
                            🔍 Debug
                        </button>
                        <button onclick="DataService.clearCache(); showNotification('Cache cleared', 'info');" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); font-size: 0.85rem;">
                            🔃 Clear Cache
                        </button>
                    </div>
                </div>
            `;
        }
        
        // Debug panel to show loaded data state
        function showDebugPanel() {
            const debugData = {
                importedLeagueData: {
                    hasLeague: !!importedLeagueData?.league,
                    leagueName: importedLeagueData?.league?.name || 'N/A',
                    leagueEntries: importedLeagueData?.league_entries?.length || 0,
                    squadsCount: Object.keys(importedLeagueData?.squads || {}).length,
                    matchesCount: Array.isArray(importedLeagueData?.matches) ? importedLeagueData.matches.length : 0,
                    transactionsCount: importedLeagueData?.transactions?.transactions?.length || 0,
                    sampleSquadKeys: Object.keys(importedLeagueData?.squads || {}).slice(0, 3),
                    sampleSquad: null
                },
                importedBootstrap: {
                    elementsCount: importedBootstrap?.elements?.length || 0,
                    teamsCount: importedBootstrap?.teams?.length || 0,
                    fixturesGWs: Object.keys(importedBootstrap?.fixtures || {}),
                    samplePlayer: importedBootstrap?.elements?.[0] ? {
                        id: importedBootstrap.elements[0].id,
                        web_name: importedBootstrap.elements[0].web_name,
                        element_type: importedBootstrap.elements[0].element_type,
                        team: importedBootstrap.elements[0].team
                    } : null
                },
                importedPlayerDetails: {
                    playerCount: Object.keys(importedPlayerDetails || {}).length,
                    samplePlayerIds: Object.keys(importedPlayerDetails || {}).slice(0, 5),
                    sampleHistory: null
                },
                maps: {
                    elementMapSize: Object.keys(elementMap || {}).length,
                    fplTeamIdMapSize: Object.keys(fplTeamIdMap || {}).length
                }
            };
            
            // Get sample squad
            const firstSquadKey = Object.keys(importedLeagueData?.squads || {})[0];
            if (firstSquadKey && importedLeagueData.squads[firstSquadKey]) {
                debugData.importedLeagueData.sampleSquad = {
                    key: firstSquadKey,
                    picks: importedLeagueData.squads[firstSquadKey].picks?.slice(0, 2) || 'NO PICKS'
                };
            }
            
            // Get sample player history
            const firstDetailKey = Object.keys(importedPlayerDetails || {})[0];
            if (firstDetailKey && importedPlayerDetails[firstDetailKey]) {
                debugData.importedPlayerDetails.sampleHistory = {
                    playerId: firstDetailKey,
                    historyLength: importedPlayerDetails[firstDetailKey].history?.length || 0,
                    firstGame: importedPlayerDetails[firstDetailKey].history?.[0] || 'NO HISTORY'
                };
            }
            
            console.log('[DEBUG] Full data state:', debugData);
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'debugModal';
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.95);z-index:99999;overflow-y:auto;padding:2rem;';
            modal.innerHTML = `
                <div style="max-width:900px;margin:0 auto;background:#0f172a;border-radius:16px;padding:2rem;border:2px solid var(--accent-cyan);font-family:monospace;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                        <h2 style="color:var(--accent-cyan);margin:0;">🔍 Data Debug Panel</h2>
                        <button onclick="document.getElementById('debugModal').remove()" style="background:#334155;border:none;padding:0.5rem 1rem;border-radius:8px;cursor:pointer;color:#fff;">✕ Close</button>
                    </div>
                    
                    <div style="display:grid;gap:1rem;">
                        <div style="background:#1e293b;padding:1rem;border-radius:8px;">
                            <h3 style="color:#f59e0b;margin:0 0 0.5rem;">importedLeagueData</h3>
                            <div style="font-size:0.85rem;color:#94a3b8;">
                                <div>League: <span style="color:${debugData.importedLeagueData.hasLeague ? '#10b981' : '#ef4444'}">${debugData.importedLeagueData.leagueName}</span></div>
                                <div>Entries: <span style="color:#22d3ee">${debugData.importedLeagueData.leagueEntries}</span></div>
                                <div>Squads: <span style="color:#22d3ee">${debugData.importedLeagueData.squadsCount}</span> (keys: ${debugData.importedLeagueData.sampleSquadKeys.join(', ') || 'none'})</div>
                                <div>Matches: <span style="color:#22d3ee">${debugData.importedLeagueData.matchesCount}</span></div>
                                <div>Transactions: <span style="color:#22d3ee">${debugData.importedLeagueData.transactionsCount}</span></div>
                                <div style="margin-top:0.5rem;padding:0.5rem;background:#111827;border-radius:4px;overflow-x:auto;">Sample Squad: <pre style="margin:0;white-space:pre-wrap;">${JSON.stringify(debugData.importedLeagueData.sampleSquad, null, 2)}</pre></div>
                            </div>
                        </div>
                        
                        <div style="background:#1e293b;padding:1rem;border-radius:8px;">
                            <h3 style="color:#8b5cf6;margin:0 0 0.5rem;">importedBootstrap</h3>
                            <div style="font-size:0.85rem;color:#94a3b8;">
                                <div>Players: <span style="color:#22d3ee">${debugData.importedBootstrap.elementsCount}</span></div>
                                <div>Teams: <span style="color:#22d3ee">${debugData.importedBootstrap.teamsCount}</span></div>
                                <div>Fixtures GWs: <span style="color:#22d3ee">${debugData.importedBootstrap.fixturesGWs.join(', ') || 'none'}</span></div>
                                <div style="margin-top:0.5rem;padding:0.5rem;background:#111827;border-radius:4px;">Sample Player: <pre style="margin:0;white-space:pre-wrap;">${JSON.stringify(debugData.importedBootstrap.samplePlayer, null, 2)}</pre></div>
                            </div>
                        </div>
                        
                        <div style="background:#1e293b;padding:1rem;border-radius:8px;">
                            <h3 style="color:#10b981;margin:0 0 0.5rem;">importedPlayerDetails</h3>
                            <div style="font-size:0.85rem;color:#94a3b8;">
                                <div>Players with history: <span style="color:#22d3ee">${debugData.importedPlayerDetails.playerCount}</span></div>
                                <div>Sample IDs: <span style="color:#22d3ee">${debugData.importedPlayerDetails.samplePlayerIds.join(', ') || 'none'}</span></div>
                                <div style="margin-top:0.5rem;padding:0.5rem;background:#111827;border-radius:4px;overflow-x:auto;">Sample History: <pre style="margin:0;white-space:pre-wrap;">${JSON.stringify(debugData.importedPlayerDetails.sampleHistory, null, 2)}</pre></div>
                            </div>
                        </div>
                        
                        <div style="background:#1e293b;padding:1rem;border-radius:8px;">
                            <h3 style="color:#f43f5e;margin:0 0 0.5rem;">Maps & Caches</h3>
                            <div style="font-size:0.85rem;color:#94a3b8;">
                                <div>elementMap size: <span style="color:#22d3ee">${debugData.maps.elementMapSize}</span></div>
                                <div>fplTeamIdMap size: <span style="color:#22d3ee">${debugData.maps.fplTeamIdMapSize}</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top:1rem;text-align:center;">
                        <button onclick="console.log('Full debug:', {importedLeagueData, importedBootstrap, importedPlayerDetails, elementMap, fplTeamIdMap})" style="padding:0.5rem 1rem;background:#334155;border:1px solid #475569;border-radius:8px;cursor:pointer;color:#fff;margin-right:0.5rem;">
                            📋 Log Full Data to Console
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
        }
        
        // Load data from database into global variables for rendering
        async function loadDataFromDb() {
            console.log('[Init] Loading data from database...');
            
            try {
                // Load league info first
                let league = null;
                try {
                    const leagueRes = await fetch('/api/db/league');
                    if (leagueRes.ok) {
                        league = await leagueRes.json();
                        console.log('[Init] Loaded league:', league?.name);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load league:', e);
                }
                
                // Load entries
                let entries = [];
                try {
                    const entriesRes = await fetch('/api/db/entries');
                    if (entriesRes.ok) {
                        entries = await entriesRes.json();
                        console.log('[Init] Loaded entries:', entries.length);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load entries:', e);
                }
                
                // Load squads
                let transformedSquads = {};
                try {
                    const squadsRes = await fetch('/api/db/squads');
                    if (squadsRes.ok) {
                        const squadsData = await squadsRes.json();
                        for (const [entryId, picks] of Object.entries(squadsData.squads || {})) {
                            transformedSquads[entryId] = {
                                picks: picks.map(p => ({
                                    element: p.player_id,
                                    position: p.squad_position,
                                    is_captain: p.is_captain,
                                    is_vice_captain: p.is_vice_captain
                                }))
                            };
                        }
                        console.log('[Init] Loaded squads:', Object.keys(transformedSquads).length);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load squads:', e);
                }
                
                // Load matches
                let matches = [];
                try {
                    const matchesRes = await fetch('/api/db/matches');
                    if (matchesRes.ok) {
                        matches = await matchesRes.json();
                        console.log('[Init] Loaded matches:', matches.length);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load matches:', e);
                }
                
                // Load transactions
                let transactions = [];
                try {
                    const transRes = await fetch('/api/db/transactions');
                    if (transRes.ok) {
                        transactions = await transRes.json();
                        console.log('[Init] Loaded transactions:', transactions.length);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load transactions:', e);
                }
                
                // Calculate standings from matches
                const standingsMap = {};
                matches.forEach(m => {
                    if (!m.finished) return;
                    
                    // Initialize entries if needed
                    [m.league_entry_1, m.league_entry_2].forEach(entryId => {
                        if (!standingsMap[entryId]) {
                            standingsMap[entryId] = {
                                league_entry: entryId,
                                matches_played: 0, matches_won: 0, matches_lost: 0, matches_drawn: 0,
                                points_for: 0, points_against: 0, total: 0
                            };
                        }
                    });
                    
                    const s1 = standingsMap[m.league_entry_1];
                    const s2 = standingsMap[m.league_entry_2];
                    const p1 = m.entry_1_points || 0;
                    const p2 = m.entry_2_points || 0;
                    
                    s1.matches_played++;
                    s2.matches_played++;
                    s1.points_for += p1;
                    s1.points_against += p2;
                    s2.points_for += p2;
                    s2.points_against += p1;
                    
                    if (p1 > p2) {
                        s1.matches_won++;
                        s1.total += 3;
                        s2.matches_lost++;
                    } else if (p2 > p1) {
                        s2.matches_won++;
                        s2.total += 3;
                        s1.matches_lost++;
                    } else {
                        s1.matches_drawn++;
                        s2.matches_drawn++;
                        s1.total += 1;
                        s2.total += 1;
                    }
                });
                
                // Convert to array and sort by total points
                const standings = Object.values(standingsMap).sort((a, b) => b.total - a.total || (b.points_for - b.points_against) - (a.points_for - a.points_against));
                standings.forEach((s, i) => s.rank = i + 1);
                console.log('[Init] Calculated standings from', matches.filter(m => m.finished).length, 'finished matches');
                
                // Construct importedLeagueData if we have league info
                // Note: league_entries must be at TOP level for rendering functions
                if (league && league.id) {
                    importedLeagueData = {
                        league: league,
                        league_entries: entries,  // TOP level, not inside league!
                        squads: transformedSquads,
                        matches: matches,  // Direct array, not wrapped!
                        transactions: { transactions: transactions },  // Wrapped for compatibility
                        standings: standings  // Calculated from matches!
                    };
                    console.log('[Init] Built importedLeagueData with', entries.length, 'teams');
                }
                
                // Load bootstrap (players + teams)
                let players = [];
                let teams = [];
                try {
                    const playersRes = await fetch('/api/db/players?limit=1000');
                    if (playersRes.ok) {
                        players = await playersRes.json();
                        console.log('[Init] Loaded players:', players.length);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load players:', e);
                }
                
                try {
                    const teamsRes = await fetch('/api/db/teams');
                    if (teamsRes.ok) {
                        teams = await teamsRes.json();
                        console.log('[Init] Loaded teams:', teams.length);
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load teams:', e);
                }
                
                // Load fixtures
                let fixtures = {};
                try {
                    const fixturesRes = await fetch('/api/db/fixtures');
                    if (fixturesRes.ok) {
                        const fixturesList = await fixturesRes.json();
                        // Group fixtures by gameweek (format expected by frontend)
                        for (const f of fixturesList) {
                            const gw = String(f.gameweek);
                            if (!fixtures[gw]) fixtures[gw] = [];
                            fixtures[gw].push({
                                id: f.id,
                                team_h: f.home_team_id,
                                team_a: f.away_team_id,
                                team_h_score: f.home_score,
                                team_a_score: f.away_score,
                                team_h_difficulty: f.home_fdr,
                                team_a_difficulty: f.away_fdr,
                                finished: f.finished,
                                kickoff_time: f.kickoff_time,
                                event: f.gameweek
                            });
                        }
                        console.log('[Init] Loaded fixtures for GWs:', Object.keys(fixtures).sort().join(', '));
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load fixtures:', e);
                }
                
                if (players.length > 0) {
                    // Transform players to have element_type from position
                    const transformedPlayers = players.map(p => ({
                        ...p,
                        element_type: p.position,
                        team: p.team_id
                    }));
                    
                    importedBootstrap = {
                        elements: transformedPlayers,
                        teams: teams.map(t => ({
                            ...t,
                            short_name: t.short_name || t.name?.substring(0, 3).toUpperCase()
                        })),
                        fixtures: fixtures  // Add fixtures!
                    };
                    
                    console.log('[Init] Built importedBootstrap with', players.length, 'players,', teams.length, 'teams,', Object.keys(fixtures).length, 'GWs of fixtures');
                    
                    // Build maps
                    buildFplTeamIdMap();
                    buildElementMap();
                }
                
                // Load element status (optional, don't fail if it errors)
                try {
                    const statusRes = await fetch('/api/db/element-status');
                    if (statusRes.ok) {
                        const statusData = await statusRes.json();
                        if (!statusData.error) {
                            importedElementStatus = statusData;
                            console.log('[Init] Loaded element status');
                        }
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load element status:', e);
                }
                
                // Load player details (gameweek history) - CRITICAL for predictions!
                try {
                    const detailsRes = await fetch('/api/db/player-details');
                    if (detailsRes.ok) {
                        const playerDetails = await detailsRes.json();
                        if (!playerDetails.error) {
                            importedPlayerDetails = playerDetails;
                            console.log('[Init] Loaded player details for', Object.keys(playerDetails).length, 'players');
                        }
                    }
                } catch (e) {
                    console.warn('[Init] Failed to load player details:', e);
                }
                
                // Debug summary
                console.log('[Init] ========== DB LOAD SUMMARY ==========');
                console.log('[Init] league:', league?.id ? `✅ ${league.name}` : '❌ Missing');
                console.log('[Init] entries:', entries.length > 0 ? `✅ ${entries.length}` : '❌ Empty');
                console.log('[Init] squads:', Object.keys(transformedSquads).length > 0 ? `✅ ${Object.keys(transformedSquads).length} teams` : '❌ Empty');
                console.log('[Init] matches:', matches.length > 0 ? `✅ ${matches.length}` : '❌ Empty');
                console.log('[Init] transactions:', transactions.length > 0 ? `✅ ${transactions.length}` : '❌ Empty');
                console.log('[Init] players:', players.length > 0 ? `✅ ${players.length}` : '❌ Empty');
                console.log('[Init] teams:', teams.length > 0 ? `✅ ${teams.length}` : '❌ Empty');
                console.log('[Init] fixtures:', Object.keys(fixtures).length > 0 ? `✅ GWs: ${Object.keys(fixtures).join(',')}` : '❌ Empty');
                console.log('[Init] playerDetails:', Object.keys(importedPlayerDetails || {}).length > 0 ? `✅ ${Object.keys(importedPlayerDetails).length} players` : '❌ Empty');
                console.log('[Init] =======================================');
                
                const success = league && league.id && players.length > 0;
                console.log('[Init] loadDataFromDb returning:', success);
                
                // Rebuild ownership map after successful load
                if (success) {
                    rebuildOwnershipMap();
                }
                
                return success;
            } catch (e) {
                console.error('[Init] Failed to load from DB:', e);
                return false;
            }
        }
        
        // Sync updates from newest JSON file
        async function syncUpdates() {
            showNotification('🔄 Syncing updates from newest file...', 'info');
            
            if (typeof DataService === 'undefined') {
                showNotification('❌ DataService not available', 'error');
                return;
            }
            
            const result = await DataService.syncFromFile();
            
            if (result.success) {
                const imported = result.imported;
                showNotification(
                    `✅ Synced from ${result.filename}: ${imported.players} players, ${imported.squads} squad slots, ${imported.gameweeks} GW records`,
                    'success'
                );
                
                // Refresh the DB status display
                const dbStatus = await DataService.checkDbStatus();
                showDbDataStatus(dbStatus);
                
                // Rebuild ownership map after sync
                rebuildOwnershipMap();
                
                // Render analysis if we have league data
                if (importedLeagueData?.league) {
                    renderLeagueAnalysis();
                }
            } else {
                showNotification(`❌ Sync failed: ${result.error}`, 'error');
            }
        }
        
        // Check for available server data files
        async function checkServerDataFiles() {
            try {
                const response = await fetch('/api/data-files');
                if (!response.ok) return;
                
                const result = await response.json();
                if (result.files && result.files.length > 0) {
                    const statusDiv = document.getElementById('serverDataStatus');
                    const infoDiv = document.getElementById('serverFileInfo');
                    
                    const newest = result.newest;
                    infoDiv.innerHTML = `
                        <strong>${newest.filename}</strong> (${newest.size_mb} MB)
                        ${result.count > 1 ? `<span style="color: var(--text-muted);"> • ${result.count} files available</span>` : ''}
                    `;
                    statusDiv.style.display = 'block';
                    
                    // Store for later use
                    window.serverDataFiles = result.files;
                }
            } catch (e) {
                console.log('[Server] No server data files available:', e.message);
            }
        }
        
        // Refresh server files list
        function refreshServerFiles() {
            checkServerDataFiles();
            showNotification('🔄 Refreshed server file list', 'info');
        }
        
        // Auto-load from server if no saved data and files available
        async function autoLoadFromServerIfAvailable() {
            try {
                const response = await fetch('/api/data-files');
                if (!response.ok) return;
                
                const result = await response.json();
                if (result.newest) {
                    console.log('[AutoLoad] Found server data file:', result.newest.filename);
                    // Auto-load the newest file
                    loadFromServer(true); // silent mode
                }
            } catch (e) {
                console.log('[AutoLoad] Server not available:', e.message);
            }
        }
        
        // Load data from server
        async function loadFromServer(silent = false) {
            try {
                if (!silent) {
                    showNotification('🔄 Loading data from server...', 'info');
                }
                
                const response = await fetch('/api/auto-load', { method: 'POST' });
                const result = await response.json();
                
                if (!result.success) {
                    if (!silent) {
                        showNotification(`❌ ${result.error}: ${result.message}`, 'error');
                    }
                    return;
                }
                
                // Process the data (same as processLeagueData)
                const data = result.data;
                
                // Set league data
                if (data.league) {
                    importedLeagueData = data.league;
                }
                
                // Add squads to league data (they're at top level in JSON)
                if (data.squads) {
                    importedLeagueData.squads = data.squads;
                }
                
                // Add transactions to league data
                if (data.transactions) {
                    importedLeagueData.transactions = data.transactions;
                }
                
                // Add current event
                if (data.currentEvent) {
                    importedLeagueData.currentEvent = data.currentEvent;
                }
                
                // Store fetch time
                if (data.fetchedAt) {
                    importedLeagueData.fetchedAt = data.fetchedAt;
                }
                
                // Set other global data
                if (data.elements) importedElementStatus = data.elements;
                if (data.bootstrap) importedBootstrap = data.bootstrap;
                if (data.playerDetails) importedPlayerDetails = data.playerDetails;
                
                // Load PL standings and fixtures if present
                if (data.plStandings && data.plStandings.length > 0) {
                    window.importedPLStandings = data.plStandings;
                    console.log('[Server] Loaded PL standings:', data.plStandings.length, 'teams');
                }
                if (data.plFixtures && data.plFixtures.length > 0) {
                    window.importedPLFixtures = data.plFixtures;
                    console.log('[Server] Loaded PL fixtures:', data.plFixtures.length, 'fixtures');
                }
                
                // Build maps from bootstrap data
                if (importedBootstrap) {
                    buildFplTeamIdMap();
                    buildElementMap();
                }
                
                // Apply transactions to update squads with trades/waivers
                if (importedLeagueData?.squads && importedLeagueData?.transactions) {
                    applyTransactionsToSquads();
                }
                
                console.log('[Server] Data loaded - Squads:', Object.keys(importedLeagueData?.squads || {}).length);
                
                // Import into DuckDB database for proper ownership tracking
                if (typeof FPLDB !== 'undefined') {
                    try {
                        console.log('[Server] Importing data into database...');
                        const dbResult = await FPLDB.importData(data);
                        console.log('[Server] Database import result:', dbResult);
                    } catch (dbError) {
                        console.warn('[Server] Database import failed:', dbError);
                    }
                }
                
                // Save to localStorage for persistence
                saveLeagueData();
                
                // Show success and render
                const msg = `✅ Loaded ${result.filename} from server`;
                if (!silent) {
                    showNotification(msg, 'success');
                }
                console.log('[Server]', msg);
                
                // Update saved status
                const statusDiv = document.getElementById('savedDataStatus');
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                        <div>
                            <span style="color: var(--accent-emerald); font-weight: 600;">✅ Data Loaded from Server</span>
                            <span style="color: var(--text-muted); font-size: 0.85rem; margin-left: 0.5rem;">
                                File: ${result.filename}
                            </span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="loadFromServer()" style="padding: 0.5rem 1rem; background: var(--accent-violet); font-size: 0.85rem;">
                                🔄 Reload from Server
                            </button>
                            <button onclick="renderLeagueAnalysis()" style="padding: 0.5rem 1rem; background: var(--accent-emerald); font-size: 0.85rem;">
                                📊 Show Analysis
                            </button>
                            <button onclick="clearSavedData()" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); font-size: 0.85rem;">
                                🗑️ Clear
                            </button>
                        </div>
                    </div>
                `;
                
                // Render analysis
                if (importedLeagueData && importedLeagueData.league) {
                    renderLeagueAnalysis();
                }
                
            } catch (e) {
                console.error('[Server] Load error:', e);
                if (!silent) {
                    showNotification(`❌ Failed to load from server: ${e.message}`, 'error');
                }
            }
        }
        
        // Try to import FPL data from clipboard
        async function tryAutoImportFromClipboard(silent = false) {
            try {
                const clipText = await navigator.clipboard.readText();
                if (clipText && clipText.includes('"league"') && clipText.includes('"bootstrap"') && clipText.includes('"playerDetails"')) {
                    const parsed = JSON.parse(clipText);
                    if (parsed.league && parsed.bootstrap && parsed.playerDetails) {
                        // Check if this is newer data than what we have
                        const newFetchedAt = parsed.fetchedAt ? new Date(parsed.fetchedAt) : new Date();
                        const currentFetchedAt = importedLeagueData?.fetchedAt ? new Date(importedLeagueData.fetchedAt) : null;
                        
                        if (!currentFetchedAt || newFetchedAt > currentFetchedAt) {
                            // Import the new data
                            document.getElementById('leagueDataInput').value = clipText;
                            processLeagueData();
                            
                            if (!silent) {
                                // Show success notification
                                showNotification('✅ New data imported from clipboard!', 'success');
                            } else {
                                // Show subtle notification for auto-import
                                showNotification('🔄 Data auto-updated from clipboard!', 'info');
                            }
                        } else if (!silent) {
                            showNotification('ℹ️ Clipboard data is same or older than current data', 'info');
                        }
                    }
                } else if (!silent) {
                    showNotification('❌ No valid FPL data found in clipboard', 'error');
                }
            } catch (e) {
                if (!silent) {
                    showNotification('⚠️ Cannot read clipboard. Please paste manually or drag the JSON file.', 'warning');
                }
            }
        }
        
        // Show notification toast
        function showNotification(message, type = 'info') {
            const colors = {
                success: 'var(--accent-emerald)',
                error: 'var(--accent-rose)',
                warning: 'var(--accent-amber)',
                info: 'var(--accent-cyan)'
            };
            
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 1rem 1.5rem;
                background: var(--bg-secondary);
                border: 2px solid ${colors[type]};
                border-radius: 12px;
                color: var(--text-primary);
                font-weight: 500;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function generateBookmarklet() {
            const leagueId = document.getElementById('leagueIdInput').value || '201560';
            
            // Create the bookmarklet code
            const bookmarkletCode = `
(function(){
    // Check if we're on the correct domain
    if (!window.location.hostname.includes('premierleague.com')) {
        alert('⚠️ Wrong website!\\n\\nThis bookmarklet must be run on draft.premierleague.com\\n\\n1. Go to draft.premierleague.com\\n2. Log in to your account\\n3. Then click this bookmarklet again');
        return;
    }
    
    const leagueId = ${leagueId};
    const results = {};
    
    async function fetchAll() {
        // Show loading
        const overlay = document.createElement('div');
        overlay.id = 'fpl-fetch-overlay';
        overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:99999;display:flex;align-items:center;justify-content:center;flex-direction:column;font-family:sans-serif;color:white;';
        overlay.innerHTML = '<div style="font-size:24px;margin-bottom:20px;">📥 Fetching FPL Data...</div><div id="fpl-status" style="font-size:16px;">Starting...</div>';
        document.body.appendChild(overlay);
        
        const status = document.getElementById('fpl-status');
        
        try {
            // Fetch league details
            status.textContent = 'Fetching league details...';
            const leagueRes = await fetch('https://draft.premierleague.com/api/league/' + leagueId + '/details');
            if (!leagueRes.ok) throw new Error('Failed to fetch league. Are you logged in?');
            results.league = await leagueRes.json();
            
            // Fetch element status
            status.textContent = 'Fetching player ownership...';
            const elemRes = await fetch('https://draft.premierleague.com/api/league/' + leagueId + '/element-status');
            results.elements = await elemRes.json();
            
            // Fetch bootstrap (player data)
            status.textContent = 'Fetching player database...';
            const bootRes = await fetch('https://draft.premierleague.com/api/bootstrap-static');
            results.bootstrap = await bootRes.json();
            
            // Determine the CURRENT gameweek (not start event)
            status.textContent = 'Determining current gameweek...';
            let currentEvent = results.league.league?.start_event || 21;
            
            // Get actual current GW from bootstrap events (with full error handling)
            try {
                if (results.bootstrap && results.bootstrap.events) {
                    const evts = results.bootstrap.events;
                    if (evts && typeof evts.find === 'function') {
                        const curr = evts.find(function(e) { return e.is_current; });
                        if (curr && curr.id) {
                            currentEvent = curr.id;
                        } else {
                            const nxt = evts.find(function(e) { return !e.finished; });
                            if (nxt && nxt.id) currentEvent = nxt.id;
                        }
                    }
                }
            } catch(evtErr) {
                console.log('Could not determine current GW, using default:', currentEvent);
            }
            results.currentEvent = currentEvent;
            
            // Fetch transactions/trades history
            status.textContent = 'Fetching trades and transactions...';
            try {
                const transRes = await fetch('https://draft.premierleague.com/api/draft/league/' + leagueId + '/transactions');
                if (transRes.ok) {
                    results.transactions = await transRes.json();
                }
            } catch(e) {
                console.log('Could not fetch transactions');
            }
            
            // Fetch each team's squad for the CURRENT event (after trades)
            status.textContent = 'Fetching team squads for GW' + currentEvent + '...';
            results.squads = {};
            const entries = results.league.league_entries || [];
            
            // Collect all owned player IDs
            const ownedPlayerIds = new Set();
            
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                status.textContent = 'Fetching squad ' + (i+1) + '/' + entries.length + '...';
                try {
                    // Fetch current event squad
                    const squadRes = await fetch('https://draft.premierleague.com/api/entry/' + entry.entry_id + '/event/' + currentEvent);
                    const squadData = await squadRes.json();
                    results.squads[entry.entry_id] = squadData;
                    
                    // Collect player IDs
                    if (squadData.picks) {
                        squadData.picks.forEach(p => ownedPlayerIds.add(p.element));
                    }
                } catch(e) {
                    console.log('Failed to fetch squad for ' + entry.entry_name);
                }
            }
            
            // Find top 100 free agents by total points
            status.textContent = 'Finding top free agents...';
            const freeAgentIds = [];
            if (results.elements && results.elements.element_status && results.bootstrap && results.bootstrap.elements) {
                // Get free agent element IDs
                const freeAgentElementIds = results.elements.element_status
                    .filter(es => es.owner === null && es.status === 'a')
                    .map(es => es.element);
                
                // Sort by total points from bootstrap
                const freeAgentsWithPoints = freeAgentElementIds
                    .map(id => {
                        const player = results.bootstrap.elements.find(e => e.id === id);
                        return { id, points: player ? player.total_points : 0 };
                    })
                    .sort((a, b) => b.points - a.points)
                    .slice(0, 100); // Increased from 50 to 100
                
                freeAgentsWithPoints.forEach(fa => freeAgentIds.push(fa.id));
            }
            
            // Also collect player IDs from transactions (traded/waivered players)
            const transactionPlayerIds = new Set();
            if (results.transactions && results.transactions.transactions) {
                results.transactions.transactions.forEach(function(trans) {
                    if (trans.element_in) transactionPlayerIds.add(trans.element_in);
                    if (trans.element_out) transactionPlayerIds.add(trans.element_out);
                });
            }
            
            // Combine: owned + top 50 free agents + transaction players (remove duplicates)
            const allPlayerIds = [...new Set([
                ...Array.from(ownedPlayerIds), 
                ...freeAgentIds,
                ...Array.from(transactionPlayerIds)
            ])];
            
            // Fetch detailed stats for all players
            status.textContent = 'Fetching player details (0/' + allPlayerIds.length + ')...';
            results.playerDetails = {};
            const playerIds = allPlayerIds;
            
            for (let i = 0; i < playerIds.length; i++) {
                const playerId = playerIds[i];
                if (i % 5 === 0) {
                    status.textContent = 'Fetching player details (' + (i+1) + '/' + playerIds.length + ')...';
                }
                try {
                    const detailRes = await fetch('https://draft.premierleague.com/api/element-summary/' + playerId);
                    const detailData = await detailRes.json();
                    results.playerDetails[playerId] = detailData;
                } catch(e) {
                    console.log('Failed to fetch details for player ' + playerId);
                }
                // Small delay to avoid rate limiting
                if (i % 10 === 9) await new Promise(r => setTimeout(r, 100));
            }
            
            // ========== CHECK DRAFT BOOTSTRAP FOR STANDINGS ==========
            status.textContent = 'Checking for PL standings...';
            
            // First, check if Draft API bootstrap already has standings (some versions do)
            if (results.bootstrap && results.bootstrap.teams) {
                const draftTeams = results.bootstrap.teams;
                const hasStandings = draftTeams.some(function(t) { 
                    return (t.win !== undefined && t.win > 0) || (t.points !== undefined && t.points > 0); 
                });
                
                if (hasStandings) {
                    console.log('Draft bootstrap has standings data!');
                    results.plStandings = draftTeams.map(function(t) {
                        return {
                            id: t.id,
                            name: t.name,
                            short_name: t.short_name,
                            position: t.position || 0,
                            played: t.played || 0,
                            win: t.win || 0,
                            draw: t.draw || 0,
                            loss: t.loss || 0,
                            goals_for: t.goals_for || 0,
                            goals_against: t.goals_against || 0,
                            goal_difference: (t.goals_for || 0) - (t.goals_against || 0),
                            points: t.points || 0,
                            strength_overall_home: t.strength_overall_home || 0,
                            strength_overall_away: t.strength_overall_away || 0,
                            strength_attack_home: t.strength_attack_home || 0,
                            strength_attack_away: t.strength_attack_away || 0,
                            strength_defence_home: t.strength_defence_home || 0,
                            strength_defence_away: t.strength_defence_away || 0
                        };
                    }).sort(function(a, b) {
                        if (b.points !== a.points) return b.points - a.points;
                        if (b.goal_difference !== a.goal_difference) return b.goal_difference - a.goal_difference;
                        return b.goals_for - a.goals_for;
                    });
                    results.plStandings.forEach(function(t, idx) { t.position = idx + 1; });
                }
            }
            
            // If no standings from Draft API, try fetching from regular FPL API
            if (!results.plStandings || results.plStandings.length === 0) {
                status.textContent = 'Fetching real PL standings from FPL API...';
                try {
                    const fplBootRes = await fetch('https://fantasy.premierleague.com/api/bootstrap-static/');
                    if (fplBootRes.ok) {
                        const fplBootData = await fplBootRes.json();
                        
                        results.plStandings = (fplBootData.teams || []).map(function(t) {
                            return {
                                id: t.id,
                                name: t.name,
                                short_name: t.short_name,
                                position: t.position || 0,
                                played: t.played || 0,
                                win: t.win || 0,
                                draw: t.draw || 0,
                                loss: t.loss || 0,
                                goals_for: t.goals_for || 0,
                                goals_against: t.goals_against || 0,
                                goal_difference: (t.goals_for || 0) - (t.goals_against || 0),
                                points: t.points || 0,
                                strength_overall_home: t.strength_overall_home || 0,
                                strength_overall_away: t.strength_overall_away || 0,
                                strength_attack_home: t.strength_attack_home || 0,
                                strength_attack_away: t.strength_attack_away || 0,
                                strength_defence_home: t.strength_defence_home || 0,
                                strength_defence_away: t.strength_defence_away || 0
                            };
                        }).sort(function(a, b) {
                            if (b.points !== a.points) return b.points - a.points;
                            if (b.goal_difference !== a.goal_difference) return b.goal_difference - a.goal_difference;
                            return b.goals_for - a.goals_for;
                        });
                        
                        results.plStandings.forEach(function(t, idx) { t.position = idx + 1; });
                        console.log('Fetched real PL standings from FPL API');
                    }
                } catch(standingsErr) {
                    console.log('Could not fetch PL standings (CORS?):', standingsErr);
                    // Flag for manual fetch later
                    results.needsStandingsFetch = true;
                }
            }
            
            // Try to fetch fixtures (may also fail due to CORS)
            if (!results.plStandings || results.plStandings.length === 0) {
                status.textContent = 'PL standings fetch failed (CORS) - will fetch in analyzer...';
            }
            
            // Log what we got
            if (results.plStandings && results.plStandings.length > 0) {
                console.log('PL standings ready:', results.plStandings.slice(0, 5).map(function(t) { return t.position + '. ' + t.short_name + ' (' + t.points + 'pts)'; }));
            }
            
            // Add timestamp
            results.fetchedAt = new Date().toISOString();
            
            // Debug: count how many player details have history
            let playersWithHistory = 0;
            let playersWithoutHistory = 0;
            Object.keys(results.playerDetails).forEach(function(pid) {
                const pd = results.playerDetails[pid];
                if (pd && pd.history && pd.history.length > 0) {
                    playersWithHistory++;
                } else {
                    playersWithoutHistory++;
                }
            });
            
            // Prepare JSON
            status.textContent = 'Preparing data...';
            const jsonStr = JSON.stringify(results, null, 2);
            const ownedCount = ownedPlayerIds.size;
            const freeAgentCount = freeAgentIds.length;
            const transactionCount = transactionPlayerIds.size;
            
            // Try to copy to clipboard
            let copied = false;
            try {
                await navigator.clipboard.writeText(jsonStr);
                copied = true;
            } catch(clipErr) {
                console.log('Clipboard failed, showing manual copy option');
            }
            
            // Store data globally for manual copy
            window.fplExportData = jsonStr;
            
            // Create download link for JSON file
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const downloadUrl = URL.createObjectURL(blob);
            const fileName = 'fpl_league_data_' + new Date().toISOString().slice(0,10) + '.json';
            
            const standingsCount = results.plStandings ? results.plStandings.length : 0;
            const needsFetch = results.needsStandingsFetch || false;
            
            overlay.innerHTML = '<div style="font-size:28px;color:#10b981;margin-bottom:20px;">✅ Success!</div>' +
                '<div style="font-size:18px;margin-bottom:15px;font-weight:bold;">Data Ready!</div>' +
                '<div style="font-size:14px;color:#94a3b8;margin-bottom:5px;">League: ' + (results.league.league?.name || 'Unknown') + '</div>' +
                '<div style="font-size:14px;color:#94a3b8;margin-bottom:5px;">Squads for: <strong style="color:#22d3ee;">GW' + currentEvent + '</strong></div>' +
                '<div style="font-size:14px;color:#94a3b8;margin-bottom:5px;">' + entries.length + ' teams (' + ownedCount + ' owned players)</div>' +
                '<div style="font-size:14px;color:#94a3b8;margin-bottom:5px;">+ ' + freeAgentCount + ' free agents + ' + transactionCount + ' from transactions</div>' +
                '<div style="font-size:14px;color:#94a3b8;margin-bottom:5px;">' + Object.keys(results.playerDetails).length + ' players fetched (' + playersWithHistory + ' with history, ' + playersWithoutHistory + ' without)</div>' +
                (standingsCount > 0 ? '<div style="font-size:14px;color:#10b981;margin-bottom:5px;">📊 Real PL Standings: ' + standingsCount + ' teams (W/D/L/Pts)</div>' : 
                    (needsFetch ? '<div style="font-size:14px;color:#f59e0b;margin-bottom:5px;">⚠️ PL standings blocked by CORS - analyzer will fetch directly</div>' : 
                    '<div style="font-size:14px;color:#ef4444;margin-bottom:5px;">⚠️ Could not fetch PL standings</div>')) +
                (results.transactions ? '<div style="font-size:14px;color:#f59e0b;margin-bottom:15px;">📋 ' + (results.transactions.transactions?.length || 0) + ' transactions loaded (trades, waivers)</div>' : '') +
                '<div style="background:#1e293b;padding:15px;border-radius:10px;margin-bottom:20px;border:2px solid #22d3ee;">' +
                    '<div style="font-size:16px;color:#22d3ee;font-weight:bold;margin-bottom:8px;">🚀 Auto-Import Ready!</div>' +
                    '<div style="font-size:13px;color:#94a3b8;">Data copied to clipboard. Just <strong style="color:#10b981;">switch back to the Analyzer tab</strong> and it will auto-update!</div>' +
                '</div>' +
                '<div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-bottom:15px;">' +
                    '<button id="fplCopyBtn" style="padding:14px 28px;background:#8b5cf6;border:none;border-radius:8px;cursor:pointer;font-size:15px;font-weight:bold;">📋 Copy Again</button>' +
                    '<a id="fplDownloadBtn" href="' + downloadUrl + '" download="' + fileName + '" style="padding:14px 28px;background:#334155;border:none;border-radius:8px;cursor:pointer;font-size:15px;font-weight:bold;text-decoration:none;color:#fff;display:inline-block;">💾 Download Backup</a>' +
                '</div>' +
                '<button onclick="this.parentElement.remove()" style="padding:10px 20px;background:#334155;border:none;border-radius:8px;cursor:pointer;font-size:14px;">Close</button>';
            
            // Store for copy button
            window.fplExportData = jsonStr;
            
            document.getElementById('fplCopyBtn').onclick = async function() {
                try {
                    await navigator.clipboard.writeText(window.fplExportData);
                    this.textContent = '✅ Copied!';
                    this.style.background = '#10b981';
                } catch(e) {
                    alert('Copy failed. Please use the Download button instead.');
                }
            };
            
        } catch(e) {
            overlay.innerHTML = '<div style="font-size:24px;color:#f43f5e;margin-bottom:20px;">❌ Error</div><div style="font-size:14px;max-width:400px;text-align:center;margin-bottom:10px;">' + e.message + '</div><div style="font-size:12px;color:#94a3b8;max-width:400px;text-align:center;">Make sure you are logged into draft.premierleague.com and the league ID is correct.</div><button onclick="this.parentElement.remove()" style="margin-top:20px;padding:10px 20px;background:#22d3ee;border:none;border-radius:8px;cursor:pointer;">Close</button>';
        }
    }
    
    fetchAll();
})();
            `.trim();
            
            // Minify for bookmarklet
            const minified = 'javascript:' + encodeURIComponent(bookmarkletCode.replace(/\\s+/g, ' ').replace(/\\n/g, ''));
            
            document.getElementById('fplBookmarklet').href = minified;
        }
        
        function showImportSubTab(subtab) {
            // Hide all sections
            document.querySelectorAll('.import-data-section').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.import-subtab').forEach(el => el.classList.remove('active'));
            
            // Show selected
            const sectionMap = {
                'league': 'importLeague',
                'elements': 'importElements',
                'bootstrap': 'importBootstrap'
            };
            
            document.getElementById(sectionMap[subtab]).style.display = 'block';
            document.querySelector(`.import-subtab[data-subtab="${subtab}"]`).classList.add('active');
        }
        
        function clearImportData() {
            document.getElementById('leagueDataInput').value = '';
            document.getElementById('elementStatusInput').value = '';
            document.getElementById('bootstrapDataInput').value = '';
            importedLeagueData = null;
            importedElementStatus = null;
            importedBootstrap = null;
            document.getElementById('importStatus').style.display = 'none';
            document.getElementById('leagueAnalysisResults').style.display = 'none';
        }
        
        function processLeagueData() {
            const statusDiv = document.getElementById('importStatus');
            const statusContent = document.getElementById('importStatusContent');
            statusDiv.style.display = 'block';
            
            let statusHtml = '';
            let hasData = false;
            
            // Try to parse league data
            const leagueInput = document.getElementById('leagueDataInput').value.trim();
            if (leagueInput) {
                try {
                    const parsed = JSON.parse(leagueInput);
                    // Check if it's the combined format from bookmarklet
                    if (parsed.league && parsed.elements && parsed.bootstrap) {
                        importedLeagueData = parsed.league;
                        importedElementStatus = parsed.elements;
                        importedBootstrap = parsed.bootstrap;
                        buildFplTeamIdMap(); // Build team ID map from bootstrap
                        if (parsed.squads) {
                            importedLeagueData.squads = parsed.squads;
                        }
                        if (parsed.transactions) {
                            importedLeagueData.transactions = parsed.transactions;
                        }
                        if (parsed.currentEvent) {
                            importedLeagueData.currentEvent = parsed.currentEvent;
                        }
                        // Store when the data was fetched
                        if (parsed.fetchedAt) {
                            importedLeagueData.fetchedAt = parsed.fetchedAt;
                        }
                        // CRITICAL: Import player details (GW history) from bookmarklet data
                        if (parsed.playerDetails) {
                            importedPlayerDetails = parsed.playerDetails;
                        }
                        // Import REAL PL standings from bookmarklet's FPL API fetch
                        if (parsed.plStandings && parsed.plStandings.length > 0) {
                            window.importedPLStandings = parsed.plStandings;
                            console.log('[Import] Real PL standings imported:', parsed.plStandings.length, 'teams');
                        }
                        // Import PL fixtures/results
                        if (parsed.plFixtures && parsed.plFixtures.length > 0) {
                            window.importedPLFixtures = parsed.plFixtures;
                            console.log('[Import] PL fixtures imported:', parsed.plFixtures.length, 'fixtures');
                        }
                        const gwInfo = parsed.currentEvent ? ` (Squads for GW${parsed.currentEvent})` : '';
                        const playerDetailsCount = parsed.playerDetails ? Object.keys(parsed.playerDetails).length : 0;
                        const standingsInfo = parsed.plStandings && parsed.plStandings.length > 0 ? ' • ✅ Real PL standings' : ' • ⚠️ No PL standings';
                        const fixturesInfo = parsed.plFixtures ? ` • ${parsed.plFixtures.filter(f => f.finished).length} match results` : '';
                        statusHtml += '<div style="color: var(--accent-emerald);">✅ All data imported from bookmarklet' + gwInfo + ' (' + playerDetailsCount + ' players with GW history)' + standingsInfo + fixturesInfo + '</div>';
                        hasData = true;
                    } else if (parsed.league) {
                        importedLeagueData = parsed;
                        statusHtml += '<div style="color: var(--accent-emerald);">✅ League data: ' + (parsed.league.name || 'Unknown') + ' (' + (parsed.league_entries?.length || 0) + ' teams)</div>';
                        hasData = true;
                    } else {
                        statusHtml += '<div style="color: var(--accent-rose);">❌ League data format not recognized</div>';
                    }
                } catch (e) {
                    statusHtml += '<div style="color: var(--accent-rose);">❌ League data: Invalid JSON - ' + e.message + '</div>';
                }
            }
            
            // Try to parse element status
            const elemInput = document.getElementById('elementStatusInput').value.trim();
            if (elemInput && !importedElementStatus) {
                try {
                    const parsed = JSON.parse(elemInput);
                    if (parsed.element_status) {
                        importedElementStatus = parsed;
                        statusHtml += '<div style="color: var(--accent-emerald);">✅ Element status: ' + parsed.element_status.length + ' players tracked</div>';
                        hasData = true;
                    } else {
                        statusHtml += '<div style="color: var(--accent-rose);">❌ Element status format not recognized</div>';
                    }
                } catch (e) {
                    statusHtml += '<div style="color: var(--accent-rose);">❌ Element status: Invalid JSON</div>';
                }
            }
            
            // Try to parse bootstrap
            const bootInput = document.getElementById('bootstrapDataInput').value.trim();
            if (bootInput && !importedBootstrap) {
                try {
                    const parsed = JSON.parse(bootInput);
                    if (parsed.elements) {
                        importedBootstrap = parsed;
                        buildFplTeamIdMap(); // Build team ID map from bootstrap
                        buildElementMap();
                        statusHtml += '<div style="color: var(--accent-emerald);">✅ Bootstrap: ' + parsed.elements.length + ' players loaded</div>';
                        hasData = true;
                    } else {
                        statusHtml += '<div style="color: var(--accent-rose);">❌ Bootstrap format not recognized</div>';
                    }
                } catch (e) {
                    statusHtml += '<div style="color: var(--accent-rose);">❌ Bootstrap: Invalid JSON</div>';
                }
            }
            
            if (importedBootstrap) {
                buildElementMap();
            }
            
            // Handle player details from combined data
            if (!importedPlayerDetails && leagueInput) {
                try {
                    const parsed = JSON.parse(leagueInput);
                    if (parsed.playerDetails) {
                        importedPlayerDetails = parsed.playerDetails;
                    }
                } catch(e) {}
            }
            
            // Apply transactions to update squads with trades/waivers
            if (importedLeagueData?.squads && importedLeagueData?.transactions) {
                applyTransactionsToSquads();
            }
            
            // Check what data we have
            const squadsCount = importedLeagueData?.squads ? Object.keys(importedLeagueData.squads).length : 0;
            const hasSquads = squadsCount > 0;
            const hasBootstrap = importedBootstrap && importedBootstrap.elements;
            const hasElements = importedElementStatus && importedElementStatus.element_status;
            const hasPlayerDetails = importedPlayerDetails && Object.keys(importedPlayerDetails).length > 0;
            const playerDetailsCount = hasPlayerDetails ? Object.keys(importedPlayerDetails).length : 0;
            
            statusHtml += '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">';
            statusHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem;">Data Summary:</div>';
            statusHtml += `<div style="color: ${hasBootstrap ? 'var(--accent-emerald)' : 'var(--accent-rose)'};">• Player Database: ${hasBootstrap ? '✅ ' + importedBootstrap.elements.length + ' players' : '❌ Missing'}</div>`;
            const fetchedForGW = importedLeagueData?.currentEvent;
            const gwLabel = fetchedForGW ? ` (GW${fetchedForGW})` : '';
            statusHtml += `<div style="color: ${hasSquads ? 'var(--accent-emerald)' : 'var(--accent-amber)'};">• Squad Data: ${hasSquads ? '✅ ' + squadsCount + ' teams' + gwLabel : '⚠️ Missing (N-K-D analysis unavailable)'}</div>`;
            statusHtml += `<div style="color: ${hasElements ? 'var(--accent-emerald)' : 'var(--accent-amber)'};">• Element Status: ${hasElements ? '✅ ' + importedElementStatus.element_status.length + ' tracked' : '⚠️ Missing (Free agents unavailable)'}</div>`;
            statusHtml += `<div style="color: ${hasPlayerDetails ? 'var(--accent-emerald)' : 'var(--accent-amber)'};">• Player Details: ${hasPlayerDetails ? '✅ ' + playerDetailsCount + ' players with GW history' : '⚠️ Missing (Per-GW stats unavailable)'}</div>`;
            
            // Check for transactions
            const hasTransactions = importedLeagueData?.transactions?.transactions?.length > 0;
            const transactionsCount = importedLeagueData?.transactions?.transactions?.length || 0;
            statusHtml += `<div style="color: ${hasTransactions ? 'var(--accent-amber)' : 'var(--text-muted)'};">• Transactions: ${hasTransactions ? '✅ ' + transactionsCount + ' trades/waivers' : '⚠️ No transaction data'}</div>`;
            
            // Detect current GW from bootstrap events
            const currentGW = getCurrentGameweek();
            if (currentGW) {
                statusHtml += `<div style="color: var(--accent-cyan); margin-top: 0.5rem;">📅 Current Gameweek: <strong>GW${currentGW}</strong> (analyzing GW${currentGW}-38)</div>`;
            }
            statusHtml += '</div>';
            
            // Save to localStorage
            if (hasData) {
                const saved = saveLeagueData();
                if (saved) {
                    statusHtml += '<div style="margin-top: 0.75rem; color: var(--accent-cyan); font-size: 0.85rem;">💾 Data saved locally - will auto-load next time!</div>';
                }
                
                // Import into DuckDB database for proper ownership tracking
                if (typeof FPLDB !== 'undefined') {
                    const leagueInputVal = document.getElementById('leagueDataInput').value.trim();
                    if (leagueInputVal) {
                        try {
                            const parsed = JSON.parse(leagueInputVal);
                            console.log('[Import] Importing data into database...');
                            FPLDB.importData(parsed).then(dbResult => {
                                console.log('[Import] Database import result:', dbResult);
                                statusHtml += '<div style="margin-top: 0.5rem; color: var(--accent-violet); font-size: 0.85rem;">🗄️ Database updated for fast queries!</div>';
                            }).catch(dbError => {
                                console.warn('[Import] Database import failed:', dbError);
                            });
                        } catch(e) {
                            console.warn('[Import] Failed to parse for DB import:', e);
                        }
                    }
                }
            }
            
            statusContent.innerHTML = statusHtml;
            
            if (hasData && importedLeagueData) {
                renderLeagueAnalysis();
            }
        }
        
        function buildElementMap() {
            if (!importedBootstrap || !importedBootstrap.elements) return;
            
            fplElementMap = {};
            importedBootstrap.elements.forEach(el => {
                fplElementMap[el.id] = {
                    id: el.id,
                    name: el.web_name,
                    firstName: el.first_name,
                    lastName: el.second_name,
                    team: fplTeamIdMap[el.team] || 'Unknown',
                    teamId: el.team,
                    position: fplPositionMap[el.element_type] || 'Unknown',
                    positionId: el.element_type,
                    totalPoints: el.total_points,
                    form: parseFloat(el.form) || 0,
                    selectedBy: parseFloat(el.selected_by_percent) || 0,
                    news: el.news || '',
                    chanceOfPlaying: el.chance_of_playing_next_round
                };
            });
        }
        
        function getPlayerById(elementId) {
            // First check FPL element map (built from bootstrap data)
            if (fplElementMap[elementId]) return fplElementMap[elementId];
            
            // Then check our local wishlist
            const wishlistPlayer = wishlistPlayers.find(p => p.fplId === elementId);
            if (wishlistPlayer) return wishlistPlayer;
            
            return { name: 'Unknown (' + elementId + ')', team: 'Unknown', position: 'Unknown' };
        }
        
        function renderLeagueAnalysis() {
            const resultsDiv = document.getElementById('leagueAnalysisResults');
            resultsDiv.style.display = 'block';
            
            // Add fetch date header
            renderFetchDateHeader();
            
            // Render league overview
            renderLeagueOverview();
        }
        
        // Render the data fetch date header
        function renderFetchDateHeader() {
            let headerEl = document.getElementById('dataFetchHeader');
            if (!headerEl) {
                headerEl = document.createElement('div');
                headerEl.id = 'dataFetchHeader';
                const resultsDiv = document.getElementById('leagueAnalysisResults');
                resultsDiv.insertBefore(headerEl, resultsDiv.firstChild);
            }
            
            const fetchedAt = importedLeagueData?.fetchedAt;
            const currentGW = getCurrentGameweek();
            const playerDetailsCount = importedPlayerDetails ? Object.keys(importedPlayerDetails).length : 0;
            
            let fetchDateStr = 'Unknown';
            if (fetchedAt) {
                const date = new Date(fetchedAt);
                fetchDateStr = date.toLocaleDateString('en-GB', { 
                    weekday: 'short', 
                    day: 'numeric', 
                    month: 'short', 
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            headerEl.innerHTML = `
                <div style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.15), rgba(139, 92, 246, 0.15)); 
                            padding: 1rem 1.5rem; 
                            border-radius: 12px; 
                            margin-bottom: 1.5rem;
                            border: 1px solid var(--accent-cyan);
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            flex-wrap: wrap;
                            gap: 1rem;">
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="font-size: 1.5rem;">📡</div>
                        <div>
                            <div style="font-weight: 600; color: var(--accent-cyan);">Data Fetched: ${fetchDateStr}</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">
                                GW${currentGW} • ${playerDetailsCount} players with detailed stats
                            </div>
                        </div>
                    </div>
                    <button onclick="tryAutoImportFromClipboard()" style="padding: 0.5rem 1rem; background: var(--accent-violet); font-size: 0.85rem; white-space: nowrap;">
                        🔄 Refresh from Clipboard
                    </button>
                </div>
            `;
            
            // Render recent transactions (trades, waivers)
            renderRecentTransactions();
            
            // Render teams comparison
            renderTeamsComparison();
            
            // Render N-K-D for all teams
            renderAllTeamsNKD();
            
            // Render free agents
            renderFreeAgents();
            
            // Setup head-to-head dropdowns
            setupH2HDropdowns();
            
            // Setup team squad view dropdown
            setupTeamViewDropdown();
        }
        
        // Render recent transactions (trades, waivers, free agent pickups)
        function renderRecentTransactions() {
            const container = document.getElementById('recentTransactionsView');
            if (!container) return;
            
            const transactions = importedLeagueData.transactions?.transactions || [];
            const entries = importedLeagueData.league_entries || [];
            
            if (transactions.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 1rem; color: var(--text-muted);">
                        No transactions data available. Re-fetch using bookmarklet to load trades.
                    </div>
                `;
                return;
            }
            
            // Helper to get team name
            const getTeamName = (entryId) => {
                const entry = entries.find(e => e.id === entryId || e.entry_id === entryId);
                return entry?.entry_name || 'Unknown Team';
            };
            
            // Helper to get player name
            const getPlayerName = (elementId) => {
                const player = getPlayerById(elementId);
                return player?.name || `Player #${elementId}`;
            };
            
            // Group transactions by type and sort by most recent
            const recentTrans = [...transactions]
                .sort((a, b) => b.event - a.event || new Date(b.added || 0) - new Date(a.added || 0))
                .slice(0, 30); // Show last 30
            
            let html = '<div style="max-height: 400px; overflow-y: auto;">';
            
            // Get current event for highlighting recent trades
            const currentGW = importedLeagueData.currentEvent || getCurrentGameweek();
            
            recentTrans.forEach(trans => {
                const isRecent = trans.event >= currentGW - 1;
                const bgColor = isRecent ? 'rgba(245, 158, 11, 0.1)' : 'var(--bg-secondary)';
                const borderColor = isRecent ? 'var(--accent-amber)' : 'var(--border-color)';
                
                let icon = '📋';
                let typeLabel = 'Transaction';
                let description = '';
                
                // Determine transaction type
                // Use player_in_name from API if available, otherwise lookup by player_in/element_in
                const getTransPlayerIn = () => trans.player_in_name || getPlayerName(trans.player_in || trans.element_in);
                const getTransPlayerOut = () => trans.player_out_name || getPlayerName(trans.player_out || trans.element_out);
                
                if (trans.kind === 't' || trans.kind === 'trade') {
                    icon = '🤝';
                    typeLabel = 'Trade';
                    description = `<span style="color: var(--accent-emerald);">+${getTransPlayerIn()}</span> / <span style="color: var(--accent-rose);">-${getTransPlayerOut()}</span>`;
                } else if (trans.kind === 'w' || trans.kind === 'waiver') {
                    icon = '🔄';
                    typeLabel = 'Waiver';
                    description = `<span style="color: var(--accent-emerald);">+${getTransPlayerIn()}</span> / <span style="color: var(--accent-rose);">-${getTransPlayerOut()}</span>`;
                } else if (trans.kind === 'f' || trans.kind === 'free') {
                    icon = '🆓';
                    typeLabel = 'Free Agent';
                    const playerOut = (trans.player_out || trans.element_out) ? getTransPlayerOut() : null;
                    description = `<span style="color: var(--accent-emerald);">+${getTransPlayerIn()}</span>`;
                    if (playerOut) description += ` / <span style="color: var(--accent-rose);">-${playerOut}</span>`;
                } else {
                    description = `Type: ${trans.kind || 'unknown'}`;
                }
                
                const teamName = trans.entry_name || getTeamName(trans.entry_id || trans.entry);
                const status = trans.result === 'a' ? '✅' : (trans.result === 'di' ? '❌' : '⏳');
                
                html += `
                    <div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: ${bgColor}; border-radius: 8px; margin-bottom: 0.5rem; border-left: 3px solid ${borderColor};">
                        <div style="font-size: 1.2rem;">${icon}</div>
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 600; font-size: 0.85rem;">${teamName}</span>
                                <span style="font-size: 0.7rem; color: var(--text-muted);">GW${trans.event} ${status}</span>
                            </div>
                            <div style="font-size: 0.8rem; margin-top: 0.25rem;">
                                <span style="color: var(--text-muted);">${typeLabel}:</span> ${description}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Add summary
            const trades = transactions.filter(t => t.kind === 't' || t.kind === 'trade').length;
            const waivers = transactions.filter(t => t.kind === 'w' || t.kind === 'waiver').length;
            const freeAgents = transactions.filter(t => t.kind === 'f' || t.kind === 'free').length;
            
            const summaryHtml = `
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                    <div style="background: var(--bg-tertiary); padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.85rem;">
                        🤝 <strong>${trades}</strong> Trades
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.85rem;">
                        🔄 <strong>${waivers}</strong> Waivers
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.85rem;">
                        🆓 <strong>${freeAgents}</strong> Free Agent Pickups
                    </div>
                </div>
            `;
            
            container.innerHTML = summaryHtml + html;
        }
        
        function setupTeamViewDropdown() {
            const entries = importedLeagueData.league_entries || [];
            const select = document.getElementById('viewTeamSelect');
            
            if (!select || entries.length === 0) return;
            
            const yourEntryId = importedLeagueData.league?.admin_entry;
            
            let options = entries.map(e => {
                const isYou = e.entry_id === yourEntryId;
                return `<option value="${e.entry_id}" ${isYou ? 'selected' : ''}>${e.entry_name} ${isYou ? '⭐' : ''}</option>`;
            }).join('');
            
            select.innerHTML = options;
            renderTeamSquadView();
        }
        
        function renderTeamSquadView() {
            const container = document.getElementById('teamSquadView');
            const select = document.getElementById('viewTeamSelect');
            const showDetailed = document.getElementById('showDetailedStats')?.checked ?? true;
            
            if (!select || !container) return;
            
            const entryId = parseInt(select.value);
            const entries = importedLeagueData.league_entries || [];
            const squads = importedLeagueData.squads || {};
            
            const entry = entries.find(e => e.entry_id === entryId);
            const squadData = squads[entryId];
            
            if (!entry) {
                container.innerHTML = '<div style="color: var(--text-muted);">Select a team to view</div>';
                return;
            }
            
            if (!squadData || !squadData.picks) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; background: var(--bg-tertiary); border-radius: 12px;">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">📭</div>
                        <div style="color: var(--text-muted);">Squad data not available for ${entry.entry_name}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.5rem;">Re-fetch data using the bookmarklet</div>
                    </div>
                `;
                return;
            }
            
            // Group players by position
            const positions = { GK: [], DEF: [], MID: [], FWD: [] };
            
            squadData.picks.forEach(pick => {
                const player = getPlayerById(pick.element);
                const bootstrapPlayer = importedBootstrap?.elements?.find(e => e.id === pick.element);
                const details = importedPlayerDetails?.[pick.element];
                
                const playerData = {
                    ...player,
                    pick,
                    bootstrap: bootstrapPlayer,
                    details,
                    isCaptain: pick.is_captain,
                    isViceCaptain: pick.is_vice_captain,
                    multiplier: pick.multiplier,
                    positionSlot: pick.position
                };
                
                const pos = player.position || 'MID';
                if (positions[pos]) {
                    positions[pos].push(playerData);
                }
            });
            
            let html = `<div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(34, 211, 238, 0.2)); border-radius: 12px;">
                <div style="font-size: 1.2rem; font-weight: 700;">${entry.entry_name}</div>
                <div style="color: var(--text-secondary); font-size: 0.85rem;">Manager: ${entry.player_first_name} ${entry.player_last_name}</div>
            </div>`;
            
            const positionColors = {
                GK: 'var(--accent-amber)',
                DEF: 'var(--accent-emerald)', 
                MID: 'var(--accent-cyan)',
                FWD: 'var(--accent-rose)'
            };
            
            const positionEmojis = {
                GK: '🧤',
                DEF: '🛡️',
                MID: '⚡',
                FWD: '⚽'
            };
            
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const players = positions[pos];
                if (players.length === 0) return;
                
                html += `
                    <div style="margin-bottom: 1.5rem;">
                        <h4 style="color: ${positionColors[pos]}; margin-bottom: 0.75rem; font-size: 0.9rem;">
                            ${positionEmojis[pos]} ${pos} (${players.length})
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(${showDetailed ? '280px' : '180px'}, 1fr)); gap: 0.75rem;">
                `;
                
                players.forEach(p => {
                    const bs = p.bootstrap || {};
                    const isStarting = p.positionSlot <= 11;
                    const form = parseFloat(bs.form) || 0;
                    const formColor = form >= 6 ? 'var(--accent-emerald)' : form >= 4 ? 'var(--accent-amber)' : 'var(--accent-rose)';
                    
                    html += `
                        <div style="background: ${isStarting ? 'var(--bg-tertiary)' : 'var(--bg-secondary)'}; padding: 0.75rem; border-radius: 10px; border-left: 3px solid ${positionColors[pos]}; ${!isStarting ? 'opacity: 0.6;' : ''} position: relative;">
                            ${p.isCaptain ? '<span style="position: absolute; top: 0.5rem; right: 0.5rem; background: var(--accent-amber); color: #000; font-size: 0.65rem; padding: 0.15rem 0.4rem; border-radius: 4px; font-weight: 700;">C</span>' : ''}
                            ${p.isViceCaptain ? '<span style="position: absolute; top: 0.5rem; right: 0.5rem; background: var(--bg-primary); color: var(--text-secondary); font-size: 0.65rem; padding: 0.15rem 0.4rem; border-radius: 4px; font-weight: 600; border: 1px solid var(--border-color);">VC</span>' : ''}
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                                <div>
                                    <div style="font-weight: 600; font-size: 0.95rem; cursor: pointer; color: var(--accent-cyan);" onclick="showPlayerDetail(${p.pick.element})" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${p.name || 'Unknown'}</div>
                                    <div style="font-size: 0.75rem; color: var(--text-muted);">${p.team || 'Unknown'}</div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.1rem; font-weight: 700; color: ${formColor};">${form.toFixed(1)}</div>
                                    <div style="font-size: 0.65rem; color: var(--text-muted);">form</div>
                                </div>
                            </div>
                    `;
                    
                    if (showDetailed) {
                        const gwHistory = p.details?.history || [];
                        const recentGWs = gwHistory.slice(-5);
                        const totalPts = bs.total_points || 0;
                        
                        // Calculate DEFCON from GW history
                        let totalDefcon = 0;
                        let defconGWs = 0; // GWs where DEFCON bonus was achieved
                        gwHistory.forEach(gw => {
                            // DEFCON = clearances + blocks + interceptions + tackles
                            const cbi = gw.clearances_blocks_interceptions || 0;
                            const tackles = gw.tackles || 0;
                            const defActions = cbi + tackles;
                            totalDefcon += defActions;
                            // Check if DEFCON threshold met (10 for DEF, 12 for MID/FWD)
                            const threshold = pos === 'DEF' ? 10 : 12;
                            if (defActions >= threshold) defconGWs++;
                        });
                        
                        html += `
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.3rem; margin-bottom: 0.5rem; font-size: 0.7rem;">
                                <div style="text-align: center; padding: 0.3rem; background: var(--bg-secondary); border-radius: 4px;">
                                    <div style="font-weight: 600; color: var(--accent-cyan);">${totalPts}</div>
                                    <div style="color: var(--text-muted);">Pts</div>
                                </div>
                                <div style="text-align: center; padding: 0.3rem; background: var(--bg-secondary); border-radius: 4px;">
                                    <div style="font-weight: 600; color: var(--accent-emerald);">${bs.goals_scored || 0}</div>
                                    <div style="color: var(--text-muted);">Goals</div>
                                </div>
                                <div style="text-align: center; padding: 0.3rem; background: var(--bg-secondary); border-radius: 4px;">
                                    <div style="font-weight: 600; color: var(--accent-violet);">${bs.assists || 0}</div>
                                    <div style="color: var(--text-muted);">Assists</div>
                                </div>
                                <div style="text-align: center; padding: 0.3rem; background: var(--bg-secondary); border-radius: 4px;">
                                    <div style="font-weight: 600;">${bs.minutes || 0}</div>
                                    <div style="color: var(--text-muted);">Min</div>
                                </div>
                            </div>
                            <!-- Defensive Stats Row -->
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.3rem; margin-bottom: 0.5rem; font-size: 0.7rem;">
                                <div style="text-align: center; padding: 0.3rem; background: rgba(16, 185, 129, 0.15); border-radius: 4px; border: 1px solid rgba(16, 185, 129, 0.3);">
                                    <div style="font-weight: 600; color: var(--accent-emerald);">${bs.clean_sheets || 0}</div>
                                    <div style="color: var(--text-muted);">CS</div>
                                </div>
                                <div style="text-align: center; padding: 0.3rem; background: rgba(139, 92, 246, 0.15); border-radius: 4px; border: 1px solid rgba(139, 92, 246, 0.3);">
                                    <div style="font-weight: 600; color: var(--accent-violet);">${totalDefcon}</div>
                                    <div style="color: var(--text-muted);">DC Tot</div>
                                </div>
                                <div style="text-align: center; padding: 0.3rem; background: rgba(245, 158, 11, 0.15); border-radius: 4px; border: 1px solid rgba(245, 158, 11, 0.3);">
                                    <div style="font-weight: 600; color: var(--accent-amber);">${defconGWs}</div>
                                    <div style="color: var(--text-muted);">DC GWs</div>
                                </div>
                            </div>
                        `;
                        
                        // Recent GW points
                        if (recentGWs.length > 0) {
                            html += `<div style="display: flex; gap: 0.2rem; margin-top: 0.5rem;">`;
                            recentGWs.forEach(gw => {
                                const pts = gw.total_points || 0;
                                const bgColor = pts >= 10 ? 'var(--accent-emerald)' : pts >= 5 ? 'var(--accent-amber)' : pts > 0 ? 'var(--bg-secondary)' : 'var(--accent-rose)';
                                const textColor = pts >= 5 ? '#000' : 'var(--text-primary)';
                                const gwNumTip = gw.round || gw.event || '?';
                                html += `
                                    <div style="flex: 1; text-align: center; padding: 0.25rem; background: ${bgColor}; border-radius: 3px; font-size: 0.7rem; color: ${textColor};" title="GW${gwNumTip}: ${pts}pts">
                                        ${pts}
                                    </div>
                                `;
                            });
                            html += `</div><div style="font-size: 0.6rem; color: var(--text-muted); text-align: center; margin-top: 0.2rem;">Last ${recentGWs.length} GWs</div>`;
                        }
                    }
                    
                    html += `</div>`;
                });
                
                html += `</div></div>`;
            });
            
            container.innerHTML = html;
        }
        
        function renderLeagueOverview() {
            const league = importedLeagueData.league;
            const entries = importedLeagueData.league_entries || [];
            const standings = importedLeagueData.standings || [];
            
            let html = `
                <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 12px;">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-cyan);">${league.name || 'Unknown League'}</div>
                    <div style="color: var(--text-muted); font-size: 0.9rem;">ID: ${league.id}</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 12px;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-emerald);">${entries.length}</div>
                    <div style="color: var(--text-muted); font-size: 0.85rem;">Teams</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 12px;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-amber);">GW ${league.start_event || '?'}-${league.stop_event || '?'}</div>
                    <div style="color: var(--text-muted); font-size: 0.85rem;">Season Range</div>
                </div>
                <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 12px;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-violet);">${league.draft_status || 'Unknown'}</div>
                    <div style="color: var(--text-muted); font-size: 0.85rem;">Draft Status</div>
                </div>
            `;
            
            document.getElementById('leagueOverview').innerHTML = html;
        }
        
        function renderTeamsComparison() {
            const entries = importedLeagueData.league_entries || [];
            const standings = importedLeagueData.standings || [];
            const squads = importedLeagueData.squads || {};
            
            // Create standings map
            const standingsMap = {};
            standings.forEach(s => {
                const entry = entries.find(e => e.id === s.league_entry);
                if (entry) {
                    standingsMap[entry.entry_id] = s;
                }
            });
            
            let html = `
                <table style="width: 100%; border-collapse: separate; border-spacing: 0 0.5rem; font-size: 0.85rem;">
                    <thead>
                        <tr style="background: var(--bg-tertiary);">
                            <th style="padding: 0.75rem; text-align: left; border-radius: 8px 0 0 8px;">#</th>
                            <th style="padding: 0.75rem; text-align: left;">Team</th>
                            <th style="padding: 0.75rem; text-align: left;">Manager</th>
                            <th style="padding: 0.75rem; text-align: center;">W</th>
                            <th style="padding: 0.75rem; text-align: center;">L</th>
                            <th style="padding: 0.75rem; text-align: center;">Pts For</th>
                            <th style="padding: 0.75rem; text-align: center;">Pts Against</th>
                            <th style="padding: 0.75rem; text-align: center; border-radius: 0 8px 8px 0;">Total</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Sort by standings rank
            const sortedEntries = [...entries].sort((a, b) => {
                const sa = standingsMap[a.entry_id];
                const sb = standingsMap[b.entry_id];
                return (sa?.rank || 99) - (sb?.rank || 99);
            });
            
            sortedEntries.forEach((entry, idx) => {
                const standing = standingsMap[entry.entry_id] || {};
                const isUser = entry.entry_id === 822133; // Your entry ID
                
                html += `
                    <tr style="background: ${isUser ? 'rgba(34, 211, 238, 0.15)' : 'var(--bg-tertiary)'}; ${isUser ? 'border: 2px solid var(--accent-cyan);' : ''}">
                        <td style="padding: 0.75rem; border-radius: 8px 0 0 8px; font-weight: 600; color: var(--accent-${idx < 3 ? 'emerald' : 'amber'});">${standing.rank || '-'}</td>
                        <td style="padding: 0.75rem; font-weight: 600;">${entry.entry_name} ${isUser ? '⭐' : ''}</td>
                        <td style="padding: 0.75rem; color: var(--text-secondary);">${entry.player_first_name} ${entry.player_last_name}</td>
                        <td style="padding: 0.75rem; text-align: center; color: var(--accent-emerald);">${standing.matches_won || 0}</td>
                        <td style="padding: 0.75rem; text-align: center; color: var(--accent-rose);">${standing.matches_lost || 0}</td>
                        <td style="padding: 0.75rem; text-align: center;">${standing.points_for || 0}</td>
                        <td style="padding: 0.75rem; text-align: center;">${standing.points_against || 0}</td>
                        <td style="padding: 0.75rem; text-align: center; border-radius: 0 8px 8px 0; font-weight: 700; color: var(--accent-violet);">${standing.total || 0}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            
            document.getElementById('teamsComparisonTable').innerHTML = html;
        }
        
        function renderAllTeamsNKD() {
            const entries = importedLeagueData.league_entries || [];
            const squads = importedLeagueData.squads || {};
            
            if (Object.keys(squads).length === 0) {
                document.getElementById('allTeamsNKD').innerHTML = `
                    <div style="text-align: center; padding: 2rem; background: rgba(245, 158, 11, 0.1); border: 1px solid var(--accent-amber); border-radius: 12px;">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⚠️</div>
                        <div style="color: var(--accent-amber); font-weight: 600; margin-bottom: 0.5rem;">Squad Data Not Available</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">
                            To see N-K-D analysis, use the bookmarklet on draft.premierleague.com to fetch complete data including team squads.
                        </div>
                    </div>
                `;
                return;
            }
            
            // Check if squads have picks data
            const firstSquad = Object.values(squads)[0];
            if (!firstSquad || !firstSquad.picks || firstSquad.picks.length === 0) {
                document.getElementById('allTeamsNKD').innerHTML = `
                    <div style="text-align: center; padding: 2rem; background: rgba(245, 158, 11, 0.1); border: 1px solid var(--accent-amber); border-radius: 12px;">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⚠️</div>
                        <div style="color: var(--accent-amber); font-weight: 600; margin-bottom: 0.5rem;">Squad Picks Not Found</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">
                            Squad data was fetched but player picks are missing. The API may have changed or you need to re-fetch using the updated bookmarklet.
                        </div>
                    </div>
                `;
                return;
            }
            
            // Get current GW for display
            const currentGW = getCurrentGameweek();
            const remainingGWs = 38 - currentGW + 1;
            
            // Show scoring legend
            let html = `
                <div style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.1), rgba(139, 92, 246, 0.1)); padding: 1rem; border-radius: 10px; margin-bottom: 1rem; border: 1px solid var(--accent-cyan);">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;">
                        <div style="font-weight: 600; color: var(--accent-cyan);">📅 Analyzing GW${currentGW} → GW38 (${remainingGWs} gameweeks remaining)</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">Past GWs excluded from analysis</div>
                    </div>
                    <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--accent-amber); font-size: 0.85rem;">⭐ Weighted Scoring</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 1rem; color: var(--text-secondary); font-size: 0.8rem;">
                        <span>⭐ Star + Easy: <strong style="color: var(--accent-emerald);">1.5</strong></span>
                        <span>⭐ Star + Medium: <strong style="color: var(--accent-amber);">1.0</strong></span>
                        <span>⭐ Star + Hard: <strong style="color: var(--accent-rose);">0.7</strong></span>
                        <span>Regular + Easy: <strong>1.0</strong></span>
                        <span>Regular + Medium: <strong style="color: var(--accent-cyan);">0.5</strong></span>
                        <span>Regular + Hard: <strong style="color: var(--text-muted);">0.0</strong></span>
                    </div>
                </div>
            `;
            
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1rem;">';
            
            const yourEntryId = importedLeagueData.league?.admin_entry || 822133;
            
            entries.forEach(entry => {
                const squadData = squads[entry.entry_id];
                if (!squadData) return;
                
                // Calculate N-K-D metrics for this team
                const analysis = analyzeSquadNKD(squadData);
                const isUser = entry.entry_id === yourEntryId;
                
                html += `
                    <div style="background: ${isUser ? 'rgba(34, 211, 238, 0.1)' : 'var(--bg-tertiary)'}; padding: 1rem; border-radius: 12px; border: ${isUser ? '2px solid var(--accent-cyan)' : '1px solid var(--border-color)'};">
                        <div style="font-weight: 600; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center;">
                            <span>${entry.entry_name} ${isUser ? '⭐' : ''}</span>
                            <span style="font-size: 0.75rem; color: var(--text-muted);">${entry.player_first_name}</span>
                        </div>
                        
                        <!-- Star Players Badge -->
                        ${analysis.starPlayersInSquad > 0 ? `
                            <div style="margin-bottom: 0.5rem; font-size: 0.75rem; color: var(--accent-amber);">
                                ⭐ ${analysis.starPlayersInSquad} Always Start player${analysis.starPlayersInSquad > 1 ? 's' : ''}
                            </div>
                        ` : ''}
                        
                        <!-- Weighted Score (NEW - Primary) -->
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 0.5rem;">
                            <div style="text-align: center; padding: 0.5rem; background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(16, 185, 129, 0.2)); border-radius: 6px; border: 1px solid var(--accent-amber);">
                                <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-amber);">${analysis.avgWeightedPerGW.toFixed(1)}</div>
                                <div style="font-size: 0.6rem; color: var(--text-muted);">⭐ Weighted Avg/GW</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(16, 185, 129, 0.2)); border-radius: 6px; border: 1px solid var(--accent-amber);">
                                <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-amber);">${analysis.gwsWith11PlusWeighted}</div>
                                <div style="font-size: 0.6rem; color: var(--text-muted);">⭐ GWs ≥11 Weighted</div>
                            </div>
                        </div>
                        
                        <!-- Legacy Stats (Secondary) -->
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">
                            <div style="text-align: center; padding: 0.4rem; background: var(--bg-secondary); border-radius: 6px;">
                                <div style="font-size: 1rem; font-weight: 600; color: var(--accent-emerald);">${analysis.avgEasyPerGW.toFixed(1)}</div>
                                <div style="font-size: 0.55rem; color: var(--text-muted);">Easy Only/GW</div>
                            </div>
                            <div style="text-align: center; padding: 0.4rem; background: var(--bg-secondary); border-radius: 6px;">
                                <div style="font-size: 1rem; font-weight: 600; color: var(--accent-cyan);">${analysis.gwsWith11Plus}</div>
                                <div style="font-size: 0.55rem; color: var(--text-muted);">GWs 11+ Easy</div>
                            </div>
                            <div style="text-align: center; padding: 0.4rem; background: var(--bg-secondary); border-radius: 6px;">
                                <div style="font-size: 1rem; font-weight: 600; color: var(--accent-violet);">${analysis.totalScore}</div>
                                <div style="font-size: 0.55rem; color: var(--text-muted);">Total Score</div>
                            </div>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text-secondary);">
                            Max from team: ${analysis.maxFromOneTeam} | Teams: ${Object.keys(analysis.teamDistribution).length}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('allTeamsNKD').innerHTML = html;
        }
        
        // Get the current gameweek (first unfinished GW, or latest finished + 1)
        function getCurrentGameweek() {
            // FIRST priority: check bootstrap events (most reliable source)
            if (importedBootstrap && importedBootstrap.events && Array.isArray(importedBootstrap.events)) {
                const events = importedBootstrap.events;
                
                // Find the current event (is_current = true)
                const currentEvent = events.find(e => e.is_current);
                if (currentEvent) return currentEvent.id;
                
                // Find first unfinished event
                const nextEvent = events.find(e => !e.finished);
                if (nextEvent) return nextEvent.id;
                
                // All finished - return last event + 1 or 38
                const lastFinished = events.filter(e => e.finished).pop();
                if (lastFinished) return Math.min(lastFinished.id + 1, 38);
            }
            
            // Second priority: check fixtures to find first unfinished gameweek
            if (importedBootstrap?.fixtures) {
                const fixtures = importedBootstrap.fixtures;
                // Check each gameweek starting from 21
                for (let gw = 21; gw <= 38; gw++) {
                    const gwFixtures = fixtures[String(gw)] || [];
                    // If this GW has unfinished fixtures, it's the next GW
                    const hasUnfinished = gwFixtures.some(f => !f.finished);
                    if (hasUnfinished) {
                        console.log('[GW Detection] Found next GW from fixtures:', gw);
                        return gw;
                    }
                }
            }
            
            // Third priority: check league matches to find first unstarted match
            if (importedLeagueData?.matches && Array.isArray(importedLeagueData.matches)) {
                const matches = importedLeagueData.matches;
                // Find first match that hasn't started
                const unstartedMatch = matches.find(m => !m.started);
                if (unstartedMatch) return unstartedMatch.event || unstartedMatch.gameweek;
                
                // Find last finished match
                const finishedMatches = matches.filter(m => m.finished);
                if (finishedMatches.length > 0) {
                    const lastFinished = finishedMatches.reduce((max, m) => 
                        (m.event || m.gameweek) > (max.event || max.gameweek) ? m : max);
                    return Math.min((lastFinished.event || lastFinished.gameweek) + 1, 38);
                }
            }
            
            // Fourth priority: use currentEvent from data fetch
            if (importedLeagueData?.currentEvent && importedLeagueData.currentEvent > 20) {
                return importedLeagueData.currentEvent;
            }
            
            // Ultimate fallback - assume we're at GW21 (next upcoming)
            return 21;
        }
        
        // Apply accepted transactions to squad data
        // This ensures squads reflect trades, waivers, and free agent pickups
        function applyTransactionsToSquads() {
            const transactions = importedLeagueData?.transactions?.transactions || [];
            const squads = importedLeagueData?.squads || {};
            const fetchedGW = importedLeagueData?.currentEvent;
            
            if (transactions.length === 0 || Object.keys(squads).length === 0) {
                return; // Nothing to apply
            }
            
            // Get accepted transactions sorted by event (oldest first)
            const acceptedTrans = transactions
                .filter(t => t.result === 'a') // Only accepted transactions
                .sort((a, b) => a.event - b.event || (a.index || 0) - (b.index || 0));
            
            console.log(`Applying ${acceptedTrans.length} accepted transactions to squads...`);
            
            // Helper to find entry_id from league_entry id
            const getEntryId = (leagueEntryId) => {
                const entries = importedLeagueData?.league_entries || [];
                const entry = entries.find(e => e.id === leagueEntryId);
                return entry?.entry_id || leagueEntryId;
            };
            
            // Apply each transaction
            acceptedTrans.forEach(trans => {
                const entryId = getEntryId(trans.entry);
                const squadData = squads[entryId];
                
                if (!squadData || !squadData.picks) {
                    console.log(`No squad data for entry ${entryId}, skipping transaction`);
                    return;
                }
                
                const picks = squadData.picks;
                const elementIn = trans.element_in;
                const elementOut = trans.element_out;
                
                // Check if element_out is in the squad
                const outIndex = picks.findIndex(p => p.element === elementOut);
                
                if (outIndex !== -1) {
                    // Replace element_out with element_in
                    const oldPick = picks[outIndex];
                    picks[outIndex] = {
                        ...oldPick,
                        element: elementIn
                    };
                    console.log(`Applied: ${trans.kind} for entry ${entryId} - OUT: ${elementOut}, IN: ${elementIn}`);
                } else if (elementIn && !elementOut) {
                    // Adding a player without dropping (shouldn't happen in FPL Draft, but handle it)
                    console.log(`Skipping add-only transaction for entry ${entryId}`);
                } else {
                    // element_out not found - transaction may have already been applied or squad is outdated
                    // Check if element_in is already in the squad
                    const inExists = picks.some(p => p.element === elementIn);
                    if (!inExists && elementOut) {
                        console.log(`Warning: element_out ${elementOut} not found in squad for entry ${entryId}`);
                    }
                }
            });
            
            console.log('Transactions applied to squads');
        }
        
        // Team name mapping: short names (FPL API) -> full names (fixture data)
        const teamNameMap = {
            // FPL short names to fixture data names
            'ARS': 'Arsenal', 'Arsenal': 'Arsenal',
            'AVL': 'Villa', 'Aston Villa': 'Villa', 'Villa': 'Villa',
            'BOU': 'Bournemouth', 'Bournemouth': 'Bournemouth',
            'BRE': 'Brentford', 'Brentford': 'Brentford',
            'BHA': 'Brighton', 'Brighton': 'Brighton',
            'CHE': 'Chelsea', 'Chelsea': 'Chelsea',
            'CRY': 'Palace', 'Crystal Palace': 'Palace', 'Palace': 'Palace',
            'EVE': 'Everton', 'Everton': 'Everton',
            'FUL': 'Fulham', 'Fulham': 'Fulham',
            'IPS': 'Leeds', 'Ipswich': 'Leeds', 'Ipswich Town': 'Leeds', // Ipswich replaced Leeds
            'LEI': 'Burnley', 'Leicester': 'Burnley', // Leicester replaced Burnley
            'LIV': 'Liverpool', 'Liverpool': 'Liverpool',
            'MCI': 'City', 'Man City': 'City', 'City': 'City', 'Manchester City': 'City',
            'MUN': 'United', 'Man Utd': 'United', 'United': 'United', 'Manchester United': 'United',
            'NEW': 'Newcastle', 'Newcastle': 'Newcastle',
            'NFO': 'Forest', "Nott'm Forest": 'Forest', 'Forest': 'Forest', 'Nottingham Forest': 'Forest',
            'SOU': 'Sunderland', 'Southampton': 'Sunderland', // Southampton maps to Sunderland slot
            'TOT': 'Spurs', 'Spurs': 'Spurs', 'Tottenham': 'Spurs',
            'WHU': 'West Ham', 'West Ham': 'West Ham',
            'WOL': 'Wolves', 'Wolves': 'Wolves'
        };
        
        // Normalize team name to match fixture data format
        function normalizeTeamName(team) {
            if (!team) return null;
            return teamNameMap[team] || teamNameMap[team.trim()] || team;
        }
        
        // Get fixture difficulty score for a team in a GW
        // Returns: 'easy' (1-2), 'medium' (3), 'hard' (4-5)
        function getFixtureDifficulty(team, gw) {
            const normalizedTeam = normalizeTeamName(team);
            const teamEasyGames = yourAnalysis[normalizedTeam] || [];
            const teamOfficialFDR = officialFDR[normalizedTeam]?.scores || {};
            
            // If in your easy games list, it's easy
            if (teamEasyGames.includes(gw)) {
                return 'easy';
            }
            
            // Check official FDR
            const fdrScore = teamOfficialFDR[gw] || 3;
            if (fdrScore <= 2) return 'easy';
            if (fdrScore === 3) return 'medium';
            return 'hard';
        }
        
        // Weighted score contribution based on Always Start status and fixture difficulty
        // Star players: easy=1.5, medium=1.0, hard=0.7
        // Regular players: easy=1.0, medium=0.5, hard=0.0
        function getPlayerGWScore(isAlwaysStar, difficulty) {
            if (isAlwaysStar) {
                switch (difficulty) {
                    case 'easy': return 1.5;
                    case 'medium': return 1.0;
                    case 'hard': return 0.7;
                    default: return 1.0;
                }
            } else {
                // Regular players: easy=1.0, medium=0.5, hard=0.0
                switch (difficulty) {
                    case 'easy': return 1.0;
                    case 'medium': return 0.5;
                    case 'hard': return 0.0;
                    default: return 0.5;
                }
            }
        }
        
        function analyzeSquadNKD(squadData) {
            // Get player picks from squad data
            const picks = squadData.picks || [];
            const playerData = [];
            const teamDistribution = {};
            let totalScore = 0;
            
            picks.forEach(pick => {
                const player = getPlayerById(pick.element);
                if (player && player.team) {
                    // Find wishlist player to check if they're an "Always Start"
                    const wishlistPlayer = wishlistPlayers.find(p => 
                        p.name === player.name || p.fplId === pick.element
                    );
                    
                    const isAlwaysStar = wishlistPlayer ? alwaysStartPlayers.includes(wishlistPlayer.rank) : false;
                    
                    playerData.push({
                        team: player.team,
                        name: player.name,
                        isAlwaysStar,
                        wishlistRank: wishlistPlayer?.rank,
                        score: wishlistPlayer?.score || 0
                    });
                    
                    teamDistribution[player.team] = (teamDistribution[player.team] || 0) + 1;
                    
                    if (wishlistPlayer) {
                        totalScore += wishlistPlayer.score || 0;
                    }
                }
            });
            
            // Calculate weighted score per GW (considering Always Start players)
            const weightedScorePerGW = {};
            const easyPerGW = {}; // Keep legacy count for backward compatibility
            
            // Use current GW as start (only analyze remaining fixtures)
            const startGW = getCurrentGameweek();
            const endGW = 38;
            
            for (let gw = startGW; gw <= endGW; gw++) {
                weightedScorePerGW[gw] = 0;
                easyPerGW[gw] = 0;
                
                playerData.forEach(p => {
                    const difficulty = getFixtureDifficulty(p.team, gw);
                    const gwScore = getPlayerGWScore(p.isAlwaysStar, difficulty);
                    weightedScorePerGW[gw] += gwScore;
                    
                    // Legacy: count easy games (for comparison)
                    if (difficulty === 'easy') {
                        easyPerGW[gw]++;
                    }
                });
            }
            
            const gwValues = Object.values(easyPerGW);
            const weightedValues = Object.values(weightedScorePerGW);
            
            const avgEasyPerGW = gwValues.reduce((a, b) => a + b, 0) / gwValues.length;
            const avgWeightedPerGW = weightedValues.reduce((a, b) => a + b, 0) / weightedValues.length;
            const gwsWith11Plus = gwValues.filter(v => v >= 11).length;
            const gwsWith11PlusWeighted = weightedValues.filter(v => v >= 11).length;
            const maxFromOneTeam = Math.max(...Object.values(teamDistribution), 0);
            
            // Count star players in squad
            const starPlayersInSquad = playerData.filter(p => p.isAlwaysStar).length;
            
            return {
                avgEasyPerGW,
                avgWeightedPerGW,
                gwsWith11Plus,
                gwsWith11PlusWeighted,
                totalScore,
                maxFromOneTeam,
                teamDistribution,
                easyPerGW,
                weightedScorePerGW,
                starPlayersInSquad,
                playerData
            };
        }
        
        function renderFreeAgents() {
            const container = document.getElementById('freeAgentsList');
            if (!container) return;
            
            // Get owned player IDs from squads
            const ownedIds = getAllOwnedPlayerIds();
            
            if (!importedBootstrap?.elements) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                        Player data not loaded. Import league data first.
                    </div>
                `;
                return;
            }
            
            if (ownedIds.size === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                        Squad data not available - cannot determine ownership.
                    </div>
                `;
                return;
            }
            
            // Get free agents (not owned, available, not left the league)
            const freeAgents = importedBootstrap.elements
                .filter(p => {
                    // Not owned
                    if (ownedIds.has(p.id)) return false;
                    
                    // Must be available (status 'a'), not injured/suspended/unavailable
                    if (p.status === 'u' || p.status === 'i' || p.status === 's') return false;
                    
                    // Filter out players who left the PL (minutes = 0 all season, no recent games)
                    if (p.minutes === 0 && p.total_points === 0) return false;
                    
                    // Check if player has any recent activity
                    const details = importedPlayerDetails?.[p.id];
                    if (details?.history) {
                        const recentGames = details.history.slice(-5);
                        const hasPlayedRecently = recentGames.some(g => g.minutes > 0);
                        if (!hasPlayedRecently && details.history.length > 5) {
                            return false; // Player hasn't played in last 5 GWs
                        }
                    }
                    
                    return true;
                })
                .map(p => {
                    const wishlistPlayer = wishlistPlayers.find(wp => wp.fplId === p.id || wp.name === p.web_name);
                    const posName = fplPositionMap[p.element_type] || '?';
                    return {
                        ...p,
                        name: p.web_name,
                        position: posName,
                        team: fplTeamIdMap[p.team] || p.team_name || '?',
                        elementId: p.id,
                        wishlistRank: wishlistPlayer?.rank || 999,
                        wishlistScore: wishlistPlayer?.score || 0
                    };
                })
                .sort((a, b) => a.wishlistRank - b.wishlistRank || b.total_points - a.total_points);
            
            console.log('[FreeAgents] Found', freeAgents.length, 'available free agents');
            
            window.allFreeAgents = freeAgents;
            filterFreeAgents();
        }
        
        function filterFreeAgents() {
            if (!window.allFreeAgents) return;
            
            const position = document.getElementById('freeAgentPosition').value;
            const search = document.getElementById('freeAgentSearch').value.toLowerCase();
            
            let filtered = window.allFreeAgents;
            
            if (position !== 'all') {
                filtered = filtered.filter(p => p.position === position);
            }
            
            if (search) {
                filtered = filtered.filter(p => 
                    p.name?.toLowerCase().includes(search) || 
                    p.team?.toLowerCase().includes(search)
                );
            }
            
            // Limit display
            const displayed = filtered.slice(0, 50);
            
            let html = `
                <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1rem;">
                    Showing ${displayed.length} of ${filtered.length} free agents (sorted by wishlist rank)
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.75rem;">
            `;
            
            displayed.forEach(player => {
                const posColor = {
                    'GK': 'var(--accent-amber)',
                    'DEF': 'var(--accent-emerald)',
                    'MID': 'var(--accent-cyan)',
                    'FWD': 'var(--accent-rose)'
                }[player.position] || 'var(--text-muted)';
                
                html += `
                    <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px; border-left: 3px solid ${posColor}; transition: transform 0.2s; position: relative;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-weight: 600; font-size: 0.9rem; color: var(--accent-cyan); cursor: pointer;" onclick="showPlayerDetail(${player.elementId})">${player.name || 'Unknown'}</div>
                        <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            ${player.team || 'Unknown'} · <span style="color: ${posColor};">${player.position || '?'}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.35rem;">
                            <div style="font-size: 0.7rem; color: var(--text-muted);">
                                Rank: ${player.wishlistRank < 999 ? '#' + player.wishlistRank : 'N/A'}
                            </div>
                            <button onclick="event.stopPropagation(); quickCompare(${player.elementId})" style="font-size: 0.65rem; padding: 0.2rem 0.4rem; background: var(--accent-violet); border: none; border-radius: 4px; cursor: pointer; color: white;">
                                📊 Compare
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('freeAgentsList').innerHTML = html;
        }
        
        function setupH2HDropdowns() {
            const entries = importedLeagueData.league_entries || [];
            
            if (entries.length === 0) {
                document.getElementById('h2hTeam1').innerHTML = '<option>No teams found</option>';
                document.getElementById('h2hTeam2').innerHTML = '<option>No teams found</option>';
                return;
            }
            
            const options = entries.map(e => 
                `<option value="${e.entry_id}">${e.entry_name} (${e.player_first_name})</option>`
            ).join('');
            
            document.getElementById('h2hTeam1').innerHTML = options;
            document.getElementById('h2hTeam2').innerHTML = options;
            
            // Pre-select user's team if found (check various entry IDs)
            const yourEntryId = importedLeagueData.league?.admin_entry || 822133;
            const userOption = entries.find(e => e.entry_id === yourEntryId);
            if (userOption) {
                document.getElementById('h2hTeam1').value = yourEntryId.toString();
            }
            
            // Select second team as different
            if (entries.length > 1) {
                const otherTeam = entries.find(e => e.entry_id !== yourEntryId);
                if (otherTeam) {
                    document.getElementById('h2hTeam2').value = otherTeam.entry_id;
                }
            }
        }
        
        // Helper: Get detailed player info with predicted points
        function getPlayerDetailedInfo(playerId) {
            const player = getPlayerById(playerId);
            const bootstrap = importedBootstrap?.elements?.find(e => e.id === playerId);
            const details = importedPlayerDetails?.[playerId];
            
            if (!player && !bootstrap) return null;
            
            const history = details?.history || [];
            const recentGames = history.slice(-5);
            const form = parseFloat(bootstrap?.form) || 0;
            const totalPoints = bootstrap?.total_points || 0;
            const minutes = bootstrap?.minutes || 0;
            
            // Calculate games played - either from history or estimate from minutes
            // Assume ~60 mins average per game if history unavailable
            const gamesPlayed = history.length > 0 
                ? history.filter(g => g.minutes > 0).length 
                : Math.max(1, Math.round(minutes / 60));
            
            // Calculate ppg (points per game) - use bootstrap form as fallback
            let ppg = 0;
            if (gamesPlayed > 0 && totalPoints > 0) {
                ppg = (totalPoints / gamesPlayed).toFixed(1);
            } else if (form > 0) {
                // Form is a rolling average of recent points, use it as ppg estimate
                ppg = form;
            }
            
            // Calculate average points from last 5 games
            // If no history available, use form or position-based estimate
            let last5Avg = 0;
            if (recentGames.length > 0) {
                last5Avg = (recentGames.reduce((sum, g) => sum + (g.total_points || 0), 0) / recentGames.length).toFixed(1);
            } else if (form > 0) {
                // Use form as best estimate for recent performance
                last5Avg = form;
            } else if (ppg > 0) {
                last5Avg = ppg;
            } else {
                // Position-based default (GK/DEF ~3-4, MID ~4, FWD ~4-5)
                const posDefaults = { 1: 3.5, 2: 3.5, 3: 4, 4: 4.5 };
                last5Avg = posDefaults[bootstrap?.element_type] || 3.5;
            }
            
            // Flag if this player has limited data (for UI warning)
            const hasDetailedData = history.length > 0;
            
            return {
                id: playerId,
                name: player?.name || bootstrap?.web_name || 'Unknown',
                team: player?.team || fplTeamIdMap[bootstrap?.team] || 'Unknown',
                teamId: bootstrap?.team,
                position: player?.position || fplPositionMap[bootstrap?.element_type] || 'MID',
                positionId: bootstrap?.element_type,
                form,
                totalPoints,
                ppg: parseFloat(ppg),
                last5Avg: parseFloat(last5Avg),
                minutes,
                hasDetailedData // New flag to indicate if detailed GW history is available
            };
        }
        
        // Helper: Calculate predicted points for a player in a specific GW
        function calculatePlayerGWPoints(playerInfo, gw) {
            if (!playerInfo) return 0;
            
            const difficulty = getFixtureDifficulty(playerInfo.team, gw);
            const basePoints = playerInfo.last5Avg || playerInfo.ppg || 3;
            
            // Adjust based on fixture difficulty
            let multiplier = 1;
            if (difficulty === 'easy') multiplier = 1.2;
            else if (difficulty === 'hard') multiplier = 0.75;
            
            // Factor in current form
            if (playerInfo.form >= 6) multiplier *= 1.1;
            else if (playerInfo.form < 3) multiplier *= 0.9;
            
            return Math.round(basePoints * multiplier * 10) / 10;
        }
        
        // Helper: Calculate predicted points for a player in upcoming GWs
        function calculatePredictedPoints(playerInfo, numGWs = 5) {
            if (!playerInfo) return { total: 0, perGW: [] };
            
            const currentGW = getCurrentGameweek();
            const predictions = [];
            let total = 0;
            
            for (let i = 0; i < numGWs; i++) {
                const gw = currentGW + i;
                if (gw > 38) break;
                
                const predicted = calculatePlayerGWPoints(playerInfo, gw);
                const difficulty = getFixtureDifficulty(playerInfo.team, gw);
                predictions.push({ gw, predicted, difficulty });
                total += predicted;
            }
            
            return { total: Math.round(total * 10) / 10, perGW: predictions };
        }
        
        // Helper: Select optimal 11 players for a specific GW
        // Formation constraints: 1 GK, 3-5 DEF, 2-5 MID, 1-3 FWD, Total = 11
        function selectOptimal11(players, gw) {
            // Calculate predicted points for each player in this GW
            const playersWithPredictions = players.map(p => ({
                ...p,
                gwPredicted: calculatePlayerGWPoints(p, gw),
                difficulty: getFixtureDifficulty(p.team, gw)
            }));
            
            // Group by position
            const byPos = { GK: [], DEF: [], MID: [], FWD: [] };
            playersWithPredictions.forEach(p => {
                if (byPos[p.position]) byPos[p.position].push(p);
            });
            
            // Sort each position by predicted points (descending)
            Object.keys(byPos).forEach(pos => {
                byPos[pos].sort((a, b) => b.gwPredicted - a.gwPredicted);
            });
            
            // Start with minimum formation: 1 GK, 3 DEF, 2 MID, 1 FWD = 7 players
            const selected = {
                GK: byPos.GK.slice(0, 1),
                DEF: byPos.DEF.slice(0, 3),
                MID: byPos.MID.slice(0, 2),
                FWD: byPos.FWD.slice(0, 1)
            };
            
            let totalSelected = 7;
            const remaining = {
                DEF: byPos.DEF.slice(3), // Can add up to 2 more (max 5)
                MID: byPos.MID.slice(2), // Can add up to 3 more (max 5)
                FWD: byPos.FWD.slice(1)  // Can add up to 2 more (max 3)
            };
            
            const maxAdd = { DEF: 2, MID: 3, FWD: 2 };
            const added = { DEF: 0, MID: 0, FWD: 0 };
            
            // Greedily add the best 4 remaining players
            while (totalSelected < 11) {
                let bestPlayer = null;
                let bestPos = null;
                let bestScore = -1;
                
                ['DEF', 'MID', 'FWD'].forEach(pos => {
                    if (remaining[pos].length > 0 && added[pos] < maxAdd[pos]) {
                        const candidate = remaining[pos][0];
                        if (candidate.gwPredicted > bestScore) {
                            bestScore = candidate.gwPredicted;
                            bestPlayer = candidate;
                            bestPos = pos;
                        }
                    }
                });
                
                if (bestPlayer && bestPos) {
                    selected[bestPos].push(bestPlayer);
                    remaining[bestPos].shift();
                    added[bestPos]++;
                    totalSelected++;
                } else {
                    break; // No more valid players to add
                }
            }
            
            // Flatten selected into array
            const lineup = [
                ...selected.GK,
                ...selected.DEF,
                ...selected.MID,
                ...selected.FWD
            ];
            
            const totalPoints = lineup.reduce((sum, p) => sum + p.gwPredicted, 0);
            
            return {
                lineup,
                formation: `${selected.DEF.length}-${selected.MID.length}-${selected.FWD.length}`,
                totalPoints: Math.round(totalPoints * 10) / 10,
                byPosition: selected
            };
        }
        
        // Helper: Calculate optimal 11 predictions for multiple GWs
        function calculateOptimal11Predictions(players, numGWs = 5) {
            const currentGW = getCurrentGameweek();
            const predictions = [];
            let total = 0;
            
            for (let i = 0; i < numGWs; i++) {
                const gw = currentGW + i;
                if (gw > 38) break;
                
                const optimal = selectOptimal11(players, gw);
                predictions.push({
                    gw,
                    points: optimal.totalPoints,
                    formation: optimal.formation,
                    lineup: optimal.lineup
                });
                total += optimal.totalPoints;
            }
            
            return { total: Math.round(total * 10) / 10, perGW: predictions };
        }
        
        // Helper: Generate trade suggestions
        function generateTradeSuggestions(team1Players, team2Players, team1Entry, team2Entry) {
            const suggestions = [];
            const currentGW = getCurrentGameweek();
            
            // Group players by position
            const t1ByPos = { GK: [], DEF: [], MID: [], FWD: [] };
            const t2ByPos = { GK: [], DEF: [], MID: [], FWD: [] };
            
            team1Players.forEach(p => {
                if (t1ByPos[p.position]) t1ByPos[p.position].push(p);
            });
            team2Players.forEach(p => {
                if (t2ByPos[p.position]) t2ByPos[p.position].push(p);
            });
            
            // Calculate fixture strength for each player over next 5 GWs
            const addFixtureStrength = (player) => {
                let strength = 0;
                for (let i = 0; i < 5; i++) {
                    const gw = currentGW + i;
                    if (gw > 38) break;
                    const diff = getFixtureDifficulty(player.team, gw);
                    if (diff === 'easy') strength += 2;
                    else if (diff === 'medium') strength += 1;
                }
                player.fixtureStrength = strength;
                return player;
            };
            
            team1Players.forEach(addFixtureStrength);
            team2Players.forEach(addFixtureStrength);
            
            // Find 1-for-1 trade opportunities (same position, both benefit from fixtures)
            const positions = ['DEF', 'MID', 'FWD'];
            
            positions.forEach(pos => {
                const t1Pos = t1ByPos[pos].sort((a, b) => a.fixtureStrength - b.fixtureStrength);
                const t2Pos = t2ByPos[pos].sort((a, b) => a.fixtureStrength - b.fixtureStrength);
                
                // Look for players with bad fixtures in one team, good fixtures in other
                t1Pos.forEach(p1 => {
                    t2Pos.forEach(p2 => {
                        // Check if trade benefits both (player with worse fixtures goes to team needing their good future fixtures)
                        if (p1.fixtureStrength < p2.fixtureStrength - 1) {
                            // Team 1 gets p2 (better fixtures), Team 2 gets p1
                            // But is p1 good for Team 2's needs?
                            const p1FutureForT2 = p1.fixtureStrength;
                            const p2FutureForT1 = p2.fixtureStrength;
                            
                            // Calculate what each team gains
                            const t1Gain = p2FutureForT1 - p1.fixtureStrength;
                            const t2Gain = p1FutureForT2 - p2.fixtureStrength;
                            
                            // If both teams gain (or roughly even)
                            if (t1Gain > 0 || t2Gain > 0) {
                                // Check if this is genuinely win-win by looking at form/points too
                                const formDiff = Math.abs(p1.form - p2.form);
                                const ppgDiff = Math.abs((p1.ppg || 3) - (p2.ppg || 3));
                                
                                if (formDiff < 3 && ppgDiff < 2) {
                                    suggestions.push({
                                        type: '1-for-1',
                                        team1Gets: [p2],
                                        team2Gets: [p1],
                                        reason: `${team1Entry.entry_name} gains fixture strength (${p2.team} has easier run). ${team2Entry.entry_name} gets ${p1.name} who may have better long-term fixtures.`,
                                        score: t1Gain + t2Gain + (p1.form + p2.form) / 2
                                    });
                                }
                            }
                        }
                    });
                });
            });
            
            // Find 2-for-2 batch trades
            positions.forEach(pos => {
                const t1Pos = t1ByPos[pos];
                const t2Pos = t2ByPos[pos];
                
                if (t1Pos.length >= 2 && t2Pos.length >= 2) {
                    // Get bottom 2 by fixture strength from each
                    const t1Bottom2 = [...t1Pos].sort((a, b) => a.fixtureStrength - b.fixtureStrength).slice(0, 2);
                    const t2Top2 = [...t2Pos].sort((a, b) => b.fixtureStrength - a.fixtureStrength).slice(0, 2);
                    
                    const t1BottomStrength = t1Bottom2.reduce((s, p) => s + p.fixtureStrength, 0);
                    const t2TopStrength = t2Top2.reduce((s, p) => s + p.fixtureStrength, 0);
                    
                    if (t2TopStrength > t1BottomStrength + 2) {
                        suggestions.push({
                            type: '2-for-2',
                            team1Gets: t2Top2,
                            team2Gets: t1Bottom2,
                            reason: `Batch swap ${pos}s: ${team1Entry.entry_name} improves fixture run, ${team2Entry.entry_name} diversifies team coverage.`,
                            score: (t2TopStrength - t1BottomStrength) + t2Top2.reduce((s, p) => s + p.form, 0) / 2
                        });
                    }
                }
            });
            
            // Cross-position trades (e.g., MID for FWD if one team is stacked)
            ['MID', 'FWD'].forEach(pos1 => {
                ['MID', 'FWD'].forEach(pos2 => {
                    if (pos1 === pos2) return;
                    
                    if (t1ByPos[pos1].length >= 3 && t2ByPos[pos2].length >= 3) {
                        const t1Weak = t1ByPos[pos1].sort((a, b) => a.form - b.form)[0];
                        const t2Strong = t2ByPos[pos2].sort((a, b) => b.form - a.form)[0];
                        
                        if (t2Strong.form > t1Weak.form + 1) {
                            suggestions.push({
                                type: 'cross-position',
                                team1Gets: [t2Strong],
                                team2Gets: [t1Weak],
                                reason: `Position rebalance: ${team1Entry.entry_name} strengthens ${pos2}, ${team2Entry.entry_name} adds ${pos1} depth.`,
                                score: t2Strong.form - t1Weak.form + (t2Strong.fixtureStrength || 0)
                            });
                        }
                    }
                });
            });
            
            // Sort by score and return top 3
            return suggestions.sort((a, b) => b.score - a.score).slice(0, 3);
        }
        
        function runHeadToHead() {
            const team1Id = parseInt(document.getElementById('h2hTeam1').value);
            const team2Id = parseInt(document.getElementById('h2hTeam2').value);
            
            const entries = importedLeagueData.league_entries || [];
            const squads = importedLeagueData.squads || {};
            const standings = importedLeagueData.standings || [];
            
            const team1Entry = entries.find(e => e.entry_id === team1Id);
            const team2Entry = entries.find(e => e.entry_id === team2Id);
            
            if (!team1Entry || !team2Entry) {
                document.getElementById('h2hResults').innerHTML = '<div style="color: var(--accent-rose);">Team data not found</div>';
                return;
            }
            
            const team1Squad = squads[team1Id];
            const team2Squad = squads[team2Id];
            
            const team1Analysis = team1Squad ? analyzeSquadNKD(team1Squad) : null;
            const team2Analysis = team2Squad ? analyzeSquadNKD(team2Squad) : null;
            
            // Get detailed player info for both squads
            const team1Players = (team1Squad?.picks || []).map(p => getPlayerDetailedInfo(p.element)).filter(Boolean);
            const team2Players = (team2Squad?.picks || []).map(p => getPlayerDetailedInfo(p.element)).filter(Boolean);
            
            // Get standings
            const team1Standing = standings.find(s => {
                const e = entries.find(entry => entry.id === s.league_entry);
                return e && e.entry_id === team1Id;
            });
            const team2Standing = standings.find(s => {
                const e = entries.find(entry => entry.id === s.league_entry);
                return e && e.entry_id === team2Id;
            });
            
            // Calculate predicted points for each team using OPTIMAL 11 selection
            // This respects formation constraints: 1 GK, 3-5 DEF, 2-5 MID, 1-3 FWD
            const team1Optimal = calculateOptimal11Predictions(team1Players, 5);
            const team2Optimal = calculateOptimal11Predictions(team2Players, 5);
            
            const team1PredictedTotal = team1Optimal.total;
            const team2PredictedTotal = team2Optimal.total;
            
            // Also calculate individual player predictions for the squad view
            const team1Predictions = [];
            const team2Predictions = [];
            
            team1Players.forEach(p => {
                const pred = calculatePredictedPoints(p, 5);
                team1Predictions.push({ player: p, ...pred });
            });
            
            team2Players.forEach(p => {
                const pred = calculatePredictedPoints(p, 5);
                team2Predictions.push({ player: p, ...pred });
            });
            
            // Position strength calculation
            const calcPositionStrength = (players) => {
                const byPos = { GK: [], DEF: [], MID: [], FWD: [] };
                players.forEach(p => {
                    if (byPos[p.position]) byPos[p.position].push(p);
                });
                
                return {
                    GK: byPos.GK.reduce((s, p) => s + (p.form || 0), 0) / Math.max(1, byPos.GK.length),
                    DEF: byPos.DEF.reduce((s, p) => s + (p.form || 0), 0) / Math.max(1, byPos.DEF.length),
                    MID: byPos.MID.reduce((s, p) => s + (p.form || 0), 0) / Math.max(1, byPos.MID.length),
                    FWD: byPos.FWD.reduce((s, p) => s + (p.form || 0), 0) / Math.max(1, byPos.FWD.length),
                    counts: {
                        GK: byPos.GK.length,
                        DEF: byPos.DEF.length,
                        MID: byPos.MID.length,
                        FWD: byPos.FWD.length
                    }
                };
            };
            
            const team1Strength = calcPositionStrength(team1Players);
            const team2Strength = calcPositionStrength(team2Players);
            
            // Team coverage analysis
            const team1Teams = [...new Set(team1Players.map(p => p.team))];
            const team2Teams = [...new Set(team2Players.map(p => p.team))];
            const sharedTeams = team1Teams.filter(t => team2Teams.includes(t));
            
            // Trade suggestions
            const tradeSuggestions = generateTradeSuggestions(team1Players, team2Players, team1Entry, team2Entry);
            
            // Current GW
            const currentGW = getCurrentGameweek();
            
            // Start building HTML
            let html = `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 2rem; align-items: start; margin-top: 1rem;">
                    <!-- Team 1 -->
                    <div style="text-align: center;">
                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-cyan); margin-bottom: 0.5rem;">${team1Entry.entry_name}</div>
                        <div style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1rem;">${team1Entry.player_first_name} ${team1Entry.player_last_name}</div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 1rem;">
                            <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-emerald);">${team1Standing?.matches_won || 0}</div>
                                <div style="font-size: 0.7rem; color: var(--text-muted);">Wins</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-violet);">${team1Standing?.points_for || 0}</div>
                                <div style="font-size: 0.7rem; color: var(--text-muted);">Points</div>
                            </div>
                        </div>
                        
                        <div style="background: linear-gradient(135deg, rgba(34,211,238,0.1), rgba(139,92,246,0.1)); padding: 1rem; border-radius: 8px; margin-bottom: 0.5rem;">
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Best XI Predicted (5 GWs)</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-cyan);">${team1PredictedTotal.toFixed(0)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-secondary);">~${(team1PredictedTotal / 5).toFixed(1)}/GW avg</div>
                        </div>
                        
                        ${team1Analysis ? `
                            <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Fixture Strength</div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-amber);">${team1Analysis.avgWeightedPerGW?.toFixed(1) || team1Analysis.avgEasyPerGW.toFixed(1)}</div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <!-- VS -->
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 2rem;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--text-muted);">VS</div>
                    </div>
                    
                    <!-- Team 2 -->
                    <div style="text-align: center;">
                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-rose); margin-bottom: 0.5rem;">${team2Entry.entry_name}</div>
                        <div style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1rem;">${team2Entry.player_first_name} ${team2Entry.player_last_name}</div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 1rem;">
                            <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-emerald);">${team2Standing?.matches_won || 0}</div>
                                <div style="font-size: 0.7rem; color: var(--text-muted);">Wins</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-violet);">${team2Standing?.points_for || 0}</div>
                                <div style="font-size: 0.7rem; color: var(--text-muted);">Points</div>
                            </div>
                        </div>
                        
                        <div style="background: linear-gradient(135deg, rgba(244,63,94,0.1), rgba(139,92,246,0.1)); padding: 1rem; border-radius: 8px; margin-bottom: 0.5rem;">
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Best XI Predicted (5 GWs)</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-rose);">${team2PredictedTotal.toFixed(0)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-secondary);">~${(team2PredictedTotal / 5).toFixed(1)}/GW avg</div>
                        </div>
                        
                        ${team2Analysis ? `
                            <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Fixture Strength</div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-amber);">${team2Analysis.avgWeightedPerGW?.toFixed(1) || team2Analysis.avgEasyPerGW.toFixed(1)}</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            
            // === POSITION STRENGTH COMPARISON ===
            html += `
                <div style="margin-top: 2rem; background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px;">
                    <h4 style="color: var(--accent-violet); margin-bottom: 1rem; font-size: 1rem;">💪 Position Strength (Avg Form)</h4>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
            `;
            
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const t1Val = team1Strength[pos];
                const t2Val = team2Strength[pos];
                const t1Count = team1Strength.counts[pos];
                const t2Count = team2Strength.counts[pos];
                const winner = t1Val > t2Val ? 'cyan' : (t2Val > t1Val ? 'rose' : 'amber');
                const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
                
                html += `
                    <div style="text-align: center; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-top: 3px solid ${posColors[pos]};">
                        <div style="font-size: 0.75rem; font-weight: 600; color: ${posColors[pos]}; margin-bottom: 0.5rem;">${pos}</div>
                        <div style="display: flex; justify-content: center; gap: 1rem; align-items: center;">
                            <div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-cyan);">${t1Val.toFixed(1)}</div>
                                <div style="font-size: 0.65rem; color: var(--text-muted);">(${t1Count})</div>
                            </div>
                            <div style="color: var(--accent-${winner}); font-size: 1.2rem;">${t1Val > t2Val ? '>' : (t2Val > t1Val ? '<' : '=')}</div>
                            <div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-rose);">${t2Val.toFixed(1)}</div>
                                <div style="font-size: 0.65rem; color: var(--text-muted);">(${t2Count})</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            
            // === SQUAD COMPARISON BY POSITION (with fixture difficulty) ===
            html += `
                <div style="margin-top: 2rem; background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px;">
                    <h4 style="color: var(--accent-emerald); margin-bottom: 1rem; font-size: 1rem;">📋 Squad Comparison (GW${currentGW}-${Math.min(currentGW + 4, 38)} Fixtures)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
            `;
            
            // Team 1 squad
            html += `<div>`;
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const posPlayers = team1Predictions.filter(p => p.player.position === pos);
                const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
                
                html += `<div style="margin-bottom: 1rem;"><div style="font-size: 0.75rem; font-weight: 600; color: ${posColors[pos]}; margin-bottom: 0.5rem;">${pos}</div>`;
                
                posPlayers.sort((a, b) => b.total - a.total).forEach(({ player, total, perGW }) => {
                    html += `
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; font-size: 0.8rem;">
                            <span style="flex: 1; color: var(--text-primary);">${player.name}</span>
                            <span style="color: var(--text-muted); font-size: 0.7rem;">${player.team}</span>
                            <div style="display: flex; gap: 2px;">
                                ${perGW.slice(0, 5).map(g => {
                                    const bg = g.difficulty === 'easy' ? '#10b981' : (g.difficulty === 'hard' ? '#ef4444' : '#f59e0b');
                                    return `<div style="width: 18px; height: 18px; background: ${bg}; border-radius: 3px; font-size: 0.6rem; display: flex; align-items: center; justify-content: center; color: #000; font-weight: 600;" title="GW${g.gw}: ${g.predicted}pts">${g.predicted.toFixed(0)}</div>`;
                                }).join('')}
                            </div>
                            <span style="font-weight: 600; color: var(--accent-cyan); min-width: 35px; text-align: right;">${total.toFixed(0)}</span>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            html += '</div>';
            
            // Team 2 squad
            html += `<div>`;
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                const posPlayers = team2Predictions.filter(p => p.player.position === pos);
                const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
                
                html += `<div style="margin-bottom: 1rem;"><div style="font-size: 0.75rem; font-weight: 600; color: ${posColors[pos]}; margin-bottom: 0.5rem;">${pos}</div>`;
                
                posPlayers.sort((a, b) => b.total - a.total).forEach(({ player, total, perGW }) => {
                    html += `
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; font-size: 0.8rem;">
                            <span style="flex: 1; color: var(--text-primary);">${player.name}</span>
                            <span style="color: var(--text-muted); font-size: 0.7rem;">${player.team}</span>
                            <div style="display: flex; gap: 2px;">
                                ${perGW.slice(0, 5).map(g => {
                                    const bg = g.difficulty === 'easy' ? '#10b981' : (g.difficulty === 'hard' ? '#ef4444' : '#f59e0b');
                                    return `<div style="width: 18px; height: 18px; background: ${bg}; border-radius: 3px; font-size: 0.6rem; display: flex; align-items: center; justify-content: center; color: #000; font-weight: 600;" title="GW${g.gw}: ${g.predicted}pts">${g.predicted.toFixed(0)}</div>`;
                                }).join('')}
                            </div>
                            <span style="font-weight: 600; color: var(--accent-rose); min-width: 35px; text-align: right;">${total.toFixed(0)}</span>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            html += '</div>';
            
            html += '</div></div>';
            
            // Helper function to render fixture boxes for a player
            const renderPlayerFixtures = (player, numGWs = 5) => {
                let fixturesHtml = '';
                let easyCount = 0;
                for (let i = 0; i < numGWs; i++) {
                    const gw = currentGW + i;
                    if (gw > 38) break;
                    const diff = getFixtureDifficulty(player.team, gw);
                    if (diff === 'easy') easyCount++;
                    const bg = diff === 'easy' ? '#10b981' : (diff === 'hard' ? '#ef4444' : '#f59e0b');
                    const pred = calculatePlayerGWPoints(player, gw);
                    fixturesHtml += `<div style="width: 20px; height: 20px; background: ${bg}; border-radius: 3px; font-size: 0.6rem; display: flex; align-items: center; justify-content: center; color: #000; font-weight: 600;" title="GW${gw}: ${pred.toFixed(1)}pts">${pred.toFixed(0)}</div>`;
                }
                return { html: fixturesHtml, easyCount };
            };
            
            // === TRADE SUGGESTIONS (Enhanced) ===
            if (tradeSuggestions.length > 0) {
                html += `
                    <div style="margin-top: 2rem; background: linear-gradient(135deg, rgba(245,158,11,0.1), rgba(139,92,246,0.1)); padding: 1.5rem; border-radius: 12px; border: 1px solid var(--accent-amber);">
                        <h4 style="color: var(--accent-amber); margin-bottom: 0.5rem; font-size: 1rem;">🤝 Win-Win Trade Suggestions</h4>
                        <p style="color: var(--text-muted); font-size: 0.75rem; margin-bottom: 1rem;">Based on fixture analysis for GW${currentGW}-${Math.min(currentGW + 4, 38)}</p>
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                `;
                
                tradeSuggestions.forEach((trade, idx) => {
                    const typeLabel = trade.type === '1-for-1' ? '1️⃣' : (trade.type === '2-for-2' ? '2️⃣' : '🔄');
                    const typeBadge = trade.type === '2-for-2' ? 'Batch Trade' : (trade.type === 'cross-position' ? 'Position Swap' : 'Direct Swap');
                    
                    // Calculate totals for each side
                    const t1GetsTotal = trade.team1Gets.reduce((sum, p) => {
                        let pts = 0;
                        for (let i = 0; i < 5; i++) {
                            const gw = currentGW + i;
                            if (gw > 38) break;
                            pts += calculatePlayerGWPoints(p, gw);
                        }
                        return sum + pts;
                    }, 0);
                    
                    const t2GetsTotal = trade.team2Gets.reduce((sum, p) => {
                        let pts = 0;
                        for (let i = 0; i < 5; i++) {
                            const gw = currentGW + i;
                            if (gw > 38) break;
                            pts += calculatePlayerGWPoints(p, gw);
                        }
                        return sum + pts;
                    }, 0);
                    
                    html += `
                        <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                                <span style="font-size: 1.2rem;">${typeLabel}</span>
                                <span style="background: var(--accent-amber); color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600;">${typeBadge}</span>
                                <span style="font-size: 0.75rem; color: var(--text-muted);">Trade #${idx + 1}</span>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 1rem; align-items: start;">
                                <div>
                                    <div style="font-size: 0.7rem; color: var(--accent-cyan); margin-bottom: 0.5rem;">${team1Entry.entry_name} receives:</div>
                                    ${trade.team1Gets.map(p => {
                                        const fixtures = renderPlayerFixtures(p);
                                        return `
                                            <div style="background: var(--bg-secondary); padding: 0.5rem; border-radius: 4px; margin-bottom: 0.35rem;">
                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                                                    <span style="font-weight: 600; font-size: 0.85rem;">${p.name}</span>
                                                    <span style="color: var(--accent-emerald); font-size: 0.7rem; font-weight: 600;">${fixtures.easyCount} easy</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <span style="color: var(--text-muted); font-size: 0.7rem;">${p.team} · ${p.position} · Form: ${p.form.toFixed(1)}</span>
                                                </div>
                                                <div style="display: flex; gap: 2px; margin-top: 0.35rem;">${fixtures.html}</div>
                                            </div>
                                        `;
                                    }).join('')}
                                    <div style="text-align: right; font-size: 0.75rem; color: var(--accent-cyan); margin-top: 0.5rem;">
                                        📊 5GW Total: <strong>${t1GetsTotal.toFixed(0)}pts</strong>
                                    </div>
                                </div>
                                
                                <div style="display: flex; flex-direction: column; align-items: center; padding-top: 1rem;">
                                    <div style="font-size: 1.5rem; color: var(--accent-amber);">⇄</div>
                                </div>
                                
                                <div>
                                    <div style="font-size: 0.7rem; color: var(--accent-rose); margin-bottom: 0.5rem;">${team2Entry.entry_name} receives:</div>
                                    ${trade.team2Gets.map(p => {
                                        const fixtures = renderPlayerFixtures(p);
                                        return `
                                            <div style="background: var(--bg-secondary); padding: 0.5rem; border-radius: 4px; margin-bottom: 0.35rem;">
                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                                                    <span style="font-weight: 600; font-size: 0.85rem;">${p.name}</span>
                                                    <span style="color: var(--accent-emerald); font-size: 0.7rem; font-weight: 600;">${fixtures.easyCount} easy</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <span style="color: var(--text-muted); font-size: 0.7rem;">${p.team} · ${p.position} · Form: ${p.form.toFixed(1)}</span>
                                                </div>
                                                <div style="display: flex; gap: 2px; margin-top: 0.35rem;">${fixtures.html}</div>
                                            </div>
                                        `;
                                    }).join('')}
                                    <div style="text-align: right; font-size: 0.75rem; color: var(--accent-rose); margin-top: 0.5rem;">
                                        📊 5GW Total: <strong>${t2GetsTotal.toFixed(0)}pts</strong>
                                    </div>
                                </div>
                            </div>
                            
                            <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(245,158,11,0.1); border-radius: 4px; font-size: 0.75rem; color: var(--text-secondary);">
                                💡 ${trade.reason}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            }
            
            // === INTERACTIVE TRADE BUILDER ===
            // Store players globally for the trade builder
            window.h2hTeam1Players = team1Players;
            window.h2hTeam2Players = team2Players;
            window.h2hTeam1Entry = team1Entry;
            window.h2hTeam2Entry = team2Entry;
            window.h2hCurrentGW = currentGW;
            
            html += `
                <div style="margin-top: 2rem; background: linear-gradient(135deg, rgba(34,211,238,0.1), rgba(244,63,94,0.1)); padding: 1.5rem; border-radius: 12px; border: 1px solid var(--accent-violet);">
                    <h4 style="color: var(--accent-violet); margin-bottom: 0.5rem; font-size: 1rem;">🔧 Trade Builder</h4>
                    <p style="color: var(--text-muted); font-size: 0.75rem; margin-bottom: 1rem;">Select players you want to trade away, and get suggestions for fair returns</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <!-- Team 1 players to offer -->
                        <div>
                            <div style="font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 0.75rem;">
                                Select from ${team1Entry.entry_name}:
                            </div>
                            <div style="max-height: 300px; overflow-y: auto; background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                ${team1Players.sort((a, b) => {
                                    const posOrder = { GK: 0, DEF: 1, MID: 2, FWD: 3 };
                                    return (posOrder[a.position] || 4) - (posOrder[b.position] || 4);
                                }).map(p => {
                                    const fixtures = renderPlayerFixtures(p);
                                    const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
                                    return `
                                        <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.35rem; cursor: pointer; border-left: 3px solid ${posColors[p.position] || '#666'};">
                                            <input type="checkbox" class="trade-builder-t1" value="${p.id}" style="accent-color: var(--accent-cyan);">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; font-size: 0.8rem;">${p.name}</div>
                                                <div style="font-size: 0.65rem; color: var(--text-muted);">${p.team} · ${p.position} · Form: ${p.form.toFixed(1)} · ${fixtures.easyCount} easy</div>
                                            </div>
                                            <div style="display: flex; gap: 1px;">${fixtures.html}</div>
                                        </label>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                        
                        <!-- Team 2 players to offer -->
                        <div>
                            <div style="font-size: 0.8rem; color: var(--accent-rose); margin-bottom: 0.75rem;">
                                Select from ${team2Entry.entry_name}:
                            </div>
                            <div style="max-height: 300px; overflow-y: auto; background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                ${team2Players.sort((a, b) => {
                                    const posOrder = { GK: 0, DEF: 1, MID: 2, FWD: 3 };
                                    return (posOrder[a.position] || 4) - (posOrder[b.position] || 4);
                                }).map(p => {
                                    const fixtures = renderPlayerFixtures(p);
                                    const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
                                    return `
                                        <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.35rem; cursor: pointer; border-left: 3px solid ${posColors[p.position] || '#666'};">
                                            <input type="checkbox" class="trade-builder-t2" value="${p.id}" style="accent-color: var(--accent-rose);">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; font-size: 0.8rem;">${p.name}</div>
                                                <div style="font-size: 0.65rem; color: var(--text-muted);">${p.team} · ${p.position} · Form: ${p.form.toFixed(1)} · ${fixtures.easyCount} easy</div>
                                            </div>
                                            <div style="display: flex; gap: 1px;">${fixtures.html}</div>
                                        </label>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1rem; text-align: center;">
                        <button onclick="analyzeTradeBuilder()" style="padding: 0.75rem 2rem; background: var(--accent-violet); font-size: 0.9rem;">
                            🔍 Analyze Trade & Suggest Returns
                        </button>
                    </div>
                    
                    <div id="tradeBuilderResults" style="margin-top: 1rem;"></div>
                </div>
            `;
            
            // === TEAM COVERAGE ===
            html += `
                <div style="margin-top: 2rem; background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px;">
                    <h4 style="color: var(--accent-cyan); margin-bottom: 1rem; font-size: 1rem;">🏟️ Team Coverage</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <div style="font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 0.5rem;">${team1Entry.entry_name} (${team1Teams.length} teams)</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">
                                ${team1Teams.map(t => {
                                    const isShared = sharedTeams.includes(t);
                                    return `<span style="padding: 0.25rem 0.5rem; background: ${isShared ? 'var(--accent-amber)' : 'var(--bg-secondary)'}; color: ${isShared ? '#000' : 'var(--text-primary)'}; border-radius: 4px; font-size: 0.7rem;">${t}</span>`;
                                }).join('')}
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: var(--accent-rose); margin-bottom: 0.5rem;">${team2Entry.entry_name} (${team2Teams.length} teams)</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.35rem;">
                                ${team2Teams.map(t => {
                                    const isShared = sharedTeams.includes(t);
                                    return `<span style="padding: 0.25rem 0.5rem; background: ${isShared ? 'var(--accent-amber)' : 'var(--bg-secondary)'}; color: ${isShared ? '#000' : 'var(--text-primary)'}; border-radius: 4px; font-size: 0.7rem;">${t}</span>`;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; font-size: 0.75rem; color: var(--text-muted);">
                        <span style="background: var(--accent-amber); color: #000; padding: 0.15rem 0.4rem; border-radius: 3px;">Highlighted</span> = Shared team coverage (${sharedTeams.length} teams)
                    </div>
                </div>
            `;
            
            // === PREDICTED POINTS PER GW CHART (OPTIMAL 11) ===
            html += `
                <div style="margin-top: 2rem; background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px;">
                    <h4 style="color: var(--accent-emerald); margin-bottom: 0.5rem; font-size: 1rem;">📈 Predicted Points by Gameweek (Best XI)</h4>
                    <p style="color: var(--text-muted); font-size: 0.75rem; margin-bottom: 1rem;">Optimal 11 selected per GW • Formation: 1 GK, 3-5 DEF, 2-5 MID, 1-3 FWD</p>
                    <div style="display: flex; gap: 0.5rem; overflow-x: auto; padding-bottom: 0.5rem;">
            `;
            
            for (let i = 0; i < 5; i++) {
                const t1GW = team1Optimal.perGW[i];
                const t2GW = team2Optimal.perGW[i];
                
                if (!t1GW || !t2GW) break;
                
                const gw = t1GW.gw;
                const t1GWPts = t1GW.points;
                const t2GWPts = t2GW.points;
                const t1Formation = t1GW.formation;
                const t2Formation = t2GW.formation;
                
                const winner = t1GWPts > t2GWPts ? 'cyan' : (t2GWPts > t1GWPts ? 'rose' : 'amber');
                const maxPts = Math.max(t1GWPts, t2GWPts, 60);
                const t1Height = (t1GWPts / maxPts) * 80;
                const t2Height = (t2GWPts / maxPts) * 80;
                
                html += `
                    <div style="flex: 1; min-width: 90px; text-align: center; background: var(--bg-secondary); padding: 1rem 0.5rem; border-radius: 8px; border-top: 3px solid var(--accent-${winner});">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">GW${gw}</div>
                        <div style="display: flex; justify-content: center; gap: 0.5rem; align-items: flex-end; height: 80px;">
                            <div style="width: 25px; height: ${t1Height}px; background: var(--accent-cyan); border-radius: 3px 3px 0 0;" title="${t1Formation}"></div>
                            <div style="width: 25px; height: ${t2Height}px; background: var(--accent-rose); border-radius: 3px 3px 0 0;" title="${t2Formation}"></div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 0.5rem;">
                            <div style="font-size: 0.75rem; font-weight: 600; color: var(--accent-cyan);">${t1GWPts.toFixed(0)}</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: var(--accent-rose);">${t2GWPts.toFixed(0)}</div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 0.25rem; margin-top: 0.25rem;">
                            <div style="font-size: 0.6rem; color: var(--accent-cyan);">${t1Formation}</div>
                            <div style="font-size: 0.6rem; color: var(--text-muted);">|</div>
                            <div style="font-size: 0.6rem; color: var(--accent-rose);">${t2Formation}</div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div></div>';
            
            // === DIFFERENTIAL PLAYERS ===
            const team1Only = team1Players.filter(p => !team2Players.some(p2 => p2.name === p.name));
            const team2Only = team2Players.filter(p => !team1Players.some(p1 => p1.name === p.name));
            
            // Sort by form
            team1Only.sort((a, b) => b.form - a.form);
            team2Only.sort((a, b) => b.form - a.form);
            
            html += `
                <div style="margin-top: 2rem; background: var(--bg-tertiary); padding: 1.5rem; border-radius: 12px;">
                    <h4 style="color: var(--accent-violet); margin-bottom: 1rem; font-size: 1rem;">🎯 Key Differentials (Top 5 Unique Players by Form)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <div style="font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 0.75rem;">${team1Entry.entry_name} Only</div>
                            ${team1Only.slice(0, 5).map(p => `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.35rem;">
                                    <div>
                                        <span style="font-weight: 600; font-size: 0.85rem;">${p.name}</span>
                                        <span style="color: var(--text-muted); font-size: 0.7rem;"> · ${p.team} · ${p.position}</span>
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <span style="font-size: 0.7rem; color: var(--text-muted);">Form:</span>
                                        <span style="font-weight: 700; color: ${p.form >= 5 ? 'var(--accent-emerald)' : 'var(--text-primary)'};">${p.form.toFixed(1)}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: var(--accent-rose); margin-bottom: 0.75rem;">${team2Entry.entry_name} Only</div>
                            ${team2Only.slice(0, 5).map(p => `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.35rem;">
                                    <div>
                                        <span style="font-weight: 600; font-size: 0.85rem;">${p.name}</span>
                                        <span style="color: var(--text-muted); font-size: 0.7rem;"> · ${p.team} · ${p.position}</span>
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <span style="font-size: 0.7rem; color: var(--text-muted);">Form:</span>
                                        <span style="font-weight: 700; color: ${p.form >= 5 ? 'var(--accent-emerald)' : 'var(--text-primary)'};">${p.form.toFixed(1)}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            // Add fixture comparison if both have analysis (legacy view)
            if (team1Analysis && team2Analysis) {
                html += `
                    <div style="margin-top: 2rem;">
                        <h4 style="color: var(--text-secondary); margin-bottom: 1rem; font-size: 0.9rem;">📅 Easy Games by Gameweek (Full Season)</h4>
                        <div style="display: flex; gap: 0.25rem; overflow-x: auto; padding-bottom: 0.5rem;">
                `;
                
                const startGW = getCurrentGameweek();
                for (let gw = startGW; gw <= 38; gw++) {
                    const t1Easy = team1Analysis.easyPerGW[gw] || 0;
                    const t2Easy = team2Analysis.easyPerGW[gw] || 0;
                    const winner = t1Easy > t2Easy ? 'cyan' : (t2Easy > t1Easy ? 'rose' : 'amber');
                    
                    html += `
                        <div style="background: var(--bg-tertiary); padding: 0.5rem 0.3rem; border-radius: 4px; min-width: 40px; text-align: center; border-top: 2px solid var(--accent-${winner});">
                            <div style="font-size: 0.65rem; color: var(--text-muted);">GW${gw}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-cyan);">${t1Easy}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-rose);">${t2Easy}</div>
                        </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            document.getElementById('h2hResults').innerHTML = html;
        }
        
        // Trade Builder Analysis Function
        function analyzeTradeBuilder() {
            const t1Selected = Array.from(document.querySelectorAll('.trade-builder-t1:checked')).map(cb => parseInt(cb.value));
            const t2Selected = Array.from(document.querySelectorAll('.trade-builder-t2:checked')).map(cb => parseInt(cb.value));
            
            const resultsDiv = document.getElementById('tradeBuilderResults');
            
            if (t1Selected.length === 0 && t2Selected.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 1rem; color: var(--accent-amber);">
                        ⚠️ Select at least one player from either team to analyze
                    </div>
                `;
                return;
            }
            
            const team1Players = window.h2hTeam1Players || [];
            const team2Players = window.h2hTeam2Players || [];
            const team1Entry = window.h2hTeam1Entry || {};
            const team2Entry = window.h2hTeam2Entry || {};
            const currentGW = window.h2hCurrentGW || getCurrentGameweek();
            
            // Get selected players
            const t1SelectedPlayers = team1Players.filter(p => t1Selected.includes(p.id));
            const t2SelectedPlayers = team2Players.filter(p => t2Selected.includes(p.id));
            
            // Calculate value of selected players (predicted points over 5 GWs)
            const calcPlayerValue = (player) => {
                let value = 0;
                let easyGames = 0;
                for (let i = 0; i < 5; i++) {
                    const gw = currentGW + i;
                    if (gw > 38) break;
                    value += calculatePlayerGWPoints(player, gw);
                    if (getFixtureDifficulty(player.team, gw) === 'easy') easyGames++;
                }
                return { value: Math.round(value * 10) / 10, easyGames, form: player.form };
            };
            
            // Calculate total value of selected players from each team
            const t1TotalValue = t1SelectedPlayers.reduce((sum, p) => sum + calcPlayerValue(p).value, 0);
            const t2TotalValue = t2SelectedPlayers.reduce((sum, p) => sum + calcPlayerValue(p).value, 0);
            
            // Get positions of selected players
            const t1Positions = t1SelectedPlayers.map(p => p.position);
            const t2Positions = t2SelectedPlayers.map(p => p.position);
            
            // Find fair trade suggestions
            let html = `
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                    <h5 style="color: var(--accent-violet); margin-bottom: 1rem;">📊 Trade Analysis</h5>
            `;
            
            // Show selected players summary
            if (t1SelectedPlayers.length > 0) {
                html += `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 0.5rem;">
                            ${team1Entry.entry_name} offers (${t1SelectedPlayers.length} player${t1SelectedPlayers.length > 1 ? 's' : ''}):
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            ${t1SelectedPlayers.map(p => {
                                const val = calcPlayerValue(p);
                                return `
                                    <div style="background: var(--bg-secondary); padding: 0.5rem 0.75rem; border-radius: 6px; font-size: 0.8rem;">
                                        <strong>${p.name}</strong> 
                                        <span style="color: var(--text-muted);">(${p.position})</span>
                                        <span style="color: var(--accent-emerald);">~${val.value.toFixed(0)}pts</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div style="font-size: 0.75rem; color: var(--accent-cyan); margin-top: 0.5rem;">
                            Total 5GW Value: <strong>${t1TotalValue.toFixed(0)} pts</strong>
                        </div>
                    </div>
                `;
            }
            
            if (t2SelectedPlayers.length > 0) {
                html += `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.8rem; color: var(--accent-rose); margin-bottom: 0.5rem;">
                            ${team2Entry.entry_name} offers (${t2SelectedPlayers.length} player${t2SelectedPlayers.length > 1 ? 's' : ''}):
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            ${t2SelectedPlayers.map(p => {
                                const val = calcPlayerValue(p);
                                return `
                                    <div style="background: var(--bg-secondary); padding: 0.5rem 0.75rem; border-radius: 6px; font-size: 0.8rem;">
                                        <strong>${p.name}</strong> 
                                        <span style="color: var(--text-muted);">(${p.position})</span>
                                        <span style="color: var(--accent-emerald);">~${val.value.toFixed(0)}pts</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div style="font-size: 0.75rem; color: var(--accent-rose); margin-top: 0.5rem;">
                            Total 5GW Value: <strong>${t2TotalValue.toFixed(0)} pts</strong>
                        </div>
                    </div>
                `;
            }
            
            // Suggest fair returns
            html += `<hr style="border-color: var(--border-color); margin: 1rem 0;">`;
            html += `<h5 style="color: var(--accent-amber); margin-bottom: 1rem;">💡 Suggested Fair Returns</h5>`;
            
            // If Team 1 is offering players, suggest what Team 2 could give
            if (t1SelectedPlayers.length > 0 && team2Players.length > 0) {
                const targetValue = t1TotalValue;
                const targetPositions = t1Positions;
                const availableT2 = team2Players.filter(p => !t2Selected.includes(p.id));
                
                // Find best combinations that match the value
                const suggestions = findFairReturnSuggestions(availableT2, targetValue, targetPositions, t1SelectedPlayers.length, currentGW);
                
                html += `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.8rem; color: var(--accent-rose); margin-bottom: 0.75rem;">
                            🎯 ${team2Entry.entry_name} could offer in return (target ~${targetValue.toFixed(0)}pts):
                        </div>
                `;
                
                if (suggestions.length > 0) {
                    suggestions.forEach((sug, idx) => {
                        const diff = sug.totalValue - targetValue;
                        const diffColor = Math.abs(diff) < 5 ? 'var(--accent-emerald)' : (diff > 0 ? 'var(--accent-cyan)' : 'var(--accent-rose)');
                        const diffLabel = diff >= 0 ? `+${diff.toFixed(0)}` : diff.toFixed(0);
                        
                        html += `
                            <div style="background: var(--bg-secondary); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.5rem; border-left: 3px solid ${idx === 0 ? 'var(--accent-emerald)' : 'var(--border-color)'};">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                    <span style="font-size: 0.75rem; color: var(--text-muted);">Option ${idx + 1}${idx === 0 ? ' (Best Match)' : ''}</span>
                                    <span style="font-size: 0.75rem; color: ${diffColor};">${sug.totalValue.toFixed(0)}pts (${diffLabel})</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                    ${sug.players.map(p => {
                                        const val = calcPlayerValue(p);
                                        const diffStr = getFixtureDifficulty(p.team, currentGW);
                                        const diffColor = diffStr === 'easy' ? '#10b981' : (diffStr === 'hard' ? '#ef4444' : '#f59e0b');
                                        return `
                                            <div style="background: var(--bg-tertiary); padding: 0.4rem 0.6rem; border-radius: 4px; font-size: 0.75rem; border-left: 2px solid ${diffColor};">
                                                <strong>${p.name}</strong>
                                                <span style="color: var(--text-muted);">${p.team} · ${p.position}</span>
                                                <span style="color: var(--accent-emerald);">${val.value.toFixed(0)}pts · ${val.easyGames} easy</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += `<div style="color: var(--text-muted); font-size: 0.8rem;">No suitable matches found</div>`;
                }
                
                html += `</div>`;
            }
            
            // If Team 2 is offering players, suggest what Team 1 could give
            if (t2SelectedPlayers.length > 0 && team1Players.length > 0) {
                const targetValue = t2TotalValue;
                const targetPositions = t2Positions;
                const availableT1 = team1Players.filter(p => !t1Selected.includes(p.id));
                
                const suggestions = findFairReturnSuggestions(availableT1, targetValue, targetPositions, t2SelectedPlayers.length, currentGW);
                
                html += `
                    <div style="margin-bottom: 1rem;">
                        <div style="font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 0.75rem;">
                            🎯 ${team1Entry.entry_name} could offer in return (target ~${targetValue.toFixed(0)}pts):
                        </div>
                `;
                
                if (suggestions.length > 0) {
                    suggestions.forEach((sug, idx) => {
                        const diff = sug.totalValue - targetValue;
                        const diffColor = Math.abs(diff) < 5 ? 'var(--accent-emerald)' : (diff > 0 ? 'var(--accent-cyan)' : 'var(--accent-rose)');
                        const diffLabel = diff >= 0 ? `+${diff.toFixed(0)}` : diff.toFixed(0);
                        
                        html += `
                            <div style="background: var(--bg-secondary); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.5rem; border-left: 3px solid ${idx === 0 ? 'var(--accent-emerald)' : 'var(--border-color)'};">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                    <span style="font-size: 0.75rem; color: var(--text-muted);">Option ${idx + 1}${idx === 0 ? ' (Best Match)' : ''}</span>
                                    <span style="font-size: 0.75rem; color: ${diffColor};">${sug.totalValue.toFixed(0)}pts (${diffLabel})</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                    ${sug.players.map(p => {
                                        const val = calcPlayerValue(p);
                                        const diffStr = getFixtureDifficulty(p.team, currentGW);
                                        const diffColor = diffStr === 'easy' ? '#10b981' : (diffStr === 'hard' ? '#ef4444' : '#f59e0b');
                                        return `
                                            <div style="background: var(--bg-tertiary); padding: 0.4rem 0.6rem; border-radius: 4px; font-size: 0.75rem; border-left: 2px solid ${diffColor};">
                                                <strong>${p.name}</strong>
                                                <span style="color: var(--text-muted);">${p.team} · ${p.position}</span>
                                                <span style="color: var(--accent-emerald);">${val.value.toFixed(0)}pts · ${val.easyGames} easy</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += `<div style="color: var(--text-muted); font-size: 0.8rem;">No suitable matches found</div>`;
                }
                
                html += `</div>`;
            }
            
            html += `</div>`;
            resultsDiv.innerHTML = html;
        }
        
        // Helper function to find fair return suggestions
        function findFairReturnSuggestions(availablePlayers, targetValue, targetPositions, targetCount, currentGW) {
            const suggestions = [];
            const tolerance = targetValue * 0.25; // 25% tolerance
            
            // Calculate value for each available player
            const playersWithValue = availablePlayers.map(p => {
                let value = 0;
                let easyGames = 0;
                for (let i = 0; i < 5; i++) {
                    const gw = currentGW + i;
                    if (gw > 38) break;
                    value += calculatePlayerGWPoints(p, gw);
                    if (getFixtureDifficulty(p.team, gw) === 'easy') easyGames++;
                }
                return { ...p, value: Math.round(value * 10) / 10, easyGames };
            }).sort((a, b) => b.value - a.value);
            
            // Try single player matches
            if (targetCount === 1) {
                playersWithValue.forEach(p => {
                    if (Math.abs(p.value - targetValue) <= tolerance) {
                        suggestions.push({
                            players: [p],
                            totalValue: p.value,
                            diff: Math.abs(p.value - targetValue)
                        });
                    }
                });
            }
            
            // Try 2-player combinations
            if (targetCount <= 2) {
                for (let i = 0; i < playersWithValue.length; i++) {
                    for (let j = i + 1; j < playersWithValue.length; j++) {
                        const combo = [playersWithValue[i], playersWithValue[j]];
                        const totalValue = combo.reduce((s, p) => s + p.value, 0);
                        if (Math.abs(totalValue - targetValue) <= tolerance) {
                            suggestions.push({
                                players: combo,
                                totalValue,
                                diff: Math.abs(totalValue - targetValue)
                            });
                        }
                    }
                }
            }
            
            // Try 3-player combinations (if offering 2+ players)
            if (targetCount >= 2 && playersWithValue.length >= 3) {
                for (let i = 0; i < Math.min(playersWithValue.length, 10); i++) {
                    for (let j = i + 1; j < Math.min(playersWithValue.length, 12); j++) {
                        for (let k = j + 1; k < Math.min(playersWithValue.length, 14); k++) {
                            const combo = [playersWithValue[i], playersWithValue[j], playersWithValue[k]];
                            const totalValue = combo.reduce((s, p) => s + p.value, 0);
                            if (Math.abs(totalValue - targetValue) <= tolerance) {
                                suggestions.push({
                                    players: combo,
                                    totalValue,
                                    diff: Math.abs(totalValue - targetValue)
                                });
                            }
                        }
                    }
                }
            }
            
            // Sort by closest to target value and limit results
            return suggestions
                .sort((a, b) => a.diff - b.diff)
                .slice(0, 4);
        }
        
        // ============================================
        // PREDICTIONS TAB FUNCTIONS
        // ============================================
        
        // ============================================
        // BATCH-BASED PREDICTION ENGINE
        // ============================================
        
        // Configuration for batch system
        const BATCH_CONFIG = {
            batches: [
                { id: 1, name: 'Top (1-4)', minRank: 1, maxRank: 4 },
                { id: 2, name: 'Upper Mid (5-8)', minRank: 5, maxRank: 8 },
                { id: 3, name: 'Mid Table (9-12)', minRank: 9, maxRank: 12 },
                { id: 4, name: 'Lower Mid (13-16)', minRank: 13, maxRank: 16 },
                { id: 5, name: 'Bottom (17-20)', minRank: 17, maxRank: 20 }
            ],
            minMinutesForInclusion: 10,
            minMinutesForDefensiveStats: 45,
            bayesianPriorWeight: 3, // Equivalent games for small sample blending
            fplScoringRules: {
                goalGK: 6, goalDEF: 6, goalMID: 5, goalFWD: 4,
                assist: 3,
                cleanSheetGK: 4, cleanSheetDEF: 4, cleanSheetMID: 1,
                savesPerPoint: 3,
                goalsConcededPenalty: -1, // Per 2 goals conceded
                yellowCard: -1,
                redCard: -3,
                bonus1: 1, bonus2: 2, bonus3: 3,
                minutes1to59: 1, minutes60plus: 2
            }
        };
        
        // Store computed batch data
        let batchAnalysisCache = {
            teamBatchMap: {},      // teamId -> batchId
            teamStats: {},         // teamId -> { vsBatch: { goals, conceded, cs, games } }
            playerStats: {},       // playerId -> { vsBatch: { goals, assists, defcon, bonus, cards, games } }
            leagueAverages: {},    // League-wide averages for cross-reference
            plStandings: [],       // Real or calculated PL standings
            standingsSource: null, // 'api', 'bootstrap', or 'calculated'
            teamVenueStats: {},    // teamId -> { home: {gf, ga, games}, away: {gf, ga, games} }
            venueLeagueAvg: null,  // { homeGF, homeGA, awayGF, awayGA } - league averages per game
            lastComputed: null
        };
        
        // Fetch REAL PL standings from FPL API
        async function fetchRealPLStandings() {
            console.log('[Standings] Fetching real PL standings from FPL API...');
            
            // Try multiple methods due to CORS
            const urls = [
                'https://fantasy.premierleague.com/api/bootstrap-static/',
                // CORS proxies as fallback
                'https://corsproxy.io/?https://fantasy.premierleague.com/api/bootstrap-static/',
                'https://api.allorigins.win/raw?url=https://fantasy.premierleague.com/api/bootstrap-static/'
            ];
            
            for (const url of urls) {
                try {
                    console.log('[Standings] Trying:', url.substring(0, 50) + '...');
                    const response = await fetch(url);
                    if (!response.ok) continue;
                    
                    const data = await response.json();
                    const teams = data.teams || [];
                    
                    if (!teams.length) continue;
                    
                    // Check if we have actual standings data
                    const hasStandingsData = teams.some(t => 
                        (t.win !== undefined && t.win > 0) || (t.points !== undefined && t.points > 0)
                    );
                    
                    if (!hasStandingsData) {
                        console.warn('[Standings] API has teams but no standings data');
                        continue;
                    }
                    
                    // Build standings from API data
                    const standings = teams.map(t => ({
                        id: t.id,
                        name: t.name,
                        short_name: t.short_name,
                        position: t.position || 0,
                        played: t.played || 0,
                        wins: t.win || 0,
                        draws: t.draw || 0,
                        losses: t.loss || 0,
                        goalsFor: t.goals_for || t.team_goals_for || 0,
                        goalsAgainst: t.goals_against || t.team_goals_against || 0,
                        goalDiff: (t.goals_for || 0) - (t.goals_against || 0),
                        points: t.points || 0,
                        cleanSheets: 0,
                        games: t.played || 0
                    }));
                    
                    // Sort by points
                    standings.sort((a, b) => {
                        if (b.points !== a.points) return b.points - a.points;
                        if (b.goalDiff !== a.goalDiff) return b.goalDiff - a.goalDiff;
                        return b.goalsFor - a.goalsFor;
                    });
                    
                    standings.forEach((t, idx) => t.position = idx + 1);
                    
                    console.log('[Standings] ✅ Fetched real standings:', standings.slice(0, 5).map(t => `${t.position}. ${t.short_name} (${t.points}pts)`));
                    
                    batchAnalysisCache.plStandings = standings;
                    batchAnalysisCache.standingsSource = 'api';
                    return standings;
                    
                } catch (error) {
                    console.warn('[Standings] Failed with', url.substring(0, 30), ':', error.message);
                }
            }
            
            console.error('[Standings] ❌ All fetch methods failed');
            return null;
        }
        
        // Try to get standings from imported data (plStandings field or bootstrap.teams)
        function getStandingsFromImportedData() {
            console.log('[Standings] Checking imported data for standings...');
            
            // First check for plStandings field (from bookmarklet)
            if (window.importedPLStandings && window.importedPLStandings.length > 0) {
                const hasPoints = window.importedPLStandings.some(t => t.points > 0);
                if (hasPoints) {
                    const standings = window.importedPLStandings.map(t => ({
                        id: t.id,
                        name: t.name,
                        short_name: t.short_name,
                        position: t.position || 0,
                        played: t.played || t.games || 0,
                        wins: t.win || t.wins || 0,
                        draws: t.draw || t.draws || 0,
                        losses: t.loss || t.losses || 0,
                        // Check both snake_case and camelCase
                        goalsFor: t.goals_for || t.goalsFor || 0,
                        goalsAgainst: t.goals_against || t.goalsAgainst || 0,
                        goalDiff: t.goal_difference || t.goalDiff || ((t.goals_for || t.goalsFor || 0) - (t.goals_against || t.goalsAgainst || 0)),
                        points: t.points || 0,
                        cleanSheets: t.cleanSheets || 0,
                        games: t.played || t.games || 0
                    }));
                    
                    standings.sort((a, b) => {
                        if (b.points !== a.points) return b.points - a.points;
                        if (b.goalDiff !== a.goalDiff) return b.goalDiff - a.goalDiff;
                        return b.goalsFor - a.goalsFor;
                    });
                    standings.forEach((t, idx) => t.position = idx + 1);
                    
                    console.log('[Standings] ✅ Using imported plStandings:', standings.slice(0, 5).map(t => `${t.position}. ${t.short_name} (${t.points}pts, GF:${t.goalsFor}, GA:${t.goalsAgainst})`));
                    batchAnalysisCache.plStandings = standings;
                    batchAnalysisCache.standingsSource = 'imported';
                    return standings;
                }
            }
            
            // Check Draft bootstrap.teams (this is from draft.premierleague.com API)
            if (importedBootstrap?.teams) {
                const teams = importedBootstrap.teams;
                console.log('[Standings] Checking Draft bootstrap teams...');
                console.log('[Standings] Sample team data:', JSON.stringify(teams[0], null, 2));
                
                // Check what fields are available
                const sampleTeam = teams[0] || {};
                console.log('[Standings] Available fields:', Object.keys(sampleTeam).join(', '));
                
                // Check for standings data
                const hasWinLoss = teams.some(t => t.win !== undefined || t.loss !== undefined);
                const hasPoints = teams.some(t => t.points !== undefined && t.points > 0);
                const hasPlayed = teams.some(t => t.played !== undefined && t.played > 0);
                
                console.log('[Standings] Data check - hasWinLoss:', hasWinLoss, 'hasPoints:', hasPoints, 'hasPlayed:', hasPlayed);
                
                if (hasPoints || hasWinLoss || hasPlayed) {
                    const standings = teams.map(t => ({
                        id: t.id,
                        name: t.name,
                        short_name: t.short_name,
                        position: t.position || 0,
                        played: t.played || 0,
                        wins: t.win || 0,
                        draws: t.draw || 0,
                        losses: t.loss || 0,
                        goalsFor: t.goals_for || t.team_goals_for || 0,
                        goalsAgainst: t.goals_against || t.team_goals_against || 0,
                        goalDiff: (t.goals_for || 0) - (t.goals_against || 0),
                        points: t.points || 0,
                        cleanSheets: 0,
                        games: t.played || 0
                    }));
                    
                    standings.sort((a, b) => {
                        if (b.points !== a.points) return b.points - a.points;
                        if (b.goalDiff !== a.goalDiff) return b.goalDiff - a.goalDiff;
                        return b.goalsFor - a.goalsFor;
                    });
                    standings.forEach((t, idx) => t.position = idx + 1);
                    
                    console.log('[Standings] ✅ Using Draft bootstrap standings:', standings.slice(0, 5).map(t => `${t.position}. ${t.short_name} (${t.points}pts)`));
                    batchAnalysisCache.plStandings = standings;
                    batchAnalysisCache.standingsSource = 'draft_bootstrap';
                    return standings;
                } else {
                    console.log('[Standings] Draft bootstrap has teams but NO standings data (win/loss/points)');
                }
            }
            
            return null;
        }
        
        // Main function to get best available standings
        async function getBestAvailableStandings() {
            console.log('[Standings] ====== GETTING BEST AVAILABLE STANDINGS ======');
            
            // Priority 1: Try imported plStandings (already fetched and stored)
            let standings = getStandingsFromImportedData();
            if (standings && standings.length > 0 && standings[0].points > 0) {
                console.log('[Standings] Using imported standings (source:', batchAnalysisCache.standingsSource, ')');
                return standings;
            }
            
            // Priority 2: Fetch from football-data.org if we have an API key
            const apiKey = localStorage.getItem(API_KEY_STORAGE);
            if (apiKey) {
                try {
                    console.log('[Standings] Trying football-data.org with saved API key...');
                    standings = await fetchStandingsFromFootballData(apiKey);
                    if (standings && standings.length > 0 && standings[0].points > 0) {
                        window.importedPLStandings = standings;
                        batchAnalysisCache.plStandings = standings;
                        batchAnalysisCache.standingsSource = 'football-data.org';
                        saveLeagueData(); // Persist
                        console.log('[Standings] ✅ Using football-data.org standings');
                        return standings;
                    }
                } catch (error) {
                    console.warn('[Standings] football-data.org fetch failed:', error.message);
                }
            } else {
                console.log('[Standings] No football-data.org API key saved');
            }
            
            // Priority 3: Fall back to calculated from history (LAST RESORT)
            console.warn('[Standings] ⚠️ Falling back to ESTIMATED standings - NOT ACCURATE');
            console.warn('[Standings] 💡 Add a football-data.org API key for real standings!');
            standings = calculatePLStandingsFromHistory();
            batchAnalysisCache.standingsSource = 'calculated';
            return standings;
        }
        
        // Calculate PL standings from player history data (FALLBACK)
        function calculatePLStandingsFromHistory() {
            console.log('[Batch] Calculating PL standings from player history...');
            
            if (!importedPlayerDetails || !importedBootstrap?.teams) {
                console.warn('[Batch] No player details or teams data available');
                return [];
            }
            
            // Build team performance from GK/DEF clean sheets and goals conceded
            const teamPerformance = {};
            importedBootstrap.teams.forEach(t => {
                teamPerformance[t.id] = {
                    id: t.id,
                    name: t.name,
                    short_name: t.short_name,
                    wins: 0,
                    draws: 0,
                    losses: 0,
                    goalsFor: 0,
                    goalsAgainst: 0,
                    cleanSheets: 0,
                    games: 0,
                    points: 0,
                    _processedGames: new Set()
                };
            });
            
            // Process each player's history to aggregate team stats
            Object.entries(importedPlayerDetails).forEach(([playerId, details]) => {
                const player = importedBootstrap.elements.find(e => e.id === parseInt(playerId));
                if (!player) return;
                
                const teamId = player.team;
                const isGK = player.element_type === 1;
                
                // Use GK data for most accurate team-level stats (they play full games)
                if (!isGK) return;
                
                (details.history || []).forEach(game => {
                    if (game.minutes < 60) return; // Only full games
                    
                    const gameKey = `${game.round}_${game.opponent_team}`;
                    if (teamPerformance[teamId]._processedGames.has(gameKey)) return;
                    teamPerformance[teamId]._processedGames.add(gameKey);
                    
                    const team = teamPerformance[teamId];
                    const goalsConceded = game.goals_conceded || 0;
                    const cleanSheet = game.clean_sheets || 0;
                    
                    team.goalsAgainst += goalsConceded;
                    team.cleanSheets += cleanSheet;
                    team.games++;
                    
                    // Estimate goals scored from match result (approximation)
                    // We'll use a different method - aggregate forward goals
                });
            });
            
            // Get goals scored from forwards/midfielders
            Object.entries(importedPlayerDetails).forEach(([playerId, details]) => {
                const player = importedBootstrap.elements.find(e => e.id === parseInt(playerId));
                if (!player) return;
                
                const teamId = player.team;
                
                (details.history || []).forEach(game => {
                    if (game.minutes < 10) return;
                    teamPerformance[teamId].goalsFor += game.goals_scored || 0;
                });
            });
            
            // Calculate points based on goals (approximation: GD * 0.5 + baseline)
            // Better method: use win/loss estimation from clean sheets and goals
            Object.values(teamPerformance).forEach(team => {
                if (team.games > 0) {
                    const gd = team.goalsFor - team.goalsAgainst;
                    const csRate = team.cleanSheets / team.games;
                    // Approximate points: more goals + fewer conceded = more wins
                    team.points = Math.round(
                        (team.goalsFor * 0.8) + // Goals scored correlates with wins
                        (team.cleanSheets * 1.5) + // Clean sheets = likely wins/draws
                        (gd * 0.5) + // Goal difference bonus
                        (team.games * 1.2) // Base points for playing
                    );
                }
                delete team._processedGames;
            });
            
            // Sort by points (descending)
            const standings = Object.values(teamPerformance)
                .filter(t => t.games > 0)
                .sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    const gdA = a.goalsFor - a.goalsAgainst;
                    const gdB = b.goalsFor - b.goalsAgainst;
                    if (gdB !== gdA) return gdB - gdA;
                    return b.goalsFor - a.goalsFor;
                });
            
            // Assign positions
            standings.forEach((team, idx) => {
                team.position = idx + 1;
            });
            
            console.log('[Batch] Calculated standings:', standings.map(t => `${t.position}. ${t.short_name} (${t.points}pts, GF:${t.goalsFor}, GA:${t.goalsAgainst})`));
            
            batchAnalysisCache.plStandings = standings;
            return standings;
        }
        
        // Build batch map from calculated standings
        function buildBatchMap() {
            if (!importedBootstrap?.teams) {
                console.warn('[Batch] No bootstrap teams data');
                return {};
            }
            
            console.log('[Batch] Building batch map...');
            
            // First, calculate standings from history if we have player data
            let standings = batchAnalysisCache.plStandings;
            if (!standings || standings.length === 0) {
                standings = calculatePLStandingsFromHistory();
            }
            
            // Check if we have valid strength data in bootstrap
            const hasStrengthData = importedBootstrap.teams.some(t => 
                (t.strength_overall_home || 0) > 0 || (t.strength_overall_away || 0) > 0
            );
            
            console.log('[Batch] Has bootstrap strength data:', hasStrengthData);
            console.log('[Batch] Has calculated standings:', standings.length > 0);
            
            const batchMap = {};
            
            if (standings.length > 0) {
                // Use calculated standings
                standings.forEach((team, index) => {
                    const rank = index + 1;
                    const batch = BATCH_CONFIG.batches.find(b => rank >= b.minRank && rank <= b.maxRank);
                    batchMap[team.id] = {
                        teamId: team.id,
                        teamName: team.short_name,
                        rank: rank,
                        batchId: batch ? batch.id : 3,
                        batchName: batch ? batch.name : 'Unknown',
                        points: team.points,
                        goalsFor: team.goalsFor,
                        goalsAgainst: team.goalsAgainst
                    };
                });
                
                // Add any missing teams (no GK data) at default batch
                importedBootstrap.teams.forEach(team => {
                    if (!batchMap[team.id]) {
                        batchMap[team.id] = {
                            teamId: team.id,
                            teamName: team.short_name,
                            rank: 10, // Default mid-table
                            batchId: 3,
                            batchName: 'Mid Table (9-12)',
                            points: 0,
                            goalsFor: 0,
                            goalsAgainst: 0
                        };
                    }
                });
            } else if (hasStrengthData) {
                // Fallback to strength data
                const teams = [...importedBootstrap.teams].sort((a, b) => {
                    const strengthA = (a.strength_overall_home || 0) + (a.strength_overall_away || 0);
                    const strengthB = (b.strength_overall_home || 0) + (b.strength_overall_away || 0);
                    return strengthB - strengthA;
                });
                
                teams.forEach((team, index) => {
                    const rank = index + 1;
                    const batch = BATCH_CONFIG.batches.find(b => rank >= b.minRank && rank <= b.maxRank);
                    batchMap[team.id] = {
                        teamId: team.id,
                        teamName: team.short_name,
                        rank: rank,
                        batchId: batch ? batch.id : 3,
                        batchName: batch ? batch.name : 'Unknown'
                    };
                });
            } else {
                // No data available - use default mid-table for all
                console.warn('[Batch] No standings data available - using defaults');
                importedBootstrap.teams.forEach(team => {
                    batchMap[team.id] = {
                        teamId: team.id,
                        teamName: team.short_name,
                        rank: 10,
                        batchId: 3,
                        batchName: 'Mid Table (9-12)'
                    };
                });
            }
            
            console.log('[Batch] Final batch map:', Object.values(batchMap).sort((a,b) => a.rank - b.rank).map(t => `${t.rank}. ${t.teamName} -> ${t.batchName}`));
            
            batchAnalysisCache.teamBatchMap = batchMap;
            return batchMap;
        }
        
        // Get batch ID for a team
        function getTeamBatch(teamId) {
            if (!batchAnalysisCache.teamBatchMap[teamId]) {
                buildBatchMap();
            }
            return batchAnalysisCache.teamBatchMap[teamId]?.batchId || 3;
        }
        
        // Calculate team-level statistics against each batch
        function calculateTeamBatchStats() {
            if (!importedPlayerDetails || !importedBootstrap?.teams) return {};
            
            const teamStats = {};
            const batchMap = batchAnalysisCache.teamBatchMap;
            
            // Initialize stats structure for each team
            importedBootstrap.teams.forEach(team => {
                teamStats[team.id] = {
                    teamName: team.short_name,
                    overall: { goalsScored: 0, goalsConceded: 0, cleanSheets: 0, games: 0 },
                    vsBatch: {}
                };
                BATCH_CONFIG.batches.forEach(b => {
                    teamStats[team.id].vsBatch[b.id] = { goalsScored: 0, goalsConceded: 0, cleanSheets: 0, games: 0 };
                });
            });
            
            // Aggregate from player history (use GK/DEF data for team-level stats)
            Object.entries(importedPlayerDetails).forEach(([playerId, details]) => {
                const player = importedBootstrap.elements.find(e => e.id === parseInt(playerId));
                if (!player) return;
                
                const teamId = player.team;
                const isDefensive = player.element_type <= 2; // GK or DEF
                
                (details.history || []).forEach(game => {
                    if (game.minutes < BATCH_CONFIG.minMinutesForInclusion) return;
                    
                    const opponentBatch = getTeamBatch(game.opponent_team);
                    if (!teamStats[teamId]) return;
                    
                    // For team goals, we need a representative sample - use highest minute player per team/game
                    // This is a simplification - ideally we'd have team-level match data
                    if (isDefensive && game.minutes >= 60) {
                        // Track unique games per team (use round as game identifier)
                        const gameKey = `${game.round}_${game.opponent_team}`;
                        if (!teamStats[teamId]._processedGames) teamStats[teamId]._processedGames = new Set();
                        
                        if (!teamStats[teamId]._processedGames.has(gameKey)) {
                            teamStats[teamId]._processedGames.add(gameKey);
                            
                            // Goals conceded from this player's data
                            const goalsConceded = game.goals_conceded || 0;
                            const cleanSheet = game.clean_sheets || 0;
                            
                            teamStats[teamId].overall.goalsConceded += goalsConceded;
                            teamStats[teamId].overall.cleanSheets += cleanSheet;
                            teamStats[teamId].overall.games++;
                            
                            teamStats[teamId].vsBatch[opponentBatch].goalsConceded += goalsConceded;
                            teamStats[teamId].vsBatch[opponentBatch].cleanSheets += cleanSheet;
                            teamStats[teamId].vsBatch[opponentBatch].games++;
                        }
                    }
                });
            });
            
            // Calculate averages
            Object.values(teamStats).forEach(stats => {
                if (stats.overall.games > 0) {
                    stats.overall.avgConceded = stats.overall.goalsConceded / stats.overall.games;
                    stats.overall.csRate = stats.overall.cleanSheets / stats.overall.games;
                }
                Object.values(stats.vsBatch).forEach(batchStats => {
                    if (batchStats.games > 0) {
                        batchStats.avgConceded = batchStats.goalsConceded / batchStats.games;
                        batchStats.csRate = batchStats.cleanSheets / batchStats.games;
                    }
                });
                delete stats._processedGames;
            });
            
            batchAnalysisCache.teamStats = teamStats;
            return teamStats;
        }
        
        // Calculate player-level statistics against each batch
        function calculatePlayerBatchStats() {
            if (!importedPlayerDetails || !importedBootstrap?.elements) return {};
            
            const playerStats = {};
            
            Object.entries(importedPlayerDetails).forEach(([playerId, details]) => {
                const player = importedBootstrap.elements.find(e => e.id === parseInt(playerId));
                if (!player) return;
                
                playerStats[playerId] = {
                    name: player.web_name,
                    position: fplPositionMap[player.element_type] || 'UNK',
                    teamId: player.team,
                    overall: {
                        goals: 0, assists: 0, cleanSheets: 0, goalsConceded: 0,
                        saves: 0, bonus: 0, bps: 0, yellowCards: 0, redCards: 0,
                        dc: 0, dcBonusHits: 0, minutes: 0, games: 0, games45plus: 0
                    },
                    vsBatch: {}
                };
                
                BATCH_CONFIG.batches.forEach(b => {
                    playerStats[playerId].vsBatch[b.id] = {
                        goals: 0, assists: 0, cleanSheets: 0, goalsConceded: 0,
                        saves: 0, bonus: 0, bps: 0, yellowCards: 0, redCards: 0,
                        dc: 0, dcBonusHits: 0, minutes: 0, games: 0, games45plus: 0
                    };
                });
                
                (details.history || []).forEach(game => {
                    if (game.minutes < BATCH_CONFIG.minMinutesForInclusion) return;
                    
                    const opponentBatch = getTeamBatch(game.opponent_team);
                    const stats = playerStats[playerId];
                    const targets = [stats.overall, stats.vsBatch[opponentBatch]];
                    
                    targets.forEach(t => {
                        t.goals += game.goals_scored || 0;
                        t.assists += game.assists || 0;
                        t.bonus += game.bonus || 0;
                        t.bps += game.bps || 0;
                        t.yellowCards += game.yellow_cards || 0;
                        t.redCards += game.red_cards || 0;
                        t.saves += game.saves || 0;
                        t.minutes += game.minutes || 0;
                        t.games++;
                        
                        // Only count defensive stats for games with 45+ minutes
                        if (game.minutes >= BATCH_CONFIG.minMinutesForDefensiveStats) {
                            t.cleanSheets += game.clean_sheets || 0;
                            t.goalsConceded += game.goals_conceded || 0;
                            t.games45plus++;
                            
                            // Defensive contribution (DC) - directly from game data
                            const gameDC = game.defensive_contribution || 0;
                            t.dc += gameDC;
                            
                            // Track DC threshold hits (DEF/GK needs 10+, MID/FWD needs 12+)
                            const dcThreshold = playerStats[playerId].position === 'DEF' || playerStats[playerId].position === 'GK' ? 10 : 12;
                            if (gameDC >= dcThreshold) {
                                t.dcBonusHits++;
                            }
                        }
                    });
                });
                
                // Calculate per-game averages
                const calcAverages = (stats) => {
                    if (stats.games > 0) {
                        stats.goalsPerGame = stats.goals / stats.games;
                        stats.assistsPerGame = stats.assists / stats.games;
                        stats.bonusPerGame = stats.bonus / stats.games;
                        stats.bpsPerGame = stats.bps / stats.games;
                        stats.yellowPerGame = stats.yellowCards / stats.games;
                        stats.redPerGame = stats.redCards / stats.games;
                        stats.savesPerGame = stats.saves / stats.games;
                        stats.minutesPerGame = stats.minutes / stats.games;
                    }
                    if (stats.games45plus > 0) {
                        stats.csPerGame = stats.cleanSheets / stats.games45plus;
                        stats.concededPerGame = stats.goalsConceded / stats.games45plus;
                        stats.dcPerGame = stats.dc / stats.games45plus;
                        // DC bonus rate = how often player hits the threshold (10 for DEF, 12 for MID/FWD)
                        stats.dcBonusRate = stats.dcBonusHits / stats.games45plus;
                    }
                };
                
                calcAverages(playerStats[playerId].overall);
                Object.values(playerStats[playerId].vsBatch).forEach(calcAverages);
            });
            
            batchAnalysisCache.playerStats = playerStats;
            return playerStats;
        }
        
        // Calculate league-wide averages for cross-referencing
        function calculateLeagueAverages() {
            const playerStats = batchAnalysisCache.playerStats;
            if (!playerStats || Object.keys(playerStats).length === 0) return {};
            
            const totals = {
                goals: 0, assists: 0, cleanSheets: 0, saves: 0,
                bonus: 0, yellowCards: 0, games: 0, games45plus: 0
            };
            
            Object.values(playerStats).forEach(p => {
                totals.goals += p.overall.goals;
                totals.assists += p.overall.assists;
                totals.cleanSheets += p.overall.cleanSheets;
                totals.saves += p.overall.saves;
                totals.bonus += p.overall.bonus;
                totals.yellowCards += p.overall.yellowCards;
                totals.games += p.overall.games;
                totals.games45plus += p.overall.games45plus;
            });
            
            const averages = {
                goalsPerGame: totals.games > 0 ? totals.goals / totals.games : 0.1,
                assistsPerGame: totals.games > 0 ? totals.assists / totals.games : 0.08,
                csPerGame: totals.games45plus > 0 ? totals.cleanSheets / totals.games45plus : 0.3,
                savesPerGame: totals.games > 0 ? totals.saves / totals.games : 1.0,
                bonusPerGame: totals.games > 0 ? totals.bonus / totals.games : 0.5,
                yellowPerGame: totals.games > 0 ? totals.yellowCards / totals.games : 0.1
            };
            
            batchAnalysisCache.leagueAverages = averages;
            return averages;
        }
        
        // ============================================
        // TEAM VENUE (HOME/AWAY) STATS SYSTEM
        // ============================================
        
        // Compute team-level home vs away performance stats
        function computeTeamVenueStats() {
            console.log('[Venue] Computing team venue (home/away) stats...');
            
            const teamVenueStats = {};
            const seen = new Set(); // Track seen fixtures to avoid double-counting
            
            // Process all player histories to build team-level stats
            Object.entries(importedPlayerDetails || {}).forEach(([playerId, details]) => {
                const player = importedBootstrap?.elements?.find(e => e.id === parseInt(playerId));
                if (!player) return;
                
                const teamId = player.team;
                if (!teamVenueStats[teamId]) {
                    teamVenueStats[teamId] = {
                        home: { gf: 0, ga: 0, games: 0, cs: 0 },
                        away: { gf: 0, ga: 0, games: 0, cs: 0 }
                    };
                }
                
                (details.history || []).forEach(game => {
                    // Use team + fixture as unique key to avoid counting same match multiple times
                    const key = `${teamId}-${game.fixture}`;
                    if (seen.has(key)) return;
                    seen.add(key);
                    
                    const detail = game.detail || '';
                    const isHome = detail.includes('(H)');
                    
                    // Parse score from detail like "MUN (A) 0-1" or "LEE (H) 5-0"
                    const scorePart = detail.split(' ').pop();
                    const scoreParts = scorePart.split('-');
                    
                    if (scoreParts.length === 2) {
                        const score1 = parseInt(scoreParts[0]);
                        const score2 = parseInt(scoreParts[1]);
                        
                        if (!isNaN(score1) && !isNaN(score2)) {
                            const gf = isHome ? score1 : score2;
                            const ga = isHome ? score2 : score1;
                            const venue = isHome ? 'home' : 'away';
                            
                            teamVenueStats[teamId][venue].gf += gf;
                            teamVenueStats[teamId][venue].ga += ga;
                            teamVenueStats[teamId][venue].games++;
                            if (ga === 0) {
                                teamVenueStats[teamId][venue].cs++;
                            }
                        }
                    }
                });
            });
            
            // Calculate league-wide venue averages
            let totalHomeGF = 0, totalHomeGA = 0, totalHomeGames = 0;
            let totalAwayGF = 0, totalAwayGA = 0, totalAwayGames = 0;
            
            Object.values(teamVenueStats).forEach(team => {
                totalHomeGF += team.home.gf;
                totalHomeGA += team.home.ga;
                totalHomeGames += team.home.games;
                totalAwayGF += team.away.gf;
                totalAwayGA += team.away.ga;
                totalAwayGames += team.away.games;
            });
            
            const venueLeagueAvg = {
                homeGF: totalHomeGames > 0 ? totalHomeGF / totalHomeGames : 1.5,
                homeGA: totalHomeGames > 0 ? totalHomeGA / totalHomeGames : 1.2,
                awayGF: totalAwayGames > 0 ? totalAwayGF / totalAwayGames : 1.2,
                awayGA: totalAwayGames > 0 ? totalAwayGA / totalAwayGames : 1.5
            };
            
            // Store in cache
            batchAnalysisCache.teamVenueStats = teamVenueStats;
            batchAnalysisCache.venueLeagueAvg = venueLeagueAvg;
            
            console.log('[Venue] Stats computed for', Object.keys(teamVenueStats).length, 'teams');
            console.log('[Venue] League averages:', venueLeagueAvg);
            
            return { teamVenueStats, venueLeagueAvg };
        }
        
        // Get team venue stat with Bayesian blending for small samples
        function getTeamVenueStat(teamStats, venue, stat, leagueAvg, minGames = 3) {
            const data = teamStats?.[venue];
            if (!data || data.games === 0) return leagueAvg;
            
            const teamValue = data[stat] / data.games;
            
            // If enough games, use team's actual value
            if (data.games >= minGames * 2) {
                return teamValue;
            }
            
            // Bayesian blend with league average for small samples
            const weight = data.games / (data.games + minGames);
            return (teamValue * weight) + (leagueAvg * (1 - weight));
        }
        
        // Clamp value within range
        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }
        
        // Get dynamic venue cross-reference multipliers for a specific matchup
        function getVenueCrossReference(playerTeamId, opponentTeamId, isHome) {
            const stats = batchAnalysisCache.teamVenueStats || {};
            const avg = batchAnalysisCache.venueLeagueAvg || { homeGF: 1.5, homeGA: 1.2, awayGF: 1.2, awayGA: 1.5 };
            
            const playerTeam = stats[playerTeamId];
            const opponent = stats[opponentTeamId];
            
            // Default multipliers if no data
            if (!playerTeam || !opponent) {
                return {
                    attackMultiplier: isHome ? 1.1 : 0.95,
                    csMultiplier: isHome ? 1.1 : 0.95,
                    savesMultiplier: isHome ? 0.95 : 1.05,
                    bonusMultiplier: isHome ? 1.05 : 0.98,
                    isHome
                };
            }
            
            if (isHome) {
                // === HOME TEAM CALCULATIONS ===
                
                // Attack: How good is home team at scoring at home × How leaky is away team when away
                const homeAttackStrength = getTeamVenueStat(playerTeam, 'home', 'gf', avg.homeGF) / avg.homeGF;
                const awayDefenseWeakness = getTeamVenueStat(opponent, 'away', 'ga', avg.awayGA) / avg.awayGA;
                
                // Defense: How solid is home team at home × How weak is away team's attack when away
                const homeDefenseStrength = avg.homeGA / Math.max(0.1, getTeamVenueStat(playerTeam, 'home', 'ga', avg.homeGA));
                const awayAttackWeakness = avg.awayGF / Math.max(0.1, getTeamVenueStat(opponent, 'away', 'gf', avg.awayGF));
                
                const attackMult = homeAttackStrength * awayDefenseWeakness;
                const csMult = homeDefenseStrength * awayAttackWeakness;
                
                return {
                    attackMultiplier: clamp(attackMult, 0.4, 2.5),
                    csMultiplier: clamp(csMult, 0.3, 3.0),
                    savesMultiplier: clamp(1 / csMult, 0.5, 2.0), // Inverse - more shots faced if defense is weaker
                    bonusMultiplier: clamp(attackMult * 0.6 + 0.4, 0.7, 1.5), // Correlated with attack
                    isHome: true
                };
            } else {
                // === AWAY TEAM CALCULATIONS ===
                
                // Attack: How good is away team at scoring away × How leaky is home team at home
                const awayAttackStrength = getTeamVenueStat(playerTeam, 'away', 'gf', avg.awayGF) / avg.awayGF;
                const homeDefenseWeakness = getTeamVenueStat(opponent, 'home', 'ga', avg.homeGA) / avg.homeGA;
                
                // Defense: How solid is away team when away × How weak is home team's attack at home
                const awayDefenseStrength = avg.awayGA / Math.max(0.1, getTeamVenueStat(playerTeam, 'away', 'ga', avg.awayGA));
                const homeAttackWeakness = avg.homeGF / Math.max(0.1, getTeamVenueStat(opponent, 'home', 'gf', avg.homeGF));
                
                const attackMult = awayAttackStrength * homeDefenseWeakness;
                const csMult = awayDefenseStrength * homeAttackWeakness;
                
                return {
                    attackMultiplier: clamp(attackMult, 0.4, 2.5),
                    csMultiplier: clamp(csMult, 0.3, 3.0),
                    savesMultiplier: clamp(1 / csMult, 0.5, 2.0),
                    bonusMultiplier: clamp(attackMult * 0.6 + 0.4, 0.7, 1.5),
                    isHome: false
                };
            }
        }
        
        // Apply Bayesian weighting for small sample sizes
        function applyBayesianBlend(batchValue, overallValue, batchGames, priorWeight = BATCH_CONFIG.bayesianPriorWeight) {
            if (batchGames === 0) return overallValue || 0;
            if (batchGames >= priorWeight * 2) return batchValue; // Enough data, use batch directly
            
            // Weighted blend: more games in batch = more weight to batch value
            const totalWeight = batchGames + priorWeight;
            return ((batchValue * batchGames) + ((overallValue || 0) * priorWeight)) / totalWeight;
        }
        
        // Cross-reference player stats with opponent's actual rates
        function crossReferenceWithOpponent(playerBatchStats, playerOverallStats, opponentTeamStats, opponentBatch, leagueAvg) {
            // If opponent concedes more than league average, boost expected goals/assists
            const opponentConcededRate = opponentTeamStats?.vsBatch?.[opponentBatch]?.avgConceded 
                                        || opponentTeamStats?.overall?.avgConceded 
                                        || leagueAvg.goalsPerGame * 11; // Fallback
            
            const opponentCSRate = opponentTeamStats?.vsBatch?.[opponentBatch]?.csRate 
                                  || opponentTeamStats?.overall?.csRate 
                                  || 0.3;
            
            // Multiplier based on opponent's defensive weakness
            const leagueAvgConceded = leagueAvg.goalsPerGame * 11 || 1.5;
            const offensiveMultiplier = Math.max(0.5, Math.min(2.0, opponentConcededRate / leagueAvgConceded));
            
            // For clean sheets, lower multiplier if opponent scores a lot
            const defensiveMultiplier = Math.max(0.3, Math.min(1.5, 1 - (1 - opponentCSRate) * 0.5));
            
            return {
                offensiveMultiplier,
                defensiveMultiplier
            };
        }
        
        // Main batch-based prediction for a single player
        function predictPlayerPointsBatch(playerId, opponentTeamId, isHome, gameweek) {
            const pStats = batchAnalysisCache.playerStats?.[playerId];
            const player = importedBootstrap?.elements?.find(e => e.id === parseInt(playerId));
            
            if (!pStats || !player) {
                // Debug first few missing predictions
                if (!window._predictDebugCount) window._predictDebugCount = 0;
                if (window._predictDebugCount < 3) {
                    console.warn(`[Predict] Player ${playerId}: pStats=${!!pStats}, player=${!!player}, cacheSize=${Object.keys(batchAnalysisCache.playerStats || {}).length}`);
                    window._predictDebugCount++;
                }
                return { predicted: 0, breakdown: {}, confidence: 'none' };
            }
            
            const opponentBatch = getTeamBatch(opponentTeamId);
            const teamStats = batchAnalysisCache.teamStats?.[player.team];
            const opponentStats = batchAnalysisCache.teamStats?.[opponentTeamId];
            const leagueAvg = batchAnalysisCache.leagueAverages || {};
            const rules = BATCH_CONFIG.fplScoringRules;
            const pos = fplPositionMap[player.element_type] || 'MID';
            
            // Get batch-specific stats with Bayesian blending
            const batchData = pStats.vsBatch[opponentBatch] || {};
            const overallData = pStats.overall || {};
            const batchGames = batchData.games || 0;
            
            const expectedGoals = applyBayesianBlend(batchData.goalsPerGame || 0, overallData.goalsPerGame || 0, batchGames);
            const expectedAssists = applyBayesianBlend(batchData.assistsPerGame || 0, overallData.assistsPerGame || 0, batchGames);
            const expectedBonus = applyBayesianBlend(batchData.bonusPerGame || 0, overallData.bonusPerGame || 0, batchGames);
            const expectedYellow = applyBayesianBlend(batchData.yellowPerGame || 0, overallData.yellowPerGame || 0, batchGames);
            const expectedRed = applyBayesianBlend(batchData.redPerGame || 0, overallData.redPerGame || 0, batchGames);
            const expectedSaves = applyBayesianBlend(batchData.savesPerGame || 0, overallData.savesPerGame || 0, batchGames);
            
            // Defensive stats (only for games 45+)
            const batchGames45 = batchData.games45plus || 0;
            const expectedCS = applyBayesianBlend(batchData.csPerGame || 0, overallData.csPerGame || 0, batchGames45);
            const expectedConceded = applyBayesianBlend(batchData.concededPerGame || 0, overallData.concededPerGame || 0, batchGames45);
            
            // Defensive Contribution (DC) stats
            const expectedDC = applyBayesianBlend(batchData.dcPerGame || 0, overallData.dcPerGame || 0, batchGames45);
            const dcBonusRate = applyBayesianBlend(batchData.dcBonusRate || 0, overallData.dcBonusRate || 0, batchGames45);
            
            // Cross-reference with opponent (batch-based)
            const crossRef = crossReferenceWithOpponent(batchData, overallData, opponentStats, opponentBatch, leagueAvg);
            
            // Apply batch-based multipliers
            const adjGoals = expectedGoals * crossRef.offensiveMultiplier;
            const adjAssists = expectedAssists * crossRef.offensiveMultiplier;
            const adjCS = expectedCS * crossRef.defensiveMultiplier;
            
            // Dynamic Home/Away venue cross-reference (team-specific, not flat!)
            const venueRef = getVenueCrossReference(player.team, opponentTeamId, isHome);
            
            // Calculate FPL Points breakdown
            const breakdown = {
                minutes: rules.minutes60plus, // Assume 60+ if playing
                goals: 0,
                assists: 0,
                cleanSheet: 0,
                saves: 0,
                goalsConceded: 0,
                bonus: 0,
                dcBonus: 0,
                cards: 0
            };
            
            // Goal points by position - using dynamic venue attack multiplier
            const goalPts = pos === 'GK' || pos === 'DEF' ? rules.goalGK : pos === 'MID' ? rules.goalMID : rules.goalFWD;
            breakdown.goals = adjGoals * venueRef.attackMultiplier * goalPts;
            
            // Assists - using dynamic venue attack multiplier
            breakdown.assists = adjAssists * venueRef.attackMultiplier * rules.assist;
            
            // Clean sheets (GK/DEF only get full points) - using dynamic venue CS multiplier
            if (pos === 'GK' || pos === 'DEF') {
                breakdown.cleanSheet = adjCS * venueRef.csMultiplier * rules.cleanSheetGK;
                // Goals conceded penalty (per 2) - inverse of CS multiplier
                breakdown.goalsConceded = (expectedConceded / venueRef.csMultiplier) * (rules.goalsConcededPenalty / 2);
            } else if (pos === 'MID') {
                breakdown.cleanSheet = adjCS * venueRef.csMultiplier * rules.cleanSheetMID;
            }
            
            // Saves (GK only) - using dynamic venue saves multiplier
            if (pos === 'GK') {
                breakdown.saves = (expectedSaves * venueRef.savesMultiplier) / rules.savesPerPoint;
            }
            
            // Bonus points - using dynamic venue bonus multiplier
            breakdown.bonus = expectedBonus * venueRef.bonusMultiplier;
            
            // Defensive Contribution bonus (2 pts if DC >= threshold)
            // DEF/GK threshold: 10, MID/FWD threshold: 12
            const dcThreshold = (pos === 'DEF' || pos === 'GK') ? 10 : 12;
            // Calculate probability of hitting DC threshold based on expected DC and historical rate
            let dcBonusProb = 0;
            if (expectedDC >= dcThreshold) {
                // Expected DC already above threshold - high probability
                dcBonusProb = Math.min(0.9, 0.5 + (expectedDC - dcThreshold) * 0.1);
            } else if (expectedDC >= dcThreshold - 3) {
                // Close to threshold - use historical rate with adjustment
                dcBonusProb = dcBonusRate * (expectedDC / dcThreshold);
            } else {
                // Far from threshold - low probability
                dcBonusProb = dcBonusRate * 0.5;
            }
            breakdown.dcBonus = dcBonusProb * 2; // 2 points if threshold hit
            
            // Cards - slightly more cards when playing away
            const cardVenueMult = isHome ? 0.85 : 1.15;
            breakdown.cards = (expectedYellow * rules.yellowCard * cardVenueMult) + (expectedRed * rules.redCard);
            
            // Total predicted points
            let totalPredicted = breakdown.minutes + breakdown.goals + breakdown.assists + 
                                 breakdown.cleanSheet + breakdown.saves + breakdown.goalsConceded + 
                                 breakdown.bonus + breakdown.dcBonus + breakdown.cards;
            
            // Availability adjustment
            const status = player.status || 'a';
            const chance = player.chance_of_playing_next_round;
            let availMultiplier = 1.0;
            
            if (status === 'u' || status === 'i') availMultiplier = 0;
            else if (status === 'd') availMultiplier = 0.5;
            else if (chance !== null && chance !== undefined && chance < 100) availMultiplier = chance / 100;
            
            totalPredicted *= availMultiplier;
            
            // Determine confidence level
            let confidence = 'high';
            if (batchGames < 2) confidence = 'low';
            else if (batchGames < 5) confidence = 'medium';
            
            return {
                playerId: parseInt(playerId),
                name: player.web_name,
                pos,
                team: fplTeamIdMap[player.team] || '?',
                teamId: player.team,
                opponent: fplTeamIdMap[opponentTeamId] || '?',
                opponentId: opponentTeamId,
                opponentBatch,
                opponentBatchName: BATCH_CONFIG.batches.find(b => b.id === opponentBatch)?.name || 'Unknown',
                isHome,
                predicted: Math.round(Math.max(0, totalPredicted) * 10) / 10,
                breakdown: {
                    minutes: Math.round(breakdown.minutes * 10) / 10,
                    goals: Math.round(breakdown.goals * 10) / 10,
                    assists: Math.round(breakdown.assists * 10) / 10,
                    cs: Math.round(breakdown.cleanSheet * 10) / 10,
                    saves: Math.round(breakdown.saves * 10) / 10,
                    conceded: Math.round(breakdown.goalsConceded * 10) / 10,
                    bonus: Math.round(breakdown.bonus * 10) / 10,
                    dcBonus: Math.round(breakdown.dcBonus * 10) / 10,
                    cards: Math.round(breakdown.cards * 10) / 10
                },
                expectedDC: Math.round(expectedDC * 10) / 10,
                confidence,
                batchGames,
                crossRef,
                // Dynamic venue multipliers (team-specific home/away factors)
                venueMultipliers: {
                    attack: Math.round(venueRef.attackMultiplier * 100) / 100,
                    cs: Math.round(venueRef.csMultiplier * 100) / 100,
                    saves: Math.round(venueRef.savesMultiplier * 100) / 100,
                    bonus: Math.round(venueRef.bonusMultiplier * 100) / 100,
                    isHome: venueRef.isHome
                }
            };
        }
        
        // Initialize the batch analysis system
        async function initBatchAnalysis() {
            console.log('[Batch] ====== INITIALIZING BATCH ANALYSIS ======');
            console.log('[Batch] Data available:', {
                hasBootstrap: !!importedBootstrap,
                teamsCount: importedBootstrap?.teams?.length || 0,
                elementsCount: importedBootstrap?.elements?.length || 0,
                hasPlayerDetails: !!importedPlayerDetails,
                playerDetailsCount: Object.keys(importedPlayerDetails || {}).length
            });
            
            // Get best available standings (API > Bootstrap > Calculated)
            const standings = await getBestAvailableStandings();
            console.log('[Batch] Standings source:', batchAnalysisCache.standingsSource);
            console.log('[Batch] Standings count:', standings?.length || 0);
            
            // Build batch map using standings
            buildBatchMap();
            
            // Calculate team and player stats
            calculateTeamBatchStats();
            calculatePlayerBatchStats();
            calculateLeagueAverages();
            
            // Compute team venue (home/away) stats for dynamic multipliers
            computeTeamVenueStats();
            
            batchAnalysisCache.lastComputed = new Date().toISOString();
            
            console.log('[Batch] ====== ANALYSIS COMPLETE ======');
            console.log('[Batch] Results:', {
                teamsInBatchMap: Object.keys(batchAnalysisCache.teamBatchMap).length,
                playersWithStats: Object.keys(batchAnalysisCache.playerStats).length,
                standingsCount: batchAnalysisCache.plStandings.length,
                source: batchAnalysisCache.standingsSource
            });
            
            // Log top 5 teams
            const top5 = Object.values(batchAnalysisCache.teamBatchMap)
                .sort((a, b) => a.rank - b.rank)
                .slice(0, 5);
            console.log('[Batch] Top 5 teams:', top5.map(t => `${t.rank}. ${t.teamName}`).join(', '));
        }
        
        // Tab switching function
        function switchAnalysisTab(tabName, buttonEl) {
            // Hide all tabs
            document.querySelectorAll('#leagueAnalysisResults .tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active from all tab buttons
            document.querySelectorAll('#leagueAnalysisResults .tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            const tabElement = document.getElementById(tabName + 'Tab');
            if (tabElement) {
                tabElement.classList.add('active');
            }
            
            // Activate clicked button
            if (buttonEl) {
                buttonEl.classList.add('active');
            }
            
            // Render content if needed
            if (tabName === 'predictions') {
                initPredictionsTab();
            } else if (tabName === 'plstats') {
                initPLStatsTab();
            } else if (tabName === 'simulation') {
                renderSimulationTab();
            }
        }
        
        // Initialize predictions tab
        async function initPredictionsTab() {
            // Initialize batch analysis for predictions
            if (!batchAnalysisCache.lastComputed && importedPlayerDetails && importedBootstrap) {
                await initBatchAnalysis();
            }
            
            // Populate GW selector (starting from next upcoming GW, minimum 21)
            const gwSelect = document.getElementById('predictionGW');
            if (gwSelect && gwSelect.options.length === 0) {
                const currentGW = getCurrentGameweek();
                const startGW = Math.max(21, currentGW); // Always start from GW21 or later
                for (let gw = startGW; gw <= 38; gw++) {
                    const option = document.createElement('option');
                    option.value = gw;
                    option.textContent = `GW${gw}`;
                    if (gw === startGW) option.selected = true;
                    gwSelect.appendChild(option);
                }
            }
            
            // Populate team selector for breakdown
            const teamSelect = document.getElementById('breakdownTeamSelect');
            if (teamSelect && teamSelect.options.length === 0 && importedLeagueData?.league_entries) {
                importedLeagueData.league_entries.forEach(entry => {
                    const option = document.createElement('option');
                    option.value = entry.entry_id;
                    option.textContent = entry.entry_name;
                    teamSelect.appendChild(option);
                });
            }
            
            renderPredictionsTab();
        }
        
        // Main prediction calculator for a gameweek (BATCH-BASED)
        async function calculateGWPredictions(gameweek) {
            if (!importedLeagueData || !importedBootstrap) {
                return [];
            }
            
            // Initialize batch analysis if not done
            if (!batchAnalysisCache.lastComputed) {
                await initBatchAnalysis();
            }
            
            const squads = importedLeagueData.squads || {};
            const fixtures = importedBootstrap.fixtures || {};
            const gwFixtures = fixtures[String(gameweek)] || [];
            
            // Build team fixture map for this gameweek
            const teamFixtureMap = {};
            gwFixtures.forEach(fix => {
                teamFixtureMap[fix.team_h] = { 
                    opponent: fix.team_a, 
                    isHome: true
                };
                teamFixtureMap[fix.team_a] = { 
                    opponent: fix.team_h, 
                    isHome: false
                };
            });
            
            const predictions = [];
            
            (importedLeagueData.league_entries || []).forEach(entry => {
                const entryId = String(entry.entry_id);
                const squadData = squads[entryId];
                if (!squadData || !squadData.picks) return;
                
                // Use new batch-based prediction for each player
                const playerPredictions = squadData.picks.map(pick => {
                    const player = importedBootstrap?.elements?.find(e => e.id === pick.element);
                    if (!player) {
                        // Player not in bootstrap - likely a recent trade-in
                        console.warn(`[Predictions] Player ${pick.element} not found in bootstrap (trade-in?)`);
                        return null; // Will be filtered out
                    }
                    
                    const teamId = player.team;
                    const fixture = teamFixtureMap[teamId];
                    
                    if (!fixture) {
                        return { 
                            playerId: pick.element, 
                            name: player.web_name, 
                            pos: fplPositionMap[player.element_type] || '?',
                            team: fplTeamIdMap[teamId] || '?',
                            predicted: 0, 
                            opponent: 'BYE',
                            isHome: false,
                            breakdown: { minutes: 0, goals: 0, assists: 0, cs: 0, saves: 0, bonus: 0, dcBonus: 0, cards: 0, conceded: 0 },
                            confidence: 'none'
                        };
                    }
                    
                    // Use batch-based prediction
                    return predictPlayerPointsBatch(pick.element, fixture.opponent, fixture.isHome, gameweek);
                }).filter(p => p !== null); // Filter out missing players
                
                // Sort by predicted points
                playerPredictions.sort((a, b) => b.predicted - a.predicted);
                
                // Select optimal 11
                const optimal11 = selectOptimalLineup(playerPredictions);
                const optimalPoints = optimal11.lineup.reduce((sum, p) => sum + p.predicted, 0);
                const totalPoints = playerPredictions.reduce((sum, p) => sum + p.predicted, 0);
                const benchPoints = totalPoints - optimalPoints;
                
                predictions.push({
                    entryId: entry.entry_id,
                    entryName: entry.entry_name,
                    players: playerPredictions,
                    optimal11: optimal11.lineup,
                    formation: optimal11.formation,
                    optimalPoints: Math.round(optimalPoints * 10) / 10,
                    benchPoints: Math.round(benchPoints * 10) / 10,
                    totalPoints: Math.round(totalPoints * 10) / 10
                });
            });
            
            // Sort by optimal points
            predictions.sort((a, b) => b.optimalPoints - a.optimalPoints);
            
            return predictions;
        }
        
        // Legacy prediction function (kept for backward compatibility with other features)
        function calculatePlayerPredictionLegacy(playerId, teamFixtureMap, gameweek) {
            // Get player from processed map AND raw bootstrap for complete data
            const playerMap = fplElementMap[playerId];
            const playerRaw = importedBootstrap?.elements?.find(e => e.id === playerId);
            
            if (!playerMap && !playerRaw) {
                return { playerId, name: 'Unknown', pos: '?', team: '?', predicted: 0, breakdown: {} };
            }
            
            // Use mapped data (correctly formatted) or fallback to raw
            const pos = playerMap?.position || fplPositionMap[playerRaw?.element_type] || '?';
            const teamId = playerMap?.teamId || playerRaw?.team;
            const teamName = playerMap?.team || fplTeamIdMap[teamId] || '?';
            const playerName = playerMap?.name || playerRaw?.web_name || 'Unknown';
            const fixture = teamFixtureMap[teamId];
            
            if (!fixture) {
                return { 
                    playerId, 
                    name: playerName, 
                    pos, 
                    team: teamName, 
                    predicted: 0, 
                    opponent: 'BYE',
                    isHome: false,
                    fdr: 3,
                    breakdown: { goals: 0, assists: 0, cs: 0, saves: 0, bonus: 0, minutes: 0 } 
                };
            }
            
            const opponentName = fplTeamIdMap[fixture.opponent] || '?';
            
            // Get player stats - use mapped data or raw
            const form = playerMap?.form || parseFloat(playerRaw?.form) || 0;
            const ppg = playerMap?.ppg || parseFloat(playerRaw?.points_per_game) || 0;
            const totalPoints = playerMap?.totalPoints || playerRaw?.total_points || 0;
            
            // Get detailed history
            const details = importedPlayerDetails?.[String(playerId)];
            const history = details?.history || [];
            
            // Calculate last 5 games average
            let last5Avg = 0;
            if (history.length > 0) {
                const recent = history.slice(-5);
                last5Avg = recent.reduce((sum, g) => sum + (g.total_points || 0), 0) / recent.length;
            }
            
            // If no history, use form/ppg as fallback
            if (last5Avg === 0 && form > 0) last5Avg = form;
            if (last5Avg === 0 && ppg > 0) last5Avg = ppg;
            
            // Calculate breakdown
            const breakdown = calculatePointsBreakdown(playerId, history, fixture, pos);
            
            // Base prediction
            let basePred = (last5Avg * 0.4) + (form * 0.3) + (ppg * 0.2) + 2 * 0.1;
            
            // FDR adjustment
            const fdrMult = 1 + (3 - fixture.fdr) * 0.08;
            
            // Home/away adjustment
            const homeMult = fixture.isHome ? 1.05 : 0.97;
            
            // Availability check
            let availMult = 1.0;
            const status = playerRaw?.status || playerMap?.status || 'a';
            const chance = playerRaw?.chance_of_playing_next_round ?? playerMap?.chanceOfPlaying ?? null;
            
            if (status === 'u' || status === 'i') {
                availMult = 0;
            } else if (status === 'd') {
                availMult = 0.5;
            } else if (chance !== null && chance < 100) {
                availMult = chance / 100;
            }
            
            let predicted = basePred * fdrMult * homeMult * availMult;
            
            // Minimum points if playing
            if (availMult > 0.5 && predicted < 2) predicted = 2;
            if (availMult === 0) predicted = 0;
            
            return {
                playerId,
                name: playerName,
                pos,
                team: teamName,
                teamId,
                opponent: opponentName,
                opponentId: fixture.opponent,
                isHome: fixture.isHome,
                fdr: fixture.fdr || 3,
                predicted: Math.round(predicted * 10) / 10,
                breakdown,
                form,
                ppg,
                last5Avg: Math.round(last5Avg * 10) / 10,
                status,
                chance
            };
        }
        
        // Calculate detailed points breakdown
        function calculatePointsBreakdown(playerId, history, fixture, pos) {
            if (!history || history.length === 0) {
                return { goals: 0, assists: 0, cs: 0, saves: 0, bonus: 0, minutes: 0 };
            }
            
            const recent = history.slice(-5);
            const gamesPlayed = recent.filter(g => g.minutes > 0).length || 1;
            
            // Calculate per-game averages
            const avgGoals = recent.reduce((sum, g) => sum + (g.goals_scored || 0), 0) / gamesPlayed;
            const avgAssists = recent.reduce((sum, g) => sum + (g.assists || 0), 0) / gamesPlayed;
            const avgCS = recent.reduce((sum, g) => sum + (g.clean_sheets || 0), 0) / gamesPlayed;
            const avgSaves = recent.reduce((sum, g) => sum + (g.saves || 0), 0) / gamesPlayed;
            const avgBonus = recent.reduce((sum, g) => sum + (g.bonus || 0), 0) / gamesPlayed;
            const avgMinutes = recent.reduce((sum, g) => sum + (g.minutes || 0), 0) / gamesPlayed;
            
            // FDR adjustment factor
            const fdrFactor = 1 + (3 - (fixture?.fdr || 3)) * 0.1;
            
            // Convert to expected points
            let goalPoints = 0;
            if (pos === 'GK' || pos === 'DEF') goalPoints = avgGoals * 6 * fdrFactor;
            else if (pos === 'MID') goalPoints = avgGoals * 5 * fdrFactor;
            else goalPoints = avgGoals * 4 * fdrFactor;
            
            const assistPoints = avgAssists * 3 * fdrFactor;
            
            let csPoints = 0;
            if (pos === 'GK' || pos === 'DEF') csPoints = avgCS * 4 * fdrFactor;
            else if (pos === 'MID') csPoints = avgCS * 1 * fdrFactor;
            
            const savePoints = pos === 'GK' ? (avgSaves / 3) * fdrFactor : 0;
            
            return {
                goals: Math.round(goalPoints * 10) / 10,
                assists: Math.round(assistPoints * 10) / 10,
                cs: Math.round(csPoints * 10) / 10,
                saves: Math.round(savePoints * 10) / 10,
                bonus: Math.round(avgBonus * 10) / 10,
                minutes: Math.round(avgMinutes)
            };
        }
        
        // Select optimal 11 from squad
        function selectOptimalLineup(playerPredictions) {
            // Filter to only valid positions
            const validPlayers = playerPredictions.filter(p => ['GK', 'DEF', 'MID', 'FWD'].includes(p.pos));
            
            const byPos = { GK: [], DEF: [], MID: [], FWD: [] };
            
            validPlayers.forEach(p => {
                byPos[p.pos].push(p);
            });
            
            // Sort each position by predicted points
            Object.keys(byPos).forEach(pos => {
                byPos[pos].sort((a, b) => b.predicted - a.predicted);
            });
            
            // FPL Formation constraints:
            // 1 GK (always), 3-5 DEF, 2-5 MID, 1-3 FWD = 11 outfield players
            const minPos = { DEF: 3, MID: 2, FWD: 1 };
            const maxPos = { DEF: 5, MID: 5, FWD: 3 };
            
            const selected = [];
            const counts = { GK: 0, DEF: 0, MID: 0, FWD: 0 };
            
            // 1 GK (required)
            if (byPos.GK.length > 0) {
                selected.push(byPos.GK.shift());
                counts.GK = 1;
            }
            
            // Fill minimum required for each outfield position
            ['DEF', 'MID', 'FWD'].forEach(pos => {
                const needed = minPos[pos];
                for (let i = 0; i < needed && byPos[pos].length > 0; i++) {
                    selected.push(byPos[pos].shift());
                    counts[pos]++;
                }
            });
            
            // Fill remaining slots (need 11 total) from best available
            const remaining = [...byPos.DEF, ...byPos.MID, ...byPos.FWD];
            remaining.sort((a, b) => b.predicted - a.predicted);
            
            while (selected.length < 11 && remaining.length > 0) {
                const next = remaining.shift();
                // Check we don't exceed max for this position
                if (counts[next.pos] < maxPos[next.pos]) {
                    selected.push(next);
                    counts[next.pos]++;
                }
            }
            
            // If we still don't have 11, fill with any available (shouldn't happen with full squad)
            if (selected.length < 11) {
                console.warn(`[Formation] Only ${selected.length} players available for lineup`);
            }
            
            // Calculate formation string
            const formation = `${counts.DEF}-${counts.MID}-${counts.FWD}`;
            
            return {
                lineup: selected,
                formation: formation
            };
        }
        
        // Calculate team uncertainty (standard deviation) based on prediction confidence
        function calculateTeamUncertainty(teamPred) {
            if (!teamPred || !teamPred.optimal11) {
                return 15; // Default high uncertainty
            }
            
            const players = teamPred.optimal11;
            
            // Count confidence levels in the optimal 11
            let lowConf = 0, medConf = 0, highConf = 0;
            players.forEach(p => {
                if (p.confidence === 'low') lowConf++;
                else if (p.confidence === 'medium') medConf++;
                else highConf++;
            });
            
            // Base uncertainty from FPL scoring variance (empirically ~12 pts std dev)
            const baseUncertainty = 12;
            
            // Add uncertainty for low confidence predictions
            // Low confidence players add more variance
            const confUncertainty = (lowConf * 2.0) + (medConf * 1.0) + (highConf * 0.5);
            
            // Scale by predicted points (higher predicted = more variance)
            const ptsScale = 1 + (teamPred.optimalPoints - 35) / 100;
            
            return Math.max(8, Math.min(20, baseUncertainty + confUncertainty) * ptsScale);
        }
        
        // Standard normal CDF approximation (for probability calculation)
        function normalCDF(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return 0.5 * (1.0 + sign * y);
        }
        
        // Calculate H2H win probability using statistical approach
        // team1Pred and team2Pred are full prediction objects (or null)
        // team1Pts and team2Pts are the expected points
        function calculateH2HWinProbability(team1Pts, team2Pts, team1Pred = null, team2Pred = null) {
            if (team1Pts === 0 && team2Pts === 0) {
                return { team1Win: 33, draw: 34, team2Win: 33 };
            }
            
            // Calculate uncertainty for each team
            const sigma1 = calculateTeamUncertainty(team1Pred);
            const sigma2 = calculateTeamUncertainty(team2Pred);
            
            // Combined standard deviation for the difference
            // If X ~ N(μ1, σ1²) and Y ~ N(μ2, σ2²), then X-Y ~ N(μ1-μ2, σ1²+σ2²)
            const sigmaDiff = Math.sqrt(sigma1 * sigma1 + sigma2 * sigma2);
            
            // Expected difference
            const muDiff = team1Pts - team2Pts;
            
            // P(Team1 wins) = P(Team1 - Team2 > 0) = P(Z > -muDiff/sigmaDiff)
            // P(Team1 wins) = normalCDF(muDiff / sigmaDiff)
            const zScore = muDiff / sigmaDiff;
            
            // Calculate probabilities
            // For "draw" we consider a small margin (±2 points difference)
            const drawMargin = 2;
            const pTeam1WinsClear = normalCDF((muDiff - drawMargin) / sigmaDiff);
            const pTeam2WinsClear = 1 - normalCDF((muDiff + drawMargin) / sigmaDiff);
            const pDraw = 1 - pTeam1WinsClear - pTeam2WinsClear;
            
            // In FPL H2H, draws are rare (exact same score needed)
            // So we redistribute most of the "close game" probability
            const drawReduction = 0.7; // Keep 30% as draw possibility
            const actualDraw = pDraw * drawReduction;
            const redistributed = pDraw * (1 - drawReduction) / 2;
            
            let team1Win = pTeam1WinsClear + redistributed;
            let team2Win = pTeam2WinsClear + redistributed;
            
            // Normalize to ensure they sum to 100
            const total = team1Win + team2Win + actualDraw;
            
            return {
                team1Win: Math.round((team1Win / total) * 100),
                draw: Math.round((actualDraw / total) * 100),
                team2Win: Math.round((team2Win / total) * 100),
                sigma1: Math.round(sigma1 * 10) / 10,
                sigma2: Math.round(sigma2 * 10) / 10
            };
        }
        
        // Render predictions tab
        async function renderPredictionsTab() {
            const selectedGW = parseInt(document.getElementById('predictionGW')?.value) || getCurrentGameweek();
            const predictions = await calculateGWPredictions(selectedGW);
            
            if (predictions.length === 0) {
                document.getElementById('predictionRankings').innerHTML = '<p style="color: var(--text-muted);">No prediction data available. Make sure league data is imported.</p>';
                return;
            }
            
            renderTeamRankings(predictions, selectedGW);
            renderH2HMatchupPredictions(predictions, selectedGW);
            renderFixtureHeatmap(selectedGW);
            renderPlayerBreakdown();
            
            // Populate Monte Carlo team selector
            if (typeof populateMCTeamSelect === 'function') {
                populateMCTeamSelect();
            }
        }
        
        // Render team rankings with bar chart
        function renderTeamRankings(predictions, gameweek) {
            const maxPts = Math.max(...predictions.map(p => p.optimalPoints));
            
            // Count players with high/medium/low confidence predictions
            const analyzeConfidence = (pred) => {
                const counts = { high: 0, medium: 0, low: 0 };
                (pred.optimal11 || []).forEach(p => {
                    if (p.confidence === 'high') counts.high++;
                    else if (p.confidence === 'medium') counts.medium++;
                    else counts.low++;
                });
                return counts;
            };
            
            let html = `<div style="margin-bottom: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem;">
                    <strong>GW${gameweek} Predictions</strong> • Batch-Based Model
                </div>
                <div style="display: flex; gap: 2rem; font-size: 0.75rem; color: var(--text-muted);">
                    <span>Teams analyzed: ${Object.keys(batchAnalysisCache.teamBatchMap).length}</span>
                    <span>Players w/ history: ${Object.keys(batchAnalysisCache.playerStats).length}</span>
                    <span>Batches: ${BATCH_CONFIG.batches.map(b => b.name).join(', ')}</span>
                </div>
            </div>`;
            
            predictions.forEach((pred, idx) => {
                const rank = idx + 1;
                const pctWidth = (pred.optimalPoints / maxPts) * 100;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : 'default';
                const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : '';
                const conf = analyzeConfidence(pred);
                
                html += `
                <div class="team-rank-bar">
                    <div class="rank-badge ${rankClass}">${medal || rank}</div>
                    <div style="min-width: 150px; font-weight: 600;">${pred.entryName}</div>
                    <div class="points-bar">
                        <div class="points-bar-fill" style="width: ${pctWidth}%;">
                            ${pred.optimalPoints.toFixed(1)}
                        </div>
                    </div>
                    <div style="min-width: 80px; text-align: right; color: var(--text-secondary); font-size: 0.85rem;">
                        ${pred.formation}
                    </div>
                    <div style="min-width: 60px; text-align: right; color: var(--text-muted); font-size: 0.8rem;">
                        +${pred.benchPoints.toFixed(1)}
                    </div>
                    <div style="min-width: 70px; text-align: right; font-size: 0.7rem;" title="Confidence: High/Med/Low">
                        <span style="color: #10b981;">${conf.high}</span>/<span style="color: #f59e0b;">${conf.medium}</span>/<span style="color: #ef4444;">${conf.low}</span>
                    </div>
                </div>`;
            });
            
            document.getElementById('predictionRankings').innerHTML = html;
        }
        
        // Render H2H matchup predictions
        function renderH2HMatchupPredictions(predictions, gameweek) {
            const matches = importedLeagueData?.matches?.filter(m => m.event === gameweek) || [];
            
            if (matches.length === 0) {
                document.getElementById('h2hMatchupPredictions').innerHTML = '<p style="color: var(--text-muted);">No H2H matches found for this gameweek.</p>';
                return;
            }
            
            const entryIdToName = {};
            (importedLeagueData?.league_entries || []).forEach(e => {
                entryIdToName[e.id] = e.entry_name;
            });
            
            const predByName = {};
            predictions.forEach(p => predByName[p.entryName] = p);
            
            let html = '<div class="predictions-grid">';
            
            matches.forEach(match => {
                const team1Name = entryIdToName[match.league_entry_1] || 'Team 1';
                const team2Name = entryIdToName[match.league_entry_2] || 'Team 2';
                const team1Pred = predByName[team1Name];
                const team2Pred = predByName[team2Name];
                
                const team1Pts = team1Pred?.optimalPoints || 0;
                const team2Pts = team2Pred?.optimalPoints || 0;
                
                const probs = calculateH2HWinProbability(team1Pts, team2Pts, team1Pred, team2Pred);
                const winner = team1Pts > team2Pts ? 'team1' : team2Pts > team1Pts ? 'team2' : 'draw';
                
                // Calculate point range (±1 standard deviation)
                const team1Range = `${(team1Pts - (probs.sigma1 || 12)).toFixed(0)}-${(team1Pts + (probs.sigma1 || 12)).toFixed(0)}`;
                const team2Range = `${(team2Pts - (probs.sigma2 || 12)).toFixed(0)}-${(team2Pts + (probs.sigma2 || 12)).toFixed(0)}`;
                
                html += `
                <div class="h2h-matchup-card">
                    <div class="h2h-teams">
                        <div class="h2h-team-name" style="color: ${winner === 'team1' ? 'var(--accent-emerald)' : 'var(--text-primary)'};">
                            ${team1Name}
                            <div style="font-size: 0.85rem; color: var(--text-muted);">${team1Pts.toFixed(1)} pts</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);" title="Predicted range (±σ)">Range: ${team1Range}</div>
                        </div>
                        <div class="h2h-vs">VS</div>
                        <div class="h2h-team-name" style="text-align: right; color: ${winner === 'team2' ? 'var(--accent-emerald)' : 'var(--text-primary)'};">
                            ${team2Name}
                            <div style="font-size: 0.85rem; color: var(--text-muted);">${team2Pts.toFixed(1)} pts</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);" title="Predicted range (±σ)">Range: ${team2Range}</div>
                        </div>
                    </div>
                    <div class="win-probability-bar">
                        <div class="win-prob-segment team1" style="width: ${probs.team1Win}%;">${probs.team1Win}%</div>
                        <div class="win-prob-segment draw" style="width: ${probs.draw}%;">${probs.draw > 10 ? probs.draw + '%' : ''}</div>
                        <div class="win-prob-segment team2" style="width: ${probs.team2Win}%;">${probs.team2Win}%</div>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-muted);">
                        <span>${team1Pred?.formation || '-'}</span>
                        <span>${team2Pred?.formation || '-'}</span>
                    </div>
                </div>`;
            });
            
            html += '</div>';
            document.getElementById('h2hMatchupPredictions').innerHTML = html;
        }
        
        // Render player breakdown table
        async function renderPlayerBreakdown() {
            const teamSelect = document.getElementById('breakdownTeamSelect');
            const showOptimalOnly = document.getElementById('showOptimal11Only')?.checked;
            
            if (!teamSelect || !teamSelect.value) {
                document.getElementById('playerBreakdownTable').innerHTML = '<p style="color: var(--text-muted);">Select a team to view breakdown.</p>';
                return;
            }
            
            const selectedGW = parseInt(document.getElementById('predictionGW')?.value) || getCurrentGameweek();
            const predictions = await calculateGWPredictions(selectedGW);
            const teamPred = predictions.find(p => String(p.entryId) === teamSelect.value);
            
            if (!teamPred) {
                document.getElementById('playerBreakdownTable').innerHTML = '<p style="color: var(--text-muted);">No data for selected team.</p>';
                return;
            }
            
            const players = showOptimalOnly ? teamPred.optimal11 : teamPred.players;
            
            // Confidence badge styling
            const confBadge = (conf) => {
                const colors = { high: '#10b981', medium: '#f59e0b', low: '#ef4444', none: '#6b7280' };
                return `<span style="color: ${colors[conf] || colors.none}; font-size: 0.7rem;">●</span>`;
            };
            
            let html = `
            <table class="player-breakdown-table">
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Pos</th>
                        <th>Team</th>
                        <th>vs</th>
                        <th>Opp Batch</th>
                        <th title="Games in batch data">Games</th>
                        <th title="Dynamic venue attack multiplier (team-specific home/away factor)" class="stat-cell">⚔️</th>
                        <th class="stat-cell">Goals</th>
                        <th class="stat-cell">Assists</th>
                        <th class="stat-cell">CS</th>
                        <th class="stat-cell">Saves</th>
                        <th class="stat-cell">Bonus</th>
                        <th class="stat-cell" title="Defensive Contribution bonus (2pts)">DC</th>
                        <th class="stat-cell">Cards</th>
                        <th class="stat-cell">Predicted</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>`;
            
            players.forEach((p, idx) => {
                const inOptimal = teamPred.optimal11.some(o => o.playerId === p.playerId);
                const rowStyle = !showOptimalOnly && !inOptimal ? 'opacity: 0.5;' : '';
                const batchColor = p.opponentBatch <= 2 ? 'var(--accent-red)' : p.opponentBatch >= 4 ? 'var(--accent-emerald)' : 'var(--text-muted)';
                
                // Venue multiplier formatting
                const venueMult = p.venueMultipliers?.attack || 1.0;
                const venueColor = venueMult >= 1.3 ? 'var(--accent-emerald)' : venueMult <= 0.7 ? 'var(--accent-red)' : 'var(--text-muted)';
                const venueTitle = p.venueMultipliers ? 
                    `Attack: ${venueMult.toFixed(2)}x | CS: ${(p.venueMultipliers.cs || 1).toFixed(2)}x | Bonus: ${(p.venueMultipliers.bonus || 1).toFixed(2)}x` : 
                    'No venue data';
                
                html += `
                <tr style="${rowStyle}">
                    <td style="font-weight: 500;"><span class="player-link" onclick="showPlayerDetail(${p.playerId})">${p.name}</span> ${inOptimal ? '⭐' : ''} ${confBadge(p.confidence)}</td>
                    <td>${p.pos}</td>
                    <td>${p.team}</td>
                    <td>${p.isHome ? '🏠' : '✈️'} ${p.opponent}</td>
                    <td style="font-size: 0.75rem; color: ${batchColor};">${p.opponentBatchName || '?'}</td>
                    <td style="font-size: 0.75rem; color: var(--text-muted);">${p.batchGames || 0}</td>
                    <td class="stat-cell" style="font-size: 0.75rem; color: ${venueColor}; font-weight: 600;" title="${venueTitle}">${venueMult.toFixed(2)}x</td>
                    <td class="stat-cell ${p.breakdown?.goals > 0 ? 'highlight' : ''}">${(p.breakdown?.goals || 0).toFixed(1)}</td>
                    <td class="stat-cell ${p.breakdown?.assists > 0 ? 'highlight' : ''}">${(p.breakdown?.assists || 0).toFixed(1)}</td>
                    <td class="stat-cell ${p.breakdown?.cs > 0 ? 'highlight' : ''}">${(p.breakdown?.cs || 0).toFixed(1)}</td>
                    <td class="stat-cell ${p.breakdown?.saves > 0 ? 'highlight' : ''}">${(p.breakdown?.saves || 0).toFixed(1)}</td>
                    <td class="stat-cell">${(p.breakdown?.bonus || 0).toFixed(1)}</td>
                    <td class="stat-cell ${p.breakdown?.dcBonus > 0 ? 'highlight' : ''}" title="Expected DC: ${p.expectedDC || 0}">${(p.breakdown?.dcBonus || 0).toFixed(1)}</td>
                    <td class="stat-cell" style="color: ${(p.breakdown?.cards || 0) < 0 ? 'var(--accent-red)' : 'var(--text-muted)'}">${(p.breakdown?.cards || 0).toFixed(1)}</td>
                    <td class="stat-cell" style="font-weight: 700; color: var(--accent-cyan);">${p.predicted.toFixed(1)}</td>
                    <td><button onclick="quickCompare(${p.playerId})" style="font-size: 0.65rem; padding: 0.2rem 0.4rem; background: var(--accent-violet); border: none; border-radius: 4px; cursor: pointer; color: white;">📊</button></td>
                </tr>`;
            });
            
            html += `</tbody></table>
            <div style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: 8px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
                <div><span style="color: var(--text-muted);">Formation:</span><br><strong>${teamPred.formation}</strong></div>
                <div><span style="color: var(--text-muted);">Optimal 11:</span><br><strong style="color: var(--accent-emerald);">${teamPred.optimalPoints.toFixed(1)} pts</strong></div>
                <div><span style="color: var(--text-muted);">Bench:</span><br><strong>+${teamPred.benchPoints.toFixed(1)} pts</strong></div>
                <div><span style="color: var(--text-muted);">Confidence:</span><br><span style="color: #10b981;">●</span> High <span style="color: #f59e0b;">●</span> Med <span style="color: #ef4444;">●</span> Low</div>
            </div>`;
            
            document.getElementById('playerBreakdownTable').innerHTML = html;
        }
        
        // Render fixture difficulty heatmap
        function renderFixtureHeatmap(currentGW) {
            if (!importedBootstrap?.fixtures || !importedBootstrap?.teams) {
                document.getElementById('fixtureHeatmap').innerHTML = '<p style="color: var(--text-muted);">No fixture data available.</p>';
                return;
            }
            
            const teams = importedBootstrap.teams;
            const fixtures = importedBootstrap.fixtures;
            
            // Build fixture map: team_id -> { gw -> {opponent, fdr, isHome} }
            const fixtureMap = {};
            teams.forEach(t => fixtureMap[t.id] = {});
            
            for (let gw = currentGW; gw <= 38; gw++) {
                const gwFixtures = fixtures[String(gw)] || [];
                gwFixtures.forEach(fix => {
                    const homeTeam = teams.find(t => t.id === fix.team_h);
                    const awayTeam = teams.find(t => t.id === fix.team_a);
                    
                    if (fixtureMap[fix.team_h]) {
                        fixtureMap[fix.team_h][gw] = {
                            opponent: awayTeam?.short_name || '?',
                            fdr: fix.team_h_difficulty || 3,
                            isHome: true
                        };
                    }
                    if (fixtureMap[fix.team_a]) {
                        fixtureMap[fix.team_a][gw] = {
                            opponent: homeTeam?.short_name || '?',
                            fdr: fix.team_a_difficulty || 3,
                            isHome: false
                        };
                    }
                });
            }
            
            // Build table HTML
            let html = '<table class="fixture-heatmap-table"><thead><tr><th>Team</th>';
            
            // GW headers (show next 10 GWs)
            const maxGW = Math.min(currentGW + 9, 38);
            for (let gw = currentGW; gw <= maxGW; gw++) {
                const isCurrentGW = gw === currentGW;
                html += `<th style="${isCurrentGW ? 'background: var(--accent-cyan); color: #000;' : ''}">GW${gw}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            // Sort teams by some criteria (e.g., alphabetically or by strength)
            const sortedTeams = [...teams].sort((a, b) => a.name.localeCompare(b.name));
            
            sortedTeams.forEach(team => {
                html += `<tr><td class="team-name" style="font-weight: 500;">${team.short_name}</td>`;
                
                for (let gw = currentGW; gw <= maxGW; gw++) {
                    const fix = fixtureMap[team.id]?.[gw];
                    if (fix) {
                        const homeIcon = fix.isHome ? '' : '(A)';
                        html += `<td class="fdr-${fix.fdr}" title="GW${gw}: ${fix.opponent} ${homeIcon}">${fix.opponent}</td>`;
                    } else {
                        html += `<td style="background: var(--bg-tertiary);">-</td>`;
                    }
                }
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            document.getElementById('fixtureHeatmap').innerHTML = html;
        }
        
        // ============================================
        // PL STATS TAB FUNCTIONS
        // ============================================
        
        async function initPLStatsTab() {
            // Ensure batch analysis is done so we have calculated standings
            if (!batchAnalysisCache.lastComputed && importedPlayerDetails && importedBootstrap) {
                await initBatchAnalysis();
            }
            renderPLStandings();
            renderPLTeamCards();
            populateMatchupSelectors();
            renderAttackDefenseChart();
        }
        
        // Render PL standings table
        function renderPLStandings() {
            if (!importedBootstrap?.teams) {
                document.getElementById('plStandingsTable').innerHTML = '<p style="color: var(--text-muted);">No team data available.</p>';
                return;
            }
            
            // Use calculated standings from batch analysis if available
            let standings = batchAnalysisCache.plStandings;
            
            // If no standings yet, calculate them
            if (!standings || standings.length === 0) {
                standings = calculatePLStandingsFromHistory();
            }
            
            // Fallback to bootstrap teams if no standings calculated
            if (!standings || standings.length === 0) {
                standings = importedBootstrap.teams.map((t, idx) => ({
                    ...t,
                    position: idx + 1,
                    points: 0,
                    goalsFor: 0,
                    goalsAgainst: 0,
                    cleanSheets: 0,
                    games: 0
                }));
            }
            
            const sourceLabels = {
                'football-data.org': '✅ Real PL standings from football-data.org API',
                'imported': '✅ Real PL standings from imported data',
                'api': '✅ Real PL standings fetched from FPL API',
                'draft_bootstrap': '📊 Standings from Draft bootstrap data',
                'bootstrap': '📊 Standings from imported bootstrap data (W/D/L/Pts)',
                'calculated': '⚠️ Estimated from GK clean sheets - NOT ACCURATE. Add a football-data.org API key for real standings!'
            };
            const sourceLabel = sourceLabels[batchAnalysisCache.standingsSource] || 'Unknown source';
            const isGoodSource = ['football-data.org', 'imported', 'api'].includes(batchAnalysisCache.standingsSource);
            const sourceColor = isGoodSource ? 'var(--accent-emerald)' : 
                               batchAnalysisCache.standingsSource === 'calculated' ? 'var(--accent-rose)' : 'var(--accent-cyan)';
            
            let html = `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: 8px; font-size: 0.8rem;">
                <strong style="color: ${sourceColor};">${sourceLabel}</strong>
            </div>
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                <thead>
                    <tr style="background: var(--bg-tertiary);">
                        <th style="padding: 0.75rem; text-align: left;">#</th>
                        <th style="padding: 0.75rem; text-align: left;">Team</th>
                        <th style="padding: 0.75rem; text-align: center;">Batch</th>
                        <th style="padding: 0.75rem; text-align: center;">GP</th>
                        <th style="padding: 0.75rem; text-align: center;">GF</th>
                        <th style="padding: 0.75rem; text-align: center;">GA</th>
                        <th style="padding: 0.75rem; text-align: center;">GD</th>
                        <th style="padding: 0.75rem; text-align: center;">CS</th>
                        <th style="padding: 0.75rem; text-align: center;">Pts</th>
                    </tr>
                </thead>
                <tbody>`;
            
            standings.forEach((team) => {
                const rank = team.position;
                const rankStyle = rank <= 4 ? 'color: var(--accent-emerald);' : rank >= 18 ? 'color: var(--accent-rose);' : '';
                const batch = batchAnalysisCache.teamBatchMap[team.id];
                const batchColor = batch?.batchId <= 2 ? 'var(--accent-emerald)' : batch?.batchId >= 4 ? 'var(--accent-rose)' : 'var(--text-muted)';
                const gd = team.goalsFor - team.goalsAgainst;
                const gdColor = gd > 0 ? 'var(--accent-emerald)' : gd < 0 ? 'var(--accent-rose)' : 'var(--text-muted)';
                
                html += `
                <tr style="border-bottom: 1px solid var(--border-color);">
                    <td style="padding: 0.75rem; font-weight: 600; ${rankStyle}">${rank}</td>
                    <td style="padding: 0.75rem; font-weight: 500;">${team.name || team.short_name}</td>
                    <td style="padding: 0.75rem; text-align: center; font-size: 0.75rem; color: ${batchColor};">${batch?.batchName || '?'}</td>
                    <td style="padding: 0.75rem; text-align: center;">${team.games || 0}</td>
                    <td style="padding: 0.75rem; text-align: center; color: var(--accent-emerald);">${team.goalsFor || 0}</td>
                    <td style="padding: 0.75rem; text-align: center; color: var(--accent-rose);">${team.goalsAgainst || 0}</td>
                    <td style="padding: 0.75rem; text-align: center; color: ${gdColor};">${gd > 0 ? '+' : ''}${gd}</td>
                    <td style="padding: 0.75rem; text-align: center;">${team.cleanSheets || 0}</td>
                    <td style="padding: 0.75rem; text-align: center; font-weight: 700;">${team.points || 0}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            document.getElementById('plStandingsTable').innerHTML = html;
        }
        
        // Render PL team cards
        function renderPLTeamCards() {
            // Use calculated standings
            let standings = batchAnalysisCache.plStandings;
            if (!standings || standings.length === 0) {
                document.getElementById('plTeamCards').innerHTML = '<p style="color: var(--text-muted);">No calculated standings available. Go to GW Simulation tab first to compute.</p>';
                return;
            }
            
            const filter = document.getElementById('plTeamFilter')?.value || 'all';
            const sort = document.getElementById('plStatSort')?.value || 'rank';
            
            let teams = [...standings];
            
            // Apply filter based on calculated position
            if (filter === 'top6') {
                teams = teams.filter(t => t.position <= 6);
            } else if (filter === 'mid') {
                teams = teams.filter(t => t.position >= 7 && t.position <= 14);
            } else if (filter === 'bottom') {
                teams = teams.filter(t => t.position >= 15);
            }
            
            // Apply sorting
            if (sort === 'attack') {
                teams.sort((a, b) => b.goalsFor - a.goalsFor);
            } else if (sort === 'defense') {
                teams.sort((a, b) => a.goalsAgainst - b.goalsAgainst); // Lower is better
            } else {
                teams.sort((a, b) => a.position - b.position);
            }
            
            let html = '';
            
            teams.forEach((team) => {
                const gf = team.goalsFor || 0;
                const ga = team.goalsAgainst || 0;
                const gd = gf - ga;
                const cs = team.cleanSheets || 0;
                const gp = team.games || 0;
                const batch = batchAnalysisCache.teamBatchMap[team.id];
                
                // Calculate per-game stats
                const gfPG = gp > 0 ? (gf / gp).toFixed(2) : '0.00';
                const gaPG = gp > 0 ? (ga / gp).toFixed(2) : '0.00';
                const csRate = gp > 0 ? ((cs / gp) * 100).toFixed(0) : '0';
                
                const posColor = team.position <= 4 ? 'var(--accent-emerald)' : team.position >= 18 ? 'var(--accent-rose)' : 'var(--text-secondary)';
                
                html += `
                <div class="pl-team-card">
                    <div class="pl-team-header">
                        <div class="pl-team-name">${team.name || team.short_name}</div>
                        <div class="pl-team-rank" style="color: ${posColor};">#${team.position}</div>
                    </div>
                    <div class="pl-stats-grid">
                        <div class="pl-stat">
                            <div class="pl-stat-value" style="color: var(--accent-violet);">${team.points}</div>
                            <div class="pl-stat-label">Points</div>
                        </div>
                        <div class="pl-stat">
                            <div class="pl-stat-value" style="color: var(--accent-emerald);">${gf}</div>
                            <div class="pl-stat-label">Goals For</div>
                        </div>
                        <div class="pl-stat">
                            <div class="pl-stat-value" style="color: var(--accent-rose);">${ga}</div>
                            <div class="pl-stat-label">Goals Agst</div>
                        </div>
                        <div class="pl-stat">
                            <div class="pl-stat-value" style="color: ${gd >= 0 ? 'var(--accent-cyan)' : 'var(--accent-amber)'};">${gd > 0 ? '+' : ''}${gd}</div>
                            <div class="pl-stat-label">Goal Diff</div>
                        </div>
                    </div>
                    <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem; font-size: 0.75rem;">
                        <div style="text-align: center; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px;">
                            <div style="color: var(--text-muted);">GF/Game</div>
                            <div style="font-weight: 600; color: var(--accent-emerald);">${gfPG}</div>
                        </div>
                        <div style="text-align: center; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px;">
                            <div style="color: var(--text-muted);">GA/Game</div>
                            <div style="font-weight: 600; color: var(--accent-rose);">${gaPG}</div>
                        </div>
                        <div style="text-align: center; padding: 0.5rem; background: var(--bg-secondary); border-radius: 6px;">
                            <div style="color: var(--text-muted);">CS Rate</div>
                            <div style="font-weight: 600; color: var(--accent-cyan);">${csRate}%</div>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; text-align: center; font-size: 0.7rem; color: var(--text-muted);">
                        Batch: <span style="color: ${batch?.batchId <= 2 ? 'var(--accent-emerald)' : batch?.batchId >= 4 ? 'var(--accent-rose)' : 'var(--text-secondary)'};">${batch?.batchName || '?'}</span>
                    </div>
                </div>`;
            });
            
            document.getElementById('plTeamCards').innerHTML = html;
        }
        
        // ========== MATCHUP PREDICTOR ==========
        
        function populateMatchupSelectors() {
            const standings = batchAnalysisCache.plStandings;
            if (!standings || standings.length === 0) return;
            
            const homeSelect = document.getElementById('matchupHomeTeam');
            const awaySelect = document.getElementById('matchupAwayTeam');
            
            if (!homeSelect || !awaySelect) return;
            
            // Sort by position
            const sortedTeams = [...standings].sort((a, b) => a.position - b.position);
            
            // Clear and repopulate
            homeSelect.innerHTML = '<option value="">Select home team...</option>';
            awaySelect.innerHTML = '<option value="">Select away team...</option>';
            
            sortedTeams.forEach(team => {
                const batch = getBatchLabel(team.position);
                const option1 = document.createElement('option');
                option1.value = team.id;
                option1.textContent = `${team.position}. ${team.name || team.short_name} (${batch})`;
                homeSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = team.id;
                option2.textContent = `${team.position}. ${team.name || team.short_name} (${batch})`;
                awaySelect.appendChild(option2);
            });
        }
        
        function getBatchLabel(position) {
            if (position <= 4) return 'Top 4';
            if (position <= 8) return 'Upper Mid';
            if (position <= 12) return 'Mid Table';
            if (position <= 16) return 'Lower Mid';
            return 'Bottom 4';
        }
        
        function getBatchRange(position) {
            if (position <= 4) return '1-4';
            if (position <= 8) return '5-8';
            if (position <= 12) return '9-12';
            if (position <= 16) return '13-16';
            return '17-20';
        }
        
        function calculateMatchupPrediction() {
            const homeSelect = document.getElementById('matchupHomeTeam');
            const awaySelect = document.getElementById('matchupAwayTeam');
            const resultDiv = document.getElementById('matchupResult');
            
            const homeTeamId = parseInt(homeSelect.value);
            const awayTeamId = parseInt(awaySelect.value);
            
            if (!homeTeamId || !awayTeamId) {
                resultDiv.style.display = 'none';
                return;
            }
            
            if (homeTeamId === awayTeamId) {
                resultDiv.style.display = 'block';
                resultDiv.innerHTML = '<p style="color: var(--accent-amber);">⚠️ Please select two different teams</p>';
                return;
            }
            
            const standings = batchAnalysisCache.plStandings;
            if (!standings) return;
            
            const homeTeam = standings.find(t => t.id === homeTeamId);
            const awayTeam = standings.find(t => t.id === awayTeamId);
            
            if (!homeTeam || !awayTeam) return;
            
            // Calculate predicted goals using batch logic
            const prediction = predictMatchScore(homeTeam, awayTeam);
            
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = renderMatchupResult(homeTeam, awayTeam, prediction);
        }
        
        function predictMatchScore(homeTeam, awayTeam) {
            const standings = batchAnalysisCache.plStandings;
            const teamStats = batchAnalysisCache.teamStats || {};
            
            // Get batch info
            const homeBatch = getBatchRange(homeTeam.position);
            const awayBatch = getBatchRange(awayTeam.position);
            
            // Base stats (per game)
            const homeGames = homeTeam.games || homeTeam.played || 1;
            const awayGames = awayTeam.games || awayTeam.played || 1;
            
            const homeBaseGF = (homeTeam.goalsFor || 0) / homeGames;
            const homeBaseGA = (homeTeam.goalsAgainst || 0) / homeGames;
            const awayBaseGF = (awayTeam.goalsFor || 0) / awayGames;
            const awayBaseGA = (awayTeam.goalsAgainst || 0) / awayGames;
            
            // League averages
            const totalGames = standings.reduce((sum, t) => sum + (t.games || t.played || 0), 0) / 2;
            const totalGoals = standings.reduce((sum, t) => sum + (t.goalsFor || 0), 0);
            const leagueAvgGoals = totalGames > 0 ? totalGoals / totalGames : 1.4;
            
            // Home advantage factor (typically +0.3-0.4 goals)
            const homeAdvantage = 1.15;
            const awayDisadvantage = 0.85;
            
            // Batch-adjusted calculations
            // Home team attacking vs Away team defending
            let homeExpectedGoals = homeBaseGF;
            // How good is home team at scoring? (vs league avg)
            const homeAttackStrength = homeBaseGF / leagueAvgGoals;
            // How bad is away team at defending? (vs league avg)
            const awayDefenseWeakness = awayBaseGA / leagueAvgGoals;
            
            // Home expected = league avg * home attack strength * away defense weakness * home advantage
            homeExpectedGoals = leagueAvgGoals * homeAttackStrength * awayDefenseWeakness * homeAdvantage;
            
            // Away team attacking vs Home team defending
            let awayExpectedGoals = awayBaseGF;
            const awayAttackStrength = awayBaseGF / leagueAvgGoals;
            const homeDefenseWeakness = homeBaseGA / leagueAvgGoals;
            
            awayExpectedGoals = leagueAvgGoals * awayAttackStrength * homeDefenseWeakness * awayDisadvantage;
            
            // Batch modifier - teams perform differently vs different level opponents
            const batchModifiers = {
                'vs-top': { attack: 0.8, defense: 1.2 },      // Harder to score, easier to concede
                'vs-mid': { attack: 1.0, defense: 1.0 },      // Normal
                'vs-bottom': { attack: 1.2, defense: 0.85 }   // Easier to score, harder to concede
            };
            
            // Apply batch modifiers
            let homeVsAwayBatchMod = batchModifiers['vs-mid'];
            let awayVsHomeBatchMod = batchModifiers['vs-mid'];
            
            if (awayTeam.position <= 4) homeVsAwayBatchMod = batchModifiers['vs-top'];
            else if (awayTeam.position >= 17) homeVsAwayBatchMod = batchModifiers['vs-bottom'];
            
            if (homeTeam.position <= 4) awayVsHomeBatchMod = batchModifiers['vs-top'];
            else if (homeTeam.position >= 17) awayVsHomeBatchMod = batchModifiers['vs-bottom'];
            
            homeExpectedGoals *= homeVsAwayBatchMod.attack;
            awayExpectedGoals *= awayVsHomeBatchMod.attack;
            
            // Cap at reasonable values
            homeExpectedGoals = Math.max(0.3, Math.min(4.0, homeExpectedGoals));
            awayExpectedGoals = Math.max(0.2, Math.min(3.5, awayExpectedGoals));
            
            // Calculate win probabilities using Poisson-ish approximation
            const homeWinProb = calculateWinProbability(homeExpectedGoals, awayExpectedGoals);
            const drawProb = calculateDrawProbability(homeExpectedGoals, awayExpectedGoals);
            const awayWinProb = 1 - homeWinProb - drawProb;
            
            // Most likely scoreline
            const homeRounded = Math.round(homeExpectedGoals);
            const awayRounded = Math.round(awayExpectedGoals);
            
            return {
                homeGoals: homeExpectedGoals,
                awayGoals: awayExpectedGoals,
                homeRounded,
                awayRounded,
                homeWinProb,
                drawProb,
                awayWinProb,
                homeAttackStrength,
                awayAttackStrength,
                homeDefenseWeakness,
                awayDefenseWeakness,
                homeBatch,
                awayBatch,
                leagueAvgGoals
            };
        }
        
        function calculateWinProbability(teamAGoals, teamBGoals) {
            // Simplified probability calculation
            const diff = teamAGoals - teamBGoals;
            // Using logistic function for smooth probability
            const prob = 1 / (1 + Math.exp(-diff * 1.2));
            // Adjust for draw probability
            return Math.max(0.05, Math.min(0.85, prob * 0.85));
        }
        
        function calculateDrawProbability(homeGoals, awayGoals) {
            // Draws more likely when expected goals are close
            const diff = Math.abs(homeGoals - awayGoals);
            const avgGoals = (homeGoals + awayGoals) / 2;
            // Base draw prob around 25%, adjusted by closeness
            return Math.max(0.1, Math.min(0.35, 0.30 - diff * 0.15 + (1.5 - avgGoals) * 0.05));
        }
        
        function renderMatchupResult(homeTeam, awayTeam, pred) {
            const homeWinPct = (pred.homeWinProb * 100).toFixed(0);
            const drawPct = (pred.drawProb * 100).toFixed(0);
            const awayWinPct = (pred.awayWinProb * 100).toFixed(0);
            
            return `
            <div style="background: var(--bg-secondary); border-radius: 12px; padding: 1.5rem; margin-top: 1rem;">
                <!-- Score Prediction -->
                <div style="display: flex; justify-content: center; align-items: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.25rem;">HOME</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: var(--accent-emerald);">${homeTeam.name || homeTeam.short_name}</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">Batch: ${pred.homeBatch}</div>
                    </div>
                    
                    <div style="text-align: center;">
                        <div style="font-size: 3rem; font-weight: 700; color: var(--text-primary); letter-spacing: 0.1em;">
                            ${pred.homeRounded} - ${pred.awayRounded}
                        </div>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">
                            xG: ${pred.homeGoals.toFixed(2)} - ${pred.awayGoals.toFixed(2)}
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.25rem;">AWAY</div>
                        <div style="font-size: 1.1rem; font-weight: 600; color: var(--accent-rose);">${awayTeam.name || awayTeam.short_name}</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">Batch: ${pred.awayBatch}</div>
                    </div>
                </div>
                
                <!-- Win Probability Bar -->
                <div style="margin-bottom: 1.5rem;">
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 0.5rem;">
                        <span style="color: var(--accent-emerald);">Home Win ${homeWinPct}%</span>
                        <span style="color: var(--text-muted);">Draw ${drawPct}%</span>
                        <span style="color: var(--accent-rose);">Away Win ${awayWinPct}%</span>
                    </div>
                    <div style="display: flex; height: 12px; border-radius: 6px; overflow: hidden;">
                        <div style="width: ${homeWinPct}%; background: var(--accent-emerald);"></div>
                        <div style="width: ${drawPct}%; background: var(--text-muted);"></div>
                        <div style="width: ${awayWinPct}%; background: var(--accent-rose);"></div>
                    </div>
                </div>
                
                <!-- Detailed Stats -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px;">
                        <div style="font-size: 0.85rem; color: var(--accent-emerald); margin-bottom: 0.5rem; font-weight: 600;">
                            ${homeTeam.short_name || homeTeam.name} Stats
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                <span>Attack Strength:</span>
                                <span style="color: ${pred.homeAttackStrength > 1 ? 'var(--accent-emerald)' : 'var(--accent-rose)'};">
                                    ${(pred.homeAttackStrength * 100).toFixed(0)}%
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                <span>Defense Weakness:</span>
                                <span style="color: ${pred.homeDefenseWeakness < 1 ? 'var(--accent-emerald)' : 'var(--accent-rose)'};">
                                    ${(pred.homeDefenseWeakness * 100).toFixed(0)}%
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>Goals/Game:</span>
                                <span>${((homeTeam.goalsFor || 0) / (homeTeam.games || 1)).toFixed(2)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>Conceded/Game:</span>
                                <span>${((homeTeam.goalsAgainst || 0) / (homeTeam.games || 1)).toFixed(2)}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px;">
                        <div style="font-size: 0.85rem; color: var(--accent-rose); margin-bottom: 0.5rem; font-weight: 600;">
                            ${awayTeam.short_name || awayTeam.name} Stats
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                <span>Attack Strength:</span>
                                <span style="color: ${pred.awayAttackStrength > 1 ? 'var(--accent-emerald)' : 'var(--accent-rose)'};">
                                    ${(pred.awayAttackStrength * 100).toFixed(0)}%
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                <span>Defense Weakness:</span>
                                <span style="color: ${pred.awayDefenseWeakness < 1 ? 'var(--accent-emerald)' : 'var(--accent-rose)'};">
                                    ${(pred.awayDefenseWeakness * 100).toFixed(0)}%
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>Goals/Game:</span>
                                <span>${((awayTeam.goalsFor || 0) / (awayTeam.games || 1)).toFixed(2)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>Conceded/Game:</span>
                                <span>${((awayTeam.goalsAgainst || 0) / (awayTeam.games || 1)).toFixed(2)}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Methodology Note -->
                <div style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-primary); border-radius: 6px; font-size: 0.75rem; color: var(--text-muted);">
                    <strong>Methodology:</strong> xG = League Avg (${pred.leagueAvgGoals.toFixed(2)}) × Attack Strength × Opponent Defense Weakness × Home/Away Factor × Batch Modifier
                </div>
            </div>
            `;
        }
        
        // Render attack vs defense comparison chart
        function renderAttackDefenseChart() {
            let standings = batchAnalysisCache.plStandings;
            if (!standings || standings.length === 0) {
                document.getElementById('attackDefenseChart').innerHTML = '<p style="color: var(--text-muted);">No calculated standings available.</p>';
                return;
            }
            
            // Find max values for scaling
            const maxGF = Math.max(...standings.map(t => t.goalsFor || 0));
            const maxGA = Math.max(...standings.map(t => t.goalsAgainst || 0));
            
            let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
            
            // Sort by goals for (attack)
            const sortedTeams = [...standings].sort((a, b) => (b.goalsFor || 0) - (a.goalsFor || 0));
            
            sortedTeams.forEach(team => {
                const gf = team.goalsFor || 0;
                const ga = team.goalsAgainst || 0;
                const gfPct = maxGF > 0 ? (gf / maxGF) * 100 : 0;
                const gaPct = maxGA > 0 ? (ga / maxGA) * 100 : 0;
                
                html += `
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <div style="width: 50px; font-size: 0.75rem; font-weight: 500;">${team.short_name}</div>
                    <div style="flex: 1; display: flex; gap: 2px; height: 20px;">
                        <div style="width: ${gfPct}%; background: linear-gradient(90deg, var(--accent-emerald), #34d399); border-radius: 4px 0 0 4px;" title="Goals For: ${gf}"></div>
                        <div style="width: ${gaPct}%; background: linear-gradient(90deg, var(--accent-rose), #f87171); border-radius: 0 4px 4px 0;" title="Goals Against: ${ga}"></div>
                    </div>
                    <div style="width: 70px; font-size: 0.75rem; text-align: right;">
                        <span style="color: var(--accent-emerald);">${gf}</span> / <span style="color: var(--accent-rose);">${ga}</span>
                    </div>
                </div>`;
            });
            
            html += '</div>';
            html += `<div style="margin-top: 1rem; display: flex; gap: 1.5rem; font-size: 0.75rem; color: var(--text-muted);">
                <span><span style="display: inline-block; width: 12px; height: 12px; background: var(--accent-emerald); border-radius: 2px; margin-right: 4px;"></span>Goals Scored</span>
                <span><span style="display: inline-block; width: 12px; height: 12px; background: var(--accent-rose); border-radius: 2px; margin-right: 4px;"></span>Goals Conceded</span>
            </div>`;
            
            document.getElementById('attackDefenseChart').innerHTML = html;
        }
        
        // ============================================
        // SIMULATION TAB FUNCTIONS
        // ============================================
        
        let simulationData = null;
        
        // Render simulation tab
        function renderSimulationTab() {
            if (!simulationData) {
                // Try to auto-generate from current data
                if (importedLeagueData && importedBootstrap) {
                    useCurrentData();
                }
            }
        }
        
        // Load simulation from JSON file
        function loadSimulationFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    simulationData = JSON.parse(e.target.result);
                    renderSimulationResults();
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // Use current imported data to generate simulation
        async function useCurrentData() {
            if (!importedLeagueData || !importedBootstrap) {
                document.getElementById('simulationResults').innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--accent-rose);">
                        <p>⚠️ No league data imported. Please import data first using the bookmarklet.</p>
                    </div>`;
                return;
            }
            
            const currentGW = getCurrentGameweek();
            const predictions = await calculateGWPredictions(currentGW);
            
            simulationData = {
                gameweek: currentGW,
                generatedAt: new Date().toISOString(),
                predictions: predictions,
                fixtures: getGWFixtures(currentGW),
                h2hMatches: getH2HMatches(currentGW)
            };
            
            renderSimulationResults();
        }
        
        // Get fixtures for a gameweek
        function getGWFixtures(gw) {
            const fixtures = importedBootstrap?.fixtures?.[String(gw)] || [];
            return fixtures.map(fix => ({
                home: fplTeamIdMap[fix.team_h] || '?',
                away: fplTeamIdMap[fix.team_a] || '?',
                homeFDR: fix.team_h_difficulty || 3,
                awayFDR: fix.team_a_difficulty || 3
            }));
        }
        
        // Get H2H matches for a gameweek
        function getH2HMatches(gw) {
            const matches = importedLeagueData?.matches?.filter(m => m.event === gw) || [];
            const entryIdToName = {};
            (importedLeagueData?.league_entries || []).forEach(e => {
                entryIdToName[e.id] = e.entry_name;
            });
            
            return matches.map(m => ({
                team1: entryIdToName[m.league_entry_1] || 'Team 1',
                team2: entryIdToName[m.league_entry_2] || 'Team 2',
                team1Id: m.league_entry_1,
                team2Id: m.league_entry_2
            }));
        }
        
        // Render simulation results
        function renderSimulationResults() {
            if (!simulationData || !simulationData.predictions) {
                document.getElementById('simulationResults').innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                        <p>No simulation data available.</p>
                    </div>`;
                return;
            }
            
            const { predictions, gameweek, generatedAt, fixtures, h2hMatches } = simulationData;
            const maxPts = Math.max(...predictions.map(p => p.optimalPoints));
            
            let html = `
            <!-- Meta Info -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 12px; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                <div>
                    <span style="color: var(--accent-cyan); font-weight: 600;">GW${gameweek}</span> Simulation
                </div>
                <div style="color: var(--text-muted); font-size: 0.85rem;">
                    Generated: ${new Date(generatedAt).toLocaleString()}
                </div>
            </div>
            
            <!-- PL Fixtures -->
            <div class="stat-card" style="margin-bottom: 1.5rem; border: 1px solid var(--border-color);">
                <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">⚽ GW${gameweek} Premier League Fixtures</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.75rem;">
                    ${(fixtures || []).map(f => `
                        <div style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                            <span class="fdr-${f.homeFDR}" style="padding: 2px 6px; border-radius: 4px; font-weight: 500;">${f.home}</span>
                            <span style="color: var(--text-muted);">vs</span>
                            <span class="fdr-${f.awayFDR}" style="padding: 2px 6px; border-radius: 4px; font-weight: 500;">${f.away}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <!-- Team Rankings -->
            <div class="stat-card" style="margin-bottom: 1.5rem; border: 2px solid var(--accent-emerald);">
                <h4 style="color: var(--accent-emerald); margin-bottom: 1rem;">🏆 Predicted Team Rankings</h4>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                        <thead>
                            <tr style="background: var(--bg-tertiary);">
                                <th style="padding: 0.75rem; text-align: left;">Rank</th>
                                <th style="padding: 0.75rem; text-align: left;">Team</th>
                                <th style="padding: 0.75rem; text-align: center;">Formation</th>
                                <th style="padding: 0.75rem; text-align: center;">Optimal 11</th>
                                <th style="padding: 0.75rem; text-align: center;">Bench</th>
                                <th style="padding: 0.75rem; text-align: left;">Points Bar</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${predictions.map((p, idx) => {
                                const rank = idx + 1;
                                const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : rank;
                                const pctWidth = (p.optimalPoints / maxPts) * 100;
                                return `
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 0.75rem; font-weight: 700;">${medal}</td>
                                    <td style="padding: 0.75rem; font-weight: 600;">${p.entryName}</td>
                                    <td style="padding: 0.75rem; text-align: center; font-family: 'JetBrains Mono', monospace;">${p.formation}</td>
                                    <td style="padding: 0.75rem; text-align: center; font-weight: 700; color: var(--accent-emerald);">${p.optimalPoints.toFixed(1)}</td>
                                    <td style="padding: 0.75rem; text-align: center; color: var(--text-muted);">+${p.benchPoints.toFixed(1)}</td>
                                    <td style="padding: 0.75rem;">
                                        <div style="background: var(--bg-secondary); height: 20px; border-radius: 10px; overflow: hidden;">
                                            <div style="width: ${pctWidth}%; height: 100%; background: linear-gradient(90deg, var(--accent-emerald), var(--accent-cyan)); border-radius: 10px;"></div>
                                        </div>
                                    </td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- H2H Matchups -->
            <div class="stat-card" style="margin-bottom: 1.5rem; border: 2px solid var(--accent-amber);">
                <h4 style="color: var(--accent-amber); margin-bottom: 1rem;">⚔️ H2H Matchup Predictions</h4>
                <div class="predictions-grid">
                    ${(h2hMatches || []).map(match => {
                        const team1Pred = predictions.find(p => p.entryName === match.team1);
                        const team2Pred = predictions.find(p => p.entryName === match.team2);
                        const team1Pts = team1Pred?.optimalPoints || 0;
                        const team2Pts = team2Pred?.optimalPoints || 0;
                        const probs = calculateH2HWinProbability(team1Pts, team2Pts, team1Pred, team2Pred);
                        const winner = team1Pts > team2Pts ? 'team1' : team2Pts > team1Pts ? 'team2' : 'draw';
                        
                        return `
                        <div class="h2h-matchup-card" style="${winner === 'team1' ? 'border-left: 4px solid var(--accent-cyan);' : winner === 'team2' ? 'border-right: 4px solid var(--accent-violet);' : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                <div style="font-weight: 600; ${winner === 'team1' ? 'color: var(--accent-emerald);' : ''}">${match.team1}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">VS</div>
                                <div style="font-weight: 600; text-align: right; ${winner === 'team2' ? 'color: var(--accent-emerald);' : ''}">${match.team2}</div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.9rem;">
                                <div style="color: var(--accent-cyan); font-weight: 700;">${team1Pts.toFixed(1)} pts</div>
                                <div style="color: var(--accent-violet); font-weight: 700;">${team2Pts.toFixed(1)} pts</div>
                            </div>
                            <div class="win-probability-bar">
                                <div class="win-prob-segment team1" style="width: ${probs.team1Win}%;">${probs.team1Win > 15 ? probs.team1Win + '%' : ''}</div>
                                <div class="win-prob-segment draw" style="width: ${probs.draw}%;"></div>
                                <div class="win-prob-segment team2" style="width: ${probs.team2Win}%;">${probs.team2Win > 15 ? probs.team2Win + '%' : ''}</div>
                            </div>
                        </div>`;
                    }).join('')}
                </div>
            </div>
            
            <!-- Top Players by Team -->
            <div class="stat-card" style="border: 2px solid var(--accent-violet);">
                <h4 style="color: var(--accent-violet); margin-bottom: 1rem;">⭐ Top Predicted Players by Team</h4>
                <div class="predictions-grid">
                    ${predictions.map(team => `
                        <div class="prediction-card">
                            <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--accent-cyan);">${team.entryName}</div>
                            <div style="font-size: 0.85rem;">
                                ${team.optimal11.slice(0, 5).map((p, i) => `
                                    <div style="display: flex; justify-content: space-between; padding: 0.35rem 0; border-bottom: 1px solid var(--border-color);">
                                        <span>${i + 1}. <span class="player-link" onclick="showPlayerDetail(${p.playerId})">${p.name}</span> <span style="color: var(--text-muted);">(${p.pos})</span></span>
                                        <span style="font-weight: 600; color: var(--accent-emerald);">${p.predicted.toFixed(1)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>`;
            
            document.getElementById('simulationResults').innerHTML = html;
        }
        
        // ============================================
        // FREE AGENTS & SCORE DISTRIBUTION SYSTEM
        // ============================================
        
        let freeAgentsData = [];
        let freeAgentsByPosition = {};
        
        function initFreeAgents() {
            // Populate gameweek dropdown
            const gwSelect = document.getElementById('faGameweek');
            if (gwSelect && gwSelect.options.length === 0) {
                const currentGW = getCurrentGameweek();
                for (let gw = currentGW; gw <= 38; gw++) {
                    const opt = document.createElement('option');
                    opt.value = gw;
                    opt.textContent = `GW${gw}`;
                    if (gw === currentGW + 1) opt.selected = true;
                    gwSelect.appendChild(opt);
                }
            }
            
            // Load free agents data
            loadFreeAgents();
        }
        
        async function loadFreeAgents() {
            const loading = document.getElementById('faLoading');
            const tableEl = document.getElementById('faTable');
            
            if (loading) loading.style.display = 'block';
            if (tableEl) tableEl.innerHTML = '';
            
            const gameweek = parseInt(document.getElementById('faGameweek')?.value) || (getCurrentGameweek() + 1);
            const positionStr = document.getElementById('faPosition')?.value || '';
            const positionMap = { 'GK': 1, 'DEF': 2, 'MID': 3, 'FWD': 4 };
            const position = positionStr ? positionMap[positionStr] : null;
            
            // Try DataService (cache → DB) first
            if (typeof DataService !== 'undefined') {
                try {
                    console.log('[Free Agents] Trying DataService (cache → DB)...');
                    const players = await DataService.getFreeAgents(gameweek, position, 50);
                    
                    if (players && players.length > 0) {
                        console.log(`[Free Agents] Got ${players.length} free agents from DataService`);
                        
                        // Double-check ownership locally as a safeguard
                        const ownedIds = getAllOwnedPlayerIds();
                        console.log(`[Free Agents] Local ownership check: ${ownedIds.size} owned players`);
                        
                        // Filter out any owned players (safety check)
                        const trulyFree = players.filter(p => !ownedIds.has(p.id));
                        if (trulyFree.length < players.length) {
                            console.warn(`[Free Agents] ⚠️ Filtered out ${players.length - trulyFree.length} owned players that DB returned`);
                        }
                        
                        // Convert to display format
                        freeAgentsData = trulyFree.map(p => {
                            // Get recent scores from player details if available
                            const details = importedPlayerDetails?.[p.id] || {};
                            const history = details.history || [];
                            const recent_scores = history.filter(h => h.minutes >= 10).map(h => h.total_points).slice(-10);
                            
                            return {
                                player_id: p.id,
                                name: p.web_name,
                                team: p.team_name || 'Unknown',
                                position: { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' }[p.position] || 'MID',
                                expected: p.recent_form || p.points_per_game || 0,
                                upside: (p.recent_form || p.points_per_game || 0) * 1.5,
                                floor: Math.max(1, (p.recent_form || p.points_per_game || 0) * 0.5),
                                ci_80: [
                                    Math.max(1, Math.round((p.recent_form || 3) - (p.std_points || 3))),
                                    Math.round((p.recent_form || 3) + (p.std_points || 5))
                                ],
                                form_trend: (p.recent_form || 0) > (p.points_per_game || 0) ? 'HOT' : 
                                            (p.recent_form || 0) < (p.points_per_game || 0) ? 'COLD' : 'STABLE',
                                form_ewma: p.recent_form || p.form || 0,
                                games_played: p.games_played || 0,
                                recent_scores: recent_scores,
                                status: p.status
                            };
                        });
                        
                        renderFreeAgentsTable();
                        
                        // Try to get by-position data
                        try {
                            const response = await fetch(`/api/db/free-agents/by-position?gameweek=${gameweek}&per_position=3`);
                            const byPosData = await response.json();
                            if (byPosData.by_position) {
                                freeAgentsByPosition = {};
                                for (const [pos, posPlayers] of Object.entries(byPosData.by_position)) {
                                    freeAgentsByPosition[pos] = posPlayers.map(p => ({
                                        name: p.web_name,
                                        team: p.team_name || 'Unknown',
                                        expected: p.recent_form || p.points_per_game || 0,
                                        ci_80: [1, 10]
                                    }));
                                }
                                updateBestByPositionCards();
                            }
                        } catch (e) {
                            console.warn('[Free Agents] By-position fetch failed:', e);
                        }
                        
                        calculateLocalDifferentials(gameweek);
                        
                        if (loading) loading.style.display = 'none';
                        return;
                    }
                } catch (e) {
                    console.warn('[Free Agents] DataService error:', e);
                }
            }
            
            // Fallback to local calculation
            console.log('[Free Agents] Falling back to local calculation');
            calculateLocalFreeAgents(gameweek, positionStr);
            calculateLocalBestByPosition(gameweek);
            calculateLocalDifferentials(gameweek);
            
            if (loading) loading.style.display = 'none';
        }
        
        async function loadFreeAgentsByPosition(gameweek) {
            try {
                const response = await fetch(`/api/free-agents/by-position?gameweek=${gameweek}&per_position=3`);
                if (response.ok) {
                    const data = await response.json();
                    freeAgentsByPosition = data.by_position || {};
                    updateBestByPositionCards();
                }
            } catch (e) {
                console.warn('Failed to load by-position data:', e);
            }
        }
        
        async function loadDifferentials(gameweek) {
            try {
                const response = await fetch(`/api/free-agents/differentials?gameweek=${gameweek}&top_n=5`);
                if (response.ok) {
                    const data = await response.json();
                    renderDifferentials(data.differentials || []);
                }
            } catch (e) {
                console.warn('Failed to load differentials:', e);
            }
        }
        
        function updateBestByPositionCards() {
            for (const pos of ['GK', 'DEF', 'MID', 'FWD']) {
                const el = document.getElementById(`faBest${pos}`);
                const players = freeAgentsByPosition[pos] || [];
                
                if (el && players.length > 0) {
                    const best = players[0];
                    el.innerHTML = `
                        <div style="font-weight: 600; color: var(--text-primary);">${best.name}</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">${best.team}</div>
                        <div style="margin-top: 0.25rem;">
                            <span style="color: var(--accent-cyan);">${best.expected.toFixed(1)} pts</span>
                            <span style="color: var(--text-muted); margin-left: 0.5rem; font-size: 0.75rem;">
                                (${best.ci_80[0]}-${best.ci_80[1]})
                            </span>
                        </div>
                    `;
                }
            }
        }
        
        function renderDifferentials(differentials) {
            const el = document.getElementById('faDifferentials');
            if (!el || differentials.length === 0) return;
            
            const html = `
                <table class="standings-table" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Team</th>
                            <th>Pos</th>
                            <th>Expected</th>
                            <th>Upside</th>
                            <th>Floor</th>
                            <th>Form</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${differentials.map(p => `
                            <tr onclick="showPlayerDistribution(${p.player_id})" style="cursor: pointer;">
                                <td style="font-weight: 500;">${p.name}</td>
                                <td>${p.team}</td>
                                <td><span class="pos-badge pos-${p.position}">${p.position}</span></td>
                                <td>${p.expected.toFixed(1)}</td>
                                <td style="color: var(--accent-emerald); font-weight: 600;">${p.upside.toFixed(1)}</td>
                                <td style="color: var(--text-muted);">${p.floor.toFixed(1)}</td>
                                <td>
                                    <span class="form-badge form-${p.form_trend || 'stable'}">${p.form_trend || 'stable'}</span>
                                    <span style="margin-left: 0.25rem; font-size: 0.8rem;">${(p.form_ewma || 0).toFixed(1)}</span>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            el.innerHTML = html;
        }
        
        function renderFreeAgentsTable() {
            const tableEl = document.getElementById('faTable');
            if (!tableEl) return;
            
            if (freeAgentsData.length === 0) {
                tableEl.innerHTML = '<p style="color: var(--text-muted);">No free agents found. Make sure league data is loaded.</p>';
                return;
            }
            
            // View mode from dropdown (default: cards)
            const viewMode = document.getElementById('faViewMode')?.value || 'cards';
            
            // Score color helper
            const scoreColor = (pts) => {
                if (pts >= 10) return 'var(--accent-emerald)';
                if (pts >= 6) return 'var(--accent-cyan)';
                if (pts >= 3) return 'var(--text-primary)';
                if (pts > 0) return 'var(--accent-amber)';
                return 'var(--accent-rose)';
            };
            
            const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
            const trendIcons = { HOT: '🔥', COLD: '❄️', STABLE: '➖' };
            
            if (viewMode === 'table') {
                // Compact table view
                const html = `
                    <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                        Found ${freeAgentsData.length} available free agents
                    </p>
                    <table class="standings-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Player</th>
                                <th>Team</th>
                                <th>Pos</th>
                                <th>Expected</th>
                                <th>80% Range</th>
                                <th>Recent</th>
                                <th>Form</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${freeAgentsData.map((p, i) => `
                                <tr>
                                    <td style="color: var(--text-muted);">${i + 1}</td>
                                    <td style="font-weight: 500;">
                                        <span class="player-link" onclick="showPlayerDetail(${p.player_id})">${p.name}</span>
                                        ${p.chance !== null && p.chance < 100 ? `<span style="color: var(--accent-amber); font-size: 0.7rem;"> (${p.chance}%)</span>` : ''}
                                    </td>
                                    <td>${p.team}</td>
                                    <td><span class="pos-badge pos-${p.position}">${p.position}</span></td>
                                    <td style="color: var(--accent-cyan); font-weight: 600;">${p.expected.toFixed(1)}</td>
                                    <td>${p.ci_80[0].toFixed(0)}-${p.ci_80[1].toFixed(0)}</td>
                                    <td>
                                        <div style="display: flex; gap: 2px;">
                                            ${(p.recent_scores || []).slice(-5).map(pts => `<span style="display: inline-block; width: 18px; height: 18px; line-height: 18px; text-align: center; font-size: 0.65rem; border-radius: 3px; background: ${scoreColor(pts)}20; color: ${scoreColor(pts)};">${pts}</span>`).join('')}
                                        </div>
                                    </td>
                                    <td>
                                        <span style="color: ${p.form_trend === 'HOT' ? 'var(--accent-emerald)' : p.form_trend === 'COLD' ? 'var(--accent-rose)' : 'var(--text-muted)'};">
                                            ${trendIcons[p.form_trend] || '➖'} ${(p.form_ewma || 0).toFixed(1)}
                                        </span>
                                    </td>
                                    <td>
                                        <button onclick="showPlayerDistribution(${p.player_id})" style="padding: 0.2rem 0.4rem; font-size: 0.7rem; margin-right: 0.25rem;">📊</button>
                                        <button onclick="quickCompare(${p.player_id})" style="padding: 0.2rem 0.4rem; font-size: 0.7rem;">⚖️</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                tableEl.innerHTML = html;
            } else {
                // Detailed cards view (like the modal)
                const html = `
                    <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
                        Found ${freeAgentsData.length} available free agents - showing top predictions
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1rem;">
                        ${freeAgentsData.slice(0, 20).map((p, i) => `
                            <div class="stat-card" style="padding: 1rem; border-left: 4px solid ${posColors[p.position]};">
                                <!-- Header -->
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.75rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="background: ${posColors[p.position]}; color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600;">${p.position}</span>
                                        <div>
                                            <div class="player-link" onclick="showPlayerDetail(${p.player_id})" style="font-weight: 700; color: var(--text-primary);">${p.name}</div>
                                            <div style="font-size: 0.8rem; color: var(--text-muted);">${p.team}</div>
                                        </div>
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-cyan);">${p.expected.toFixed(1)}</div>
                                        <div style="font-size: 0.7rem; color: var(--text-muted);">Expected</div>
                                    </div>
                                </div>
                                
                                <!-- Distribution Stats -->
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; background: var(--bg-tertiary); padding: 0.5rem; border-radius: 6px;">
                                    <div style="text-align: center;">
                                        <div style="font-size: 0.65rem; color: var(--text-muted);">80% Range</div>
                                        <div style="font-size: 0.9rem; font-weight: 600; color: var(--accent-emerald);">${p.ci_80[0].toFixed(0)}-${p.ci_80[1].toFixed(0)}</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-size: 0.65rem; color: var(--text-muted);">Floor</div>
                                        <div style="font-size: 0.9rem; font-weight: 600; color: var(--accent-rose);">${p.floor?.toFixed(0) || '?'}</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-size: 0.65rem; color: var(--text-muted);">Upside</div>
                                        <div style="font-size: 0.9rem; font-weight: 600; color: var(--accent-emerald);">${p.upside?.toFixed(0) || '?'}</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-size: 0.65rem; color: var(--text-muted);">Games</div>
                                        <div style="font-size: 0.9rem; font-weight: 600;">${p.games_played}</div>
                                    </div>
                                </div>
                                
                                <!-- Form -->
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="color: ${p.form_trend === 'HOT' ? 'var(--accent-emerald)' : p.form_trend === 'COLD' ? 'var(--accent-rose)' : 'var(--text-muted)'}; font-weight: 600;">
                                            ${trendIcons[p.form_trend] || '➖'} ${p.form_trend || 'STABLE'}
                                        </span>
                                        <span style="font-size: 0.85rem; color: var(--text-secondary);">Form: ${(p.form_ewma || 0).toFixed(1)}</span>
                                    </div>
                                    ${p.chance !== null && p.chance < 100 ? `<span style="color: var(--accent-amber); font-size: 0.75rem;">⚠️ ${p.chance}% fit</span>` : ''}
                                </div>
                                
                                <!-- Recent Scores -->
                                <div style="margin-bottom: 0.75rem;">
                                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.3rem;">Recent Scores</div>
                                    <div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
                                        ${(p.recent_scores || []).slice(-10).reverse().map(pts => `
                                            <span style="display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; background: ${scoreColor(pts)}20; color: ${scoreColor(pts)}; border: 1px solid ${scoreColor(pts)}50;">${pts}</span>
                                        `).join('')}
                                    </div>
                                </div>
                                
                                <!-- Actions -->
                                <div style="display: flex; gap: 0.5rem;">
                                    <button onclick="showPlayerDistribution(${p.player_id})" style="flex: 1; padding: 0.5rem; font-size: 0.8rem; background: var(--accent-violet); border: none; border-radius: 6px; cursor: pointer;">
                                        📊 Distribution
                                    </button>
                                    <button onclick="quickCompare(${p.player_id})" style="flex: 1; padding: 0.5rem; font-size: 0.8rem; background: var(--accent-cyan); border: none; border-radius: 6px; cursor: pointer;">
                                        ⚖️ Compare
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    ${freeAgentsData.length > 20 ? `<p style="color: var(--text-muted); text-align: center; margin-top: 1rem;">Showing top 20 of ${freeAgentsData.length} free agents. Use table view to see all.</p>` : ''}
                `;
                tableEl.innerHTML = html;
            }
        }
        
        function sortFreeAgents() {
            const sortBy = document.getElementById('faSortBy')?.value || 'expected';
            
            freeAgentsData.sort((a, b) => {
                switch (sortBy) {
                    case 'upside': return b.upside - a.upside;
                    case 'floor': return b.floor - a.floor;
                    case 'form': return b.form_ewma - a.form_ewma;
                    default: return b.expected - a.expected;
                }
            });
            
            renderFreeAgentsTable();
        }
        
        // ============================================
        // OWNERSHIP TRACKING SYSTEM
        // ============================================
        
        // Global ownership mapping: playerId -> { entryId, entryName, since }
        let playerOwnershipMap = {};
        
        // Rebuild ownership mapping from squads and transactions
        function rebuildOwnershipMap() {
            console.log('[Ownership] Starting ownership rebuild...');
            playerOwnershipMap = {};
            
            const squads = importedLeagueData?.squads || {};
            const entries = importedLeagueData?.league_entries || [];
            const transactions = importedLeagueData?.transactions?.transactions || [];
            
            // Step 1: Process squads to get current ownership
            console.log('[Ownership] Step 1: Processing squads...');
            let totalPlayers = 0;
            
            Object.entries(squads).forEach(([entryId, squad]) => {
                const entry = entries.find(e => String(e.entry_id) === String(entryId) || String(e.id) === String(entryId));
                const entryName = entry?.entry_name || entry?.name || `Team ${entryId}`;
                
                let picks = [];
                if (Array.isArray(squad?.picks)) {
                    picks = squad.picks;
                } else if (Array.isArray(squad)) {
                    picks = squad;
                } else if (squad?.squad && Array.isArray(squad.squad)) {
                    picks = squad.squad;
                }
                
                picks.forEach(pick => {
                    const playerId = pick.element || pick.player_id || pick.id;
                    if (playerId) {
                        playerOwnershipMap[playerId] = {
                            entryId: parseInt(entryId),
                            entryName: entryName,
                            since: 'initial'
                        };
                        totalPlayers++;
                    }
                });
                
                console.log(`[Ownership] Squad ${entryName}: ${picks.length} players`);
            });
            
            console.log(`[Ownership] Initial ownership: ${totalPlayers} players owned by ${Object.keys(squads).length} teams`);
            
            // Step 2: Process transactions in chronological order
            console.log('[Ownership] Step 2: Processing transactions...');
            const sortedTransactions = [...transactions].sort((a, b) => {
                const gwA = a.gameweek || a.event || 0;
                const gwB = b.gameweek || b.event || 0;
                if (gwA !== gwB) return gwA - gwB;
                return new Date(a.added || 0) - new Date(b.added || 0);
            });
            
            let transCount = 0;
            sortedTransactions.forEach(trans => {
                const entryId = trans.entry_id || trans.entry;
                const playerIn = trans.player_in || trans.element_in;
                const playerOut = trans.player_out || trans.element_out;
                const entry = entries.find(e => String(e.entry_id) === String(entryId) || String(e.id) === String(entryId));
                const entryName = entry?.entry_name || trans.entry_name || `Team ${entryId}`;
                const gw = trans.gameweek || trans.event || '?';
                
                if (playerOut) {
                    // Remove ownership
                    if (playerOwnershipMap[playerOut]) {
                        delete playerOwnershipMap[playerOut];
                        transCount++;
                    }
                }
                
                if (playerIn) {
                    // Add ownership
                    playerOwnershipMap[playerIn] = {
                        entryId: entryId,
                        entryName: entryName,
                        since: `GW${gw}`
                    };
                    transCount++;
                }
            });
            
            console.log(`[Ownership] Processed ${sortedTransactions.length} transactions (${transCount} ownership changes)`);
            console.log(`[Ownership] Final ownership: ${Object.keys(playerOwnershipMap).length} players owned`);
            console.log('[Ownership] Sample ownership:', Object.entries(playerOwnershipMap).slice(0, 5).map(([id, owner]) => ({
                playerId: id,
                owner: owner.entryName
            })));
            
            // Store timestamp
            window.lastOwnershipUpdate = Date.now();
            
            return playerOwnershipMap;
        }
        
        // Get all owned player IDs (uses ownership map)
        function getAllOwnedPlayerIds() {
            // Rebuild if not initialized or stale (>5 minutes)
            if (!window.lastOwnershipUpdate || Date.now() - window.lastOwnershipUpdate > 300000) {
                rebuildOwnershipMap();
            }
            
            return new Set(Object.keys(playerOwnershipMap).map(id => parseInt(id)));
        }
        
        // Get owner of a specific player
        function getPlayerOwner(playerId) {
            if (!window.lastOwnershipUpdate) {
                rebuildOwnershipMap();
            }
            return playerOwnershipMap[playerId] || null;
        }
        
        // Debug modal to show ownership mapping
        function showOwnershipDebug() {
            rebuildOwnershipMap(); // Refresh first
            
            const entries = importedLeagueData?.league_entries || [];
            const ownedIds = new Set(Object.keys(playerOwnershipMap).map(id => parseInt(id)));
            
            // Group players by owner
            const byOwner = {};
            entries.forEach(entry => {
                byOwner[entry.entry_id] = {
                    name: entry.entry_name,
                    players: []
                };
            });
            
            Object.entries(playerOwnershipMap).forEach(([playerId, owner]) => {
                const player = importedBootstrap?.elements?.find(p => p.id === parseInt(playerId));
                if (byOwner[owner.entryId]) {
                    byOwner[owner.entryId].players.push({
                        id: playerId,
                        name: player?.web_name || `Player ${playerId}`,
                        team: fplTeamIdMap[player?.team] || '?',
                        pos: fplPositionMap[player?.element_type] || '?'
                    });
                }
            });
            
            let html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 99999; overflow-y: auto; padding: 2rem;">
                    <div style="max-width: 1200px; margin: 0 auto; background: var(--bg-primary); padding: 2rem; border-radius: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                            <h2 style="color: var(--accent-cyan); margin: 0;">🔍 Ownership Debug</h2>
                            <button onclick="this.parentElement.parentElement.parentElement.remove()" style="font-size: 1.5rem; background: none; border: none; cursor: pointer; color: var(--text-muted);">×</button>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 2rem;">
                            <div class="stat-card">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Total Players</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: var(--accent-cyan);">${importedBootstrap?.elements?.length || 0}</div>
                            </div>
                            <div class="stat-card">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Owned Players</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: var(--accent-rose);">${ownedIds.size}</div>
                            </div>
                            <div class="stat-card">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Free Agents</div>
                                <div style="font-size: 1.8rem; font-weight: 600; color: var(--accent-emerald);">${(importedBootstrap?.elements?.length || 0) - ownedIds.size}</div>
                            </div>
                        </div>
                        
                        <h3 style="color: var(--accent-amber); margin-bottom: 1rem;">Squads Breakdown</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
            `;
            
            Object.entries(byOwner).forEach(([entryId, data]) => {
                const posCounts = { GK: 0, DEF: 0, MID: 0, FWD: 0 };
                data.players.forEach(p => posCounts[p.pos]++);
                
                html += `
                    <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; border-left: 3px solid var(--accent-cyan);">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">${data.name}</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.75rem;">
                            Total: ${data.players.length} players | 
                            🧤 ${posCounts.GK} | 
                            🛡️ ${posCounts.DEF} | 
                            ⚡ ${posCounts.MID} | 
                            ⚽ ${posCounts.FWD}
                        </div>
                        <details style="font-size: 0.8rem;">
                            <summary style="cursor: pointer; color: var(--accent-cyan);">Show Players</summary>
                            <div style="margin-top: 0.5rem; max-height: 200px; overflow-y: auto;">
                                ${data.players.map(p => `
                                    <div style="padding: 0.25rem 0; border-bottom: 1px solid var(--border-color);">
                                        <span style="color: var(--text-muted);">${p.pos}</span> ${p.name} 
                                        <span style="color: var(--text-muted);">(${p.team})</span>
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    </div>
                `;
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            const modal = document.createElement('div');
            modal.innerHTML = html;
            document.body.appendChild(modal);
        }
        
        // Check if a player is available (not injured, suspended, etc.)
        function isPlayerAvailable(player) {
            // Status: 'a' = available, 'u' = unavailable, 'i' = injured, 'd' = doubtful, 's' = suspended
            if (player.status === 'u' || player.status === 'i' || player.status === 's') {
                return false;
            }
            
            // Check chance of playing
            if (player.chance_of_playing !== null && player.chance_of_playing < 25) {
                return false;
            }
            
            // Player left PL entirely (0 minutes all season)
            if (player.minutes === 0 && player.total_points === 0) {
                return false;
            }
            
            // Check if player has played recently (at least 1 game in last 5 GWs)
            const details = importedPlayerDetails?.[player.id] || {};
            const history = details.history || [];
            if (history.length > 0) {
                const recentGames = history.slice(-5);
                const hasPlayedRecently = recentGames.some(g => g.minutes > 0);
                // If player has history but hasn't played recently, they likely left
                if (!hasPlayedRecently && history.length >= 5) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Calculate tighter, more reliable confidence intervals
        function calculateTightDistribution(scores) {
            if (scores.length < 3) {
                const avg = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 3;
                return {
                    expected: avg,
                    floor: Math.max(1, avg - 2),
                    upside: avg + 3,
                    ci_80: [Math.max(1, avg - 2), avg + 3],
                    probabilities: {},
                    std: 4 // Default high variance for low sample
                };
            }
            
            const sorted = [...scores].sort((a, b) => a - b);
            const n = sorted.length;
            
            // Use IQR-based robust statistics
            const q1Idx = Math.floor(n * 0.25);
            const q3Idx = Math.floor(n * 0.75);
            const q1 = sorted[q1Idx];
            const q3 = sorted[q3Idx];
            const iqr = q3 - q1;
            
            // Trimmed mean (exclude outliers)
            const trimLow = q1 - 1.5 * iqr;
            const trimHigh = q3 + 1.5 * iqr;
            const trimmed = sorted.filter(s => s >= trimLow && s <= trimHigh);
            const avg = trimmed.length > 0 
                ? trimmed.reduce((a, b) => a + b, 0) / trimmed.length 
                : sorted.reduce((a, b) => a + b, 0) / n;
            
            // Tighter 80% CI using actual percentiles
            const ci80Low = sorted[Math.floor(n * 0.10)] || sorted[0];
            const ci80High = sorted[Math.floor(n * 0.90)] || sorted[n - 1];
            
            // Even tighter floor/upside
            const floor = sorted[Math.floor(n * 0.15)] || sorted[0];
            const upside = sorted[Math.floor(n * 0.85)] || sorted[n - 1];
            
            // Build probability distribution
            const probabilities = {};
            const countMap = {};
            scores.forEach(s => {
                const rounded = Math.round(s);
                countMap[rounded] = (countMap[rounded] || 0) + 1;
            });
            Object.entries(countMap).forEach(([score, count]) => {
                probabilities[score] = count / scores.length;
            });
            
            // Calculate standard deviation
            const variance = trimmed.length > 1 
                ? trimmed.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / (trimmed.length - 1)
                : 0;
            const std = Math.sqrt(variance);
            
            return {
                expected: avg,
                floor: floor,
                upside: upside,
                ci_80: [ci80Low, ci80High],
                probabilities: probabilities,
                std: std
            };
        }
        
        // Local calculation fallback when API is not available
        function calculateLocalFreeAgents(gameweek, position) {
            if (!importedBootstrap?.elements) {
                document.getElementById('faTable').innerHTML = '<p style="color: var(--text-muted);">Load league data first to see free agents.</p>';
                return;
            }
            
            // Get owned player IDs
            const ownedIds = getAllOwnedPlayerIds();
            
            if (ownedIds.size === 0) {
                document.getElementById('faTable').innerHTML = '<p style="color: var(--accent-rose);">⚠️ No squad data found. Make sure to import league data with squads.</p>';
                return;
            }
            
            // Get all players and filter to free agents only
            let players = importedBootstrap.elements.filter(p => {
                // Must not be owned
                if (ownedIds.has(p.id)) return false;
                
                // Must be available (not injured/suspended)
                if (!isPlayerAvailable(p)) return false;
                
                return true;
            });
            
            console.log(`[Free Agents] Found ${players.length} available free agents out of ${importedBootstrap.elements.length} total players`);
            
            // Filter by position
            if (position) {
                const posMap = { 'GK': 1, 'DEF': 2, 'MID': 3, 'FWD': 4 };
                players = players.filter(p => p.element_type === posMap[position]);
            }
            
            // Calculate predictions with tighter distributions
            freeAgentsData = players.map(p => {
                const details = importedPlayerDetails?.[p.id] || {};
                const history = details.history || [];
                
                // Get scores from games where player actually played
                const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
                
                // Calculate distribution
                const dist = calculateTightDistribution(scores);
                
                // Calculate form trend based on recent vs older games
                let formTrend = 'STABLE';
                let formEwma = p.form || dist.expected;
                
                if (scores.length >= 5) {
                    const recent3 = scores.slice(-3);
                    const prev5 = scores.slice(-8, -3);
                    const recent3Avg = recent3.reduce((a, b) => a + b, 0) / recent3.length;
                    const prev5Avg = prev5.length > 0 ? prev5.reduce((a, b) => a + b, 0) / prev5.length : dist.expected;
                    
                    formEwma = recent3Avg;
                    
                    if (recent3Avg > prev5Avg * 1.2) formTrend = 'HOT';
                    else if (recent3Avg < prev5Avg * 0.8) formTrend = 'COLD';
                }
                
                return {
                    player_id: p.id,
                    name: p.web_name,
                    team: fplTeamIdMap[p.team] || 'Unknown',
                    position: fplPositionMap[p.element_type] || '?',
                    expected: dist.expected,
                    upside: dist.upside,
                    floor: dist.floor,
                    ci_80: dist.ci_80,
                    form_trend: formTrend,
                    form_ewma: formEwma,
                    games_played: scores.length,
                    recent_scores: scores.slice(-10), // Last 10 scores
                    probabilities: dist.probabilities,
                    status: p.status,
                    chance: p.chance_of_playing_next_round
                };
            });
            
            // Sort by expected points
            freeAgentsData.sort((a, b) => b.expected - a.expected);
            
            // Take top 50
            freeAgentsData = freeAgentsData.slice(0, 50);
            
            renderFreeAgentsTable();
        }
        
        // Calculate best free agents by position locally
        function calculateLocalBestByPosition(gameweek) {
            if (!importedBootstrap?.elements) return;
            
            const ownedIds = getAllOwnedPlayerIds();
            const posMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            // Get all free agents
            const freeAgents = importedBootstrap.elements.filter(p => {
                if (ownedIds.has(p.id)) return false;
                if (!isPlayerAvailable(p)) return false;
                return true;
            });
            
            // Group by position and calculate scores
            const byPosition = { GK: [], DEF: [], MID: [], FWD: [] };
            
            freeAgents.forEach(p => {
                const pos = posMap[p.element_type];
                if (!pos) return;
                
                const details = importedPlayerDetails?.[p.id] || {};
                const history = details.history || [];
                const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
                const dist = calculateTightDistribution(scores);
                
                byPosition[pos].push({
                    name: p.web_name,
                    team: fplTeamIdMap[p.team] || 'Unknown',
                    expected: dist.expected,
                    ci_80: dist.ci_80
                });
            });
            
            // Sort each position by expected and take top 3
            for (const pos of ['GK', 'DEF', 'MID', 'FWD']) {
                byPosition[pos].sort((a, b) => b.expected - a.expected);
                byPosition[pos] = byPosition[pos].slice(0, 3);
            }
            
            freeAgentsByPosition = byPosition;
            updateBestByPositionCards();
        }
        
        // Calculate high-upside differentials locally
        function calculateLocalDifferentials(gameweek) {
            if (!importedBootstrap?.elements) return;
            
            const ownedIds = getAllOwnedPlayerIds();
            
            // Get all free agents
            const freeAgents = importedBootstrap.elements.filter(p => {
                if (ownedIds.has(p.id)) return false;
                if (!isPlayerAvailable(p)) return false;
                return true;
            });
            
            // Calculate scores with upside emphasis
            const withScores = freeAgents.map(p => {
                const details = importedPlayerDetails?.[p.id] || {};
                const history = details.history || [];
                const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
                const dist = calculateTightDistribution(scores);
                
                // Calculate form
                let formTrend = 'stable';
                let formEwma = p.form || dist.expected;
                
                if (scores.length >= 5) {
                    const recent3 = scores.slice(-3);
                    const prev5 = scores.slice(-8, -3);
                    const recent3Avg = recent3.reduce((a, b) => a + b, 0) / recent3.length;
                    const prev5Avg = prev5.length > 0 ? prev5.reduce((a, b) => a + b, 0) / prev5.length : dist.expected;
                    
                    formEwma = recent3Avg;
                    
                    if (recent3Avg > prev5Avg * 1.2) formTrend = 'hot';
                    else if (recent3Avg < prev5Avg * 0.8) formTrend = 'cold';
                }
                
                return {
                    name: p.web_name,
                    team: fplTeamIdMap[p.team] || 'Unknown',
                    position: fplPositionMap[p.element_type] || '?',
                    expected: dist.expected,
                    upside: dist.upside,
                    floor: dist.floor,
                    form_trend: formTrend,
                    form_ewma: formEwma
                };
            });
            
            // Sort by upside (90th percentile) and take top 5
            withScores.sort((a, b) => b.upside - a.upside);
            const differentials = withScores.slice(0, 5);
            
            renderDifferentials(differentials);
        }
        
        // ============================================
        // SCORE DISTRIBUTION MODAL
        // ============================================
        
        async function showPlayerDistribution(playerId) {
            const modal = document.getElementById('playerDistModal');
            if (!modal) return;
            
            modal.style.display = 'flex';
            
            // Find player info
            const player = importedBootstrap?.elements?.find(e => e.id === playerId);
            const playerName = player?.web_name || `Player ${playerId}`;
            const teamName = fplTeamIdMap[player?.team] || '';
            
            document.getElementById('distModalTitle').textContent = `${playerName} - ${teamName}`;
            
            try {
                const gameweek = document.getElementById('faGameweek')?.value || (getCurrentGameweek() + 1);
                const response = await fetch(`/api/player-distribution/${playerId}?gameweek=${gameweek}`);
                
                if (response.ok) {
                    const data = await response.json();
                    renderDistributionModal(data);
                } else {
                    renderLocalDistribution(playerId);
                }
            } catch (e) {
                console.warn('API not available, using local calculation:', e);
                renderLocalDistribution(playerId);
            }
        }
        
        function renderDistributionModal(data) {
            const dist = data.distribution || {};
            const form = data.form || {};
            
            document.getElementById('distExpected').textContent = dist.expected?.toFixed(1) || '-';
            document.getElementById('distCI80').textContent = dist.ci_80 ? `${dist.ci_80[0]}-${dist.ci_80[1]}` : '-';
            document.getElementById('distFloor').textContent = dist.ci_80?.[0]?.toFixed(0) || '-';
            document.getElementById('distMedian').textContent = dist.median?.toFixed(0) || '-';
            document.getElementById('distUpside').textContent = dist.ci_80?.[1]?.toFixed(0) || '-';
            document.getElementById('distGames').textContent = dist.sample_size || '-';
            
            // Render probability chart using Chart.js
            const probs = dist.probabilities || {};
            if (Object.keys(probs).length > 0) {
                // Convert string keys to numbers
                const numericProbs = {};
                Object.entries(probs).forEach(([k, v]) => {
                    numericProbs[parseInt(k)] = v;
                });
                renderDistributionChart(numericProbs);
            }
            
            // Render recent scores placeholder
            const recentScoresEl = document.getElementById('distRecentScores');
            recentScoresEl.innerHTML = form.recent_scores ? 
                form.recent_scores.map(s => `<span style="display: inline-block; padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">${s}</span>`).join('') :
                '<span style="color: var(--text-muted);">-</span>';
            
            // Render form analysis
            const formEl = document.getElementById('distForm');
            const consistency = form.consistency ? (form.consistency > 0.7 ? 'High' : form.consistency > 0.4 ? 'Medium' : 'Low') : '-';
            formEl.innerHTML = `
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Form (EWMA)</div>
                    <div style="font-size: 1rem; font-weight: 600;">${form.ewma?.toFixed(1) || '-'}</div>
                </div>
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Season Avg</div>
                    <div style="font-size: 1rem; font-weight: 600;">${form.season_avg?.toFixed(1) || '-'}</div>
                </div>
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Trend</div>
                    <div style="font-size: 1rem; font-weight: 600;">
                        <span class="form-badge form-${form.trend || 'stable'}">${form.trend || 'stable'}</span>
                    </div>
                </div>
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Consistency</div>
                    <div style="font-size: 1rem; font-weight: 600; color: ${consistency === 'High' ? 'var(--accent-emerald)' : consistency === 'Low' ? 'var(--accent-rose)' : 'var(--text-secondary)'};">${consistency}</div>
                </div>
            `;
        }
        
        let distChart = null;
        
        function renderLocalDistribution(playerId) {
            const player = importedBootstrap?.elements?.find(e => e.id === playerId);
            const details = importedPlayerDetails?.[playerId] || {};
            const history = details.history || [];
            
            const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
            
            if (scores.length === 0) {
                document.getElementById('distExpected').textContent = (player?.form || 3).toFixed(1);
                document.getElementById('distGames').textContent = '0';
                document.getElementById('distRecentScores').innerHTML = '<span style="color: var(--text-muted);">No game data</span>';
                return;
            }
            
            // Use tighter distribution calculation
            const dist = calculateTightDistribution(scores);
            const sorted = [...scores].sort((a, b) => a - b);
            const n = scores.length;
            
            document.getElementById('distExpected').textContent = dist.expected.toFixed(1);
            document.getElementById('distCI80').textContent = `${dist.ci_80[0].toFixed(0)}-${dist.ci_80[1].toFixed(0)}`;
            document.getElementById('distFloor').textContent = dist.floor.toFixed(0);
            document.getElementById('distMedian').textContent = sorted[Math.floor(n * 0.5)]?.toFixed(0) || '-';
            document.getElementById('distUpside').textContent = dist.upside.toFixed(0);
            document.getElementById('distGames').textContent = n;
            
            // Render recent scores
            const recentScoresEl = document.getElementById('distRecentScores');
            const recentScores = scores.slice(-10);
            recentScoresEl.innerHTML = recentScores.map((s, i) => {
                const isRecent = i >= recentScores.length - 3;
                const color = s >= dist.upside ? 'var(--accent-emerald)' : s <= dist.floor ? 'var(--accent-rose)' : 'var(--text-secondary)';
                return `<span style="display: inline-block; padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border-radius: 4px; color: ${color}; font-weight: ${isRecent ? '600' : '400'}; ${isRecent ? 'border: 1px solid var(--accent-cyan);' : ''}">${s}</span>`;
            }).join('');
            
            // Build probability chart with Chart.js
            renderDistributionChart(dist.probabilities);
            
            // Form analysis
            let formTrend = 'stable';
            let recentAvg = dist.expected;
            let seasonAvg = dist.expected;
            
            if (scores.length >= 5) {
                const recent3 = scores.slice(-3);
                const prev5 = scores.slice(-8, -3);
                recentAvg = recent3.reduce((a, b) => a + b, 0) / recent3.length;
                const prev5Avg = prev5.length > 0 ? prev5.reduce((a, b) => a + b, 0) / prev5.length : dist.expected;
                seasonAvg = scores.reduce((a, b) => a + b, 0) / scores.length;
                
                if (recentAvg > prev5Avg * 1.2) formTrend = 'hot';
                else if (recentAvg < prev5Avg * 0.8) formTrend = 'cold';
            }
            
            // Calculate consistency (std dev)
            const variance = scores.reduce((sum, s) => sum + Math.pow(s - dist.expected, 2), 0) / n;
            const stdDev = Math.sqrt(variance);
            const consistency = stdDev < 2 ? 'High' : stdDev < 4 ? 'Medium' : 'Low';
            
            const formEl = document.getElementById('distForm');
            formEl.innerHTML = `
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Recent (3 games)</div>
                    <div style="font-size: 1rem; font-weight: 600;">${recentAvg.toFixed(1)}</div>
                </div>
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Season Avg</div>
                    <div style="font-size: 1rem; font-weight: 600;">${seasonAvg.toFixed(1)}</div>
                </div>
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Trend</div>
                    <div style="font-size: 1rem; font-weight: 600;">
                        <span class="form-badge form-${formTrend}">${formTrend}</span>
                    </div>
                </div>
                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">Consistency</div>
                    <div style="font-size: 1rem; font-weight: 600; color: ${consistency === 'High' ? 'var(--accent-emerald)' : consistency === 'Low' ? 'var(--accent-rose)' : 'var(--text-secondary)'};">${consistency}</div>
                </div>
            `;
        }
        
        function renderDistributionChart(probabilities) {
            const canvas = document.getElementById('distChartCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (distChart) {
                distChart.destroy();
            }
            
            // Prepare data
            const labels = [];
            const data = [];
            const backgroundColors = [];
            
            // Get all scores from 0 to max
            const allScores = Object.keys(probabilities).map(Number);
            const minScore = Math.max(0, Math.min(...allScores) - 1);
            const maxScore = Math.max(...allScores) + 1;
            
            for (let score = minScore; score <= maxScore; score++) {
                labels.push(score.toString());
                const prob = probabilities[score] || 0;
                data.push((prob * 100).toFixed(1));
                
                // Color gradient based on score
                if (prob > 0.15) {
                    backgroundColors.push('rgba(34, 211, 238, 0.9)'); // Cyan for high prob
                } else if (prob > 0.05) {
                    backgroundColors.push('rgba(34, 211, 238, 0.6)');
                } else {
                    backgroundColors.push('rgba(34, 211, 238, 0.3)');
                }
            }
            
            distChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Probability %',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(34, 211, 238, 1)',
                        borderWidth: 1,
                        borderRadius: 4,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.raw}% chance`
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Points',
                                color: '#94a3b8'
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: '#94a3b8'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Probability %',
                                color: '#94a3b8'
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            },
                            ticks: {
                                color: '#94a3b8'
                            }
                        }
                    }
                }
            });
        }
        
        function closeDistModal() {
            const modal = document.getElementById('playerDistModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Close modal on outside click
        window.addEventListener('click', (e) => {
            const modal = document.getElementById('playerDistModal');
            if (e.target === modal) {
                modal.style.display = 'none';
            }
            const compareModal = document.getElementById('playerCompareModal');
            if (e.target === compareModal) {
                compareModal.style.display = 'none';
            }
            
            // Close compare dropdowns when clicking outside
            if (!e.target.closest('.compare-search-container')) {
                document.querySelectorAll('.compare-dropdown').forEach(d => d.style.display = 'none');
            }
        });
        
        // ============================================
        // PLAYER COMPARISON DASHBOARD
        // ============================================
        
        // Store comparison state
        const compareState = {
            players: [null, null, null, null], // Up to 4 players
            gameweek: null,
            chartInstances: {},
            playerColors: ['var(--accent-cyan)', 'var(--accent-rose)', 'var(--accent-emerald)', 'var(--accent-amber)']
        };
        
        // Open comparison modal
        function openCompareModal(initialPlayerId = null) {
            const modal = document.getElementById('playerCompareModal');
            modal.style.display = 'flex';
            
            // Populate GW selector
            const gwSelect = document.getElementById('compareGW');
            if (gwSelect.options.length === 0) {
                const currentGW = getCurrentGameweek();
                for (let gw = currentGW; gw <= 38; gw++) {
                    const option = document.createElement('option');
                    option.value = gw;
                    option.textContent = `GW${gw}`;
                    if (gw === currentGW) option.selected = true;
                    gwSelect.appendChild(option);
                }
            }
            compareState.gameweek = parseInt(gwSelect.value);
            
            // If initial player provided, add to slot 1
            if (initialPlayerId) {
                selectPlayerForCompare(1, initialPlayerId);
            }
            
            updateCompareUI();
        }
        
        // Close comparison modal
        function closeCompareModal() {
            document.getElementById('playerCompareModal').style.display = 'none';
            // Clear chart instances
            Object.values(compareState.chartInstances).forEach(chart => chart.destroy());
            compareState.chartInstances = {};
        }
        
        // Filter player search dropdown
        function filterCompareSearch(slot) {
            const input = document.getElementById(`compareSearch${slot}`);
            const dropdown = document.getElementById(`compareDropdown${slot}`);
            const query = input.value.toLowerCase().trim();
            
            if (query.length < 2) {
                dropdown.style.display = 'none';
                return;
            }
            
            const players = importedBootstrap?.elements || [];
            const matches = players
                .filter(p => 
                    p.web_name?.toLowerCase().includes(query) ||
                    (p.first_name + ' ' + p.second_name)?.toLowerCase().includes(query)
                )
                .slice(0, 15);
            
            if (matches.length === 0) {
                dropdown.innerHTML = '<div class="compare-dropdown-item" style="color: var(--text-muted);">No players found</div>';
            } else {
                const posColors = { 1: '#f59e0b', 2: '#10b981', 3: '#22d3ee', 4: '#f43f5e' };
                const posNames = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
                
                dropdown.innerHTML = matches.map(p => `
                    <div class="compare-dropdown-item" onclick="selectPlayerForCompare(${slot}, ${p.id})">
                        <span class="compare-pos-badge" style="background: ${posColors[p.element_type] || posColors[3]}; color: #000;">
                            ${posNames[p.element_type] || 'MID'}
                        </span>
                        <span style="font-weight: 600;">${p.web_name}</span>
                        <span style="color: var(--text-muted); font-size: 0.8rem;">${fplTeamIdMap[p.team] || '?'}</span>
                    </div>
                `).join('');
            }
            
            dropdown.style.display = 'block';
        }
        
        // Show dropdown on focus
        function showCompareDropdown(slot) {
            const input = document.getElementById(`compareSearch${slot}`);
            if (input.value.length >= 2) {
                filterCompareSearch(slot);
            }
        }
        
        // Select a player for comparison
        async function selectPlayerForCompare(slot, playerId) {
            const idx = slot - 1;
            
            // Hide dropdown
            document.getElementById(`compareDropdown${slot}`).style.display = 'none';
            document.getElementById(`compareSearch${slot}`).value = '';
            
            // Show loading state
            const playerCard = document.getElementById(`comparePlayer${slot}`);
            const searchContainer = document.querySelector(`#compareSlot${slot} .compare-search-container`);
            searchContainer.style.display = 'none';
            playerCard.style.display = 'block';
            playerCard.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-muted);">Loading...</div>';
            
            // Load player data
            const playerData = await loadPlayerCompareData(playerId);
            if (!playerData) {
                playerCard.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--accent-rose);">Failed to load</div>';
                setTimeout(() => {
                    searchContainer.style.display = 'block';
                    playerCard.style.display = 'none';
                }, 1500);
                return;
            }
            
            compareState.players[idx] = playerData;
            updateCompareUI();
        }
        
        // Load all data needed for comparison
        async function loadPlayerCompareData(playerId) {
            const bootstrap = importedBootstrap?.elements?.find(e => e.id === playerId);
            if (!bootstrap) return null;
            
            // Ensure batch analysis is initialized for predictions
            if (!batchAnalysisCache.lastComputed && importedPlayerDetails && importedBootstrap) {
                console.log('[Compare] Initializing batch analysis...');
                await initBatchAnalysis();
            }
            
            // Get player details (history)
            let history = [];
            const details = importedPlayerDetails?.[playerId];
            if (details?.history) {
                history = details.history;
            }
            
            // Calculate distribution
            const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
            const dist = calculateTightDistribution(scores);
            
            // Calculate form
            const recentGames = history.slice(-5);
            const recentAvg = recentGames.length > 0 
                ? recentGames.reduce((s, g) => s + g.total_points, 0) / recentGames.length 
                : 0;
            const seasonAvg = history.length > 0 
                ? history.reduce((s, g) => s + g.total_points, 0) / history.length 
                : 0;
            
            // Determine trend
            let trend = 'STABLE';
            if (recentGames.length >= 3) {
                const diff = recentAvg - seasonAvg;
                if (diff > 1.5) trend = 'HOT';
                else if (diff < -1.5) trend = 'COLD';
            }
            
            // Get GW prediction
            const gw = compareState.gameweek || getCurrentGameweek();
            const fixtures = importedBootstrap?.fixtures?.[String(gw)] || [];
            const teamFixtureMap = {};
            fixtures.forEach(f => {
                teamFixtureMap[f.team_h] = { opponent: f.team_a, isHome: true };
                teamFixtureMap[f.team_a] = { opponent: f.team_h, isHome: false };
            });
            
            let prediction = null;
            const fixture = teamFixtureMap[bootstrap.team];
            if (fixture && batchAnalysisCache.playerStats?.[playerId]) {
                prediction = predictPlayerPointsBatch(playerId, fixture.opponent, fixture.isHome, gw);
            }
            
            return {
                id: playerId,
                name: bootstrap.web_name,
                fullName: `${bootstrap.first_name || ''} ${bootstrap.second_name || ''}`.trim(),
                position: fplPositionMap[bootstrap.element_type] || 'MID',
                positionId: bootstrap.element_type,
                team: fplTeamIdMap[bootstrap.team] || '?',
                teamId: bootstrap.team,
                totalPoints: bootstrap.total_points || 0,
                goals: bootstrap.goals_scored || 0,
                assists: bootstrap.assists || 0,
                cleanSheets: bootstrap.clean_sheets || 0,
                bonus: bootstrap.bonus || 0,
                bps: bootstrap.bps || 0,
                minutes: bootstrap.minutes || 0,
                yellowCards: bootstrap.yellow_cards || 0,
                redCards: bootstrap.red_cards || 0,
                saves: bootstrap.saves || 0,
                form: parseFloat(bootstrap.form) || 0,
                history: history,
                distribution: dist,
                recentAvg: recentAvg,
                seasonAvg: seasonAvg,
                trend: trend,
                prediction: prediction,
                gamesPlayed: history.filter(h => h.minutes > 0).length
            };
        }
        
        // Add another player slot
        function addPlayerToCompare() {
            // For now, we support 2 players max
            // Could extend to 4 by adding more slots
            alert('Currently supports comparing 2 players. Clear a slot to add a different player.');
        }
        
        // Remove player from comparison
        function removePlayerFromCompare(slot) {
            const idx = slot - 1;
            compareState.players[idx] = null;
            
            // Destroy chart if exists
            if (compareState.chartInstances[`chart${slot}`]) {
                compareState.chartInstances[`chart${slot}`].destroy();
                delete compareState.chartInstances[`chart${slot}`];
            }
            
            updateCompareUI();
        }
        
        // Refresh comparison when GW changes
        async function refreshComparison() {
            const gwSelect = document.getElementById('compareGW');
            compareState.gameweek = parseInt(gwSelect.value);
            
            // Reload predictions for each player
            for (let i = 0; i < compareState.players.length; i++) {
                if (compareState.players[i]) {
                    const newData = await loadPlayerCompareData(compareState.players[i].id);
                    if (newData) {
                        compareState.players[i] = newData;
                    }
                }
            }
            
            updateCompareUI();
        }
        
        // Update the comparison UI
        function updateCompareUI() {
            const hasPlayers = compareState.players.some(p => p !== null);
            
            document.getElementById('compareContent').style.display = hasPlayers ? 'block' : 'none';
            document.getElementById('compareEmptyState').style.display = hasPlayers ? 'none' : 'block';
            
            // Update search sections visibility
            compareState.players.forEach((player, idx) => {
                const slot = idx + 1;
                const searchContainer = document.querySelector(`#compareSlot${slot} .compare-search-container`);
                const playerCard = document.getElementById(`comparePlayer${slot}`);
                
                if (player) {
                    searchContainer.style.display = 'none';
                    playerCard.style.display = 'block';
                    renderComparePlayerCard(slot, player);
                } else {
                    searchContainer.style.display = 'block';
                    playerCard.style.display = 'none';
                }
            });
            
            // Render main comparison grid
            if (hasPlayers) {
                renderCompareGrid();
                renderCompareHistory();
            }
        }
        
        // Render small player card in search section
        function renderComparePlayerCard(slot, player) {
            const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
            const slotColor = compareState.playerColors[slot - 1];
            const card = document.getElementById(`comparePlayer${slot}`);
            
            card.innerHTML = `
                <button class="compare-remove-btn" onclick="removePlayerFromCompare(${slot})">×</button>
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <span class="compare-pos-badge" style="background: ${posColors[player.position]}; color: #000;">
                        ${player.position}
                    </span>
                    <div>
                        <div style="font-weight: 600; color: ${slotColor};">${player.name}</div>
                        <div style="font-size: 0.8rem; color: var(--text-muted);">${player.team} · ${player.totalPoints} pts</div>
                    </div>
                </div>
            `;
            card.classList.add('selected');
            card.style.borderColor = slotColor;
        }
        
        // Render main comparison grid - HORIZONTAL TABLE LAYOUT
        function renderCompareGrid() {
            const grid = document.getElementById('compareGrid');
            const players = compareState.players.filter(p => p !== null);
            const gw = compareState.gameweek;
            const colors = compareState.playerColors;
            
            if (players.length === 0) {
                grid.innerHTML = '';
                return;
            }
            
            // Find best values for highlighting (higher = better for most stats)
            const getBest = (stat) => {
                const vals = players.map(p => p[stat] || 0);
                return { max: Math.max(...vals), min: Math.min(...vals) };
            };
            
            // Helper to highlight best value
            const highlightBest = (val, stat, higherIsBetter = true) => {
                const best = getBest(stat);
                if (players.length <= 1) return '';
                if (higherIsBetter && val >= best.max && best.max > 0) return 'background: rgba(16, 185, 129, 0.25); color: var(--accent-emerald); font-weight: 700;';
                if (!higherIsBetter && val <= best.min && best.min >= 0) return 'background: rgba(16, 185, 129, 0.25); color: var(--accent-emerald); font-weight: 700;';
                return '';
            };
            
            const scoreColor = (pts) => {
                if (pts >= 10) return 'var(--accent-emerald)';
                if (pts >= 6) return 'var(--accent-cyan)';
                if (pts >= 3) return 'var(--text-primary)';
                if (pts > 0) return 'var(--accent-amber)';
                return 'var(--accent-rose)';
            };
            
            const trendIcons = { HOT: '🔥', COLD: '❄️', STABLE: '➖' };
            const posColors = { GK: '#f59e0b', DEF: '#10b981', MID: '#22d3ee', FWD: '#f43f5e' };
            
            // Create column headers (player names)
            const headerCols = players.map((p, i) => `
                <th style="text-align: center; padding: 0.75rem; background: ${colors[i]}20; border-bottom: 3px solid ${colors[i]};">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span style="background: ${posColors[p.position]}; color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem;">${p.position}</span>
                        <div>
                            <div style="font-weight: 700; color: ${colors[i]};">${p.name}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">${p.team}</div>
                        </div>
                    </div>
                </th>
            `).join('');
            
            // Build stat rows
            const statRows = [];
            
            // --- GW Prediction Section ---
            statRows.push(`<tr class="section-header"><td colspan="${players.length + 1}" style="background: var(--accent-cyan); color: #000; font-weight: 700; padding: 0.5rem;">📊 GW${gw} Prediction</td></tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Expected Points</td>
                ${players.map((p, i) => {
                    const pred = p.prediction;
                    return `<td style="text-align: center; ${highlightBest(pred?.predicted || 0, 'predPts')}">
                        <span style="font-size: 1.5rem; font-weight: 700; color: ${colors[i]};">${pred?.predicted?.toFixed(1) || '-'}</span>
                    </td>`;
                }).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Opponent</td>
                ${players.map(p => {
                    const pred = p.prediction;
                    return `<td style="text-align: center;">
                        ${pred ? `<span style="color: ${pred.isHome ? 'var(--accent-emerald)' : 'var(--accent-amber)'};">
                            ${pred.isHome ? '🏠' : '✈️'} ${pred.opponent}
                        </span>` : '<span style="color: var(--text-muted);">No fixture</span>'}
                    </td>`;
                }).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">⚽ Goals Exp</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.prediction?.breakdown?.goals || 0, 'goalsPred')}">${p.prediction?.breakdown?.goals?.toFixed(2) || '-'}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">🅰️ Assists Exp</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.prediction?.breakdown?.assists || 0, 'assistsPred')}">${p.prediction?.breakdown?.assists?.toFixed(2) || '-'}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">🛡️ CS Exp</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.prediction?.breakdown?.cs || 0, 'csPred')}">${p.prediction?.breakdown?.cs?.toFixed(2) || '-'}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">⭐ Bonus Exp</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.prediction?.breakdown?.bonus || 0, 'bonusPred')}">${p.prediction?.breakdown?.bonus?.toFixed(2) || '-'}</td>`).join('')}
            </tr>`);
            
            // --- Distribution Section ---
            statRows.push(`<tr class="section-header"><td colspan="${players.length + 1}" style="background: var(--accent-violet); color: white; font-weight: 700; padding: 0.5rem;">📈 Score Distribution</td></tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">80% Range</td>
                ${players.map((p, i) => `<td style="text-align: center;"><span style="color: ${colors[i]}; font-weight: 600;">${p.distribution?.ci_80?.[0] || '?'} - ${p.distribution?.ci_80?.[1] || '?'}</span></td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Floor (15%)</td>
                ${players.map(p => `<td style="text-align: center; color: var(--accent-rose);">${p.distribution?.floor?.toFixed(0) || '-'}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Upside (85%)</td>
                ${players.map(p => `<td style="text-align: center; color: var(--accent-emerald);">${p.distribution?.upside?.toFixed(0) || '-'}</td>`).join('')}
            </tr>`);
            
            // --- Form Section ---
            statRows.push(`<tr class="section-header"><td colspan="${players.length + 1}" style="background: var(--accent-emerald); color: #000; font-weight: 700; padding: 0.5rem;">🔥 Form Analysis</td></tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Recent Avg (5)</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.recentAvg, 'recentAvg')}"><span style="font-size: 1.2rem; font-weight: 600;">${p.recentAvg.toFixed(1)}</span></td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Season Avg</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.seasonAvg, 'seasonAvg')}">${p.seasonAvg.toFixed(1)}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Trend</td>
                ${players.map(p => `<td style="text-align: center;"><span style="color: ${p.trend === 'HOT' ? 'var(--accent-emerald)' : p.trend === 'COLD' ? 'var(--accent-rose)' : 'var(--text-muted)'};">${trendIcons[p.trend]} ${p.trend}</span></td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Recent Scores</td>
                ${players.map(p => `<td style="text-align: center;">
                    <div style="display: flex; gap: 0.2rem; flex-wrap: wrap; justify-content: center;">
                        ${p.history.slice(-8).reverse().map(h => `<span style="display: inline-block; width: 22px; height: 22px; line-height: 22px; text-align: center; border-radius: 4px; font-size: 0.7rem; background: ${scoreColor(h.total_points)}20; color: ${scoreColor(h.total_points)}; border: 1px solid ${scoreColor(h.total_points)}40;">${h.total_points}</span>`).join('')}
                    </div>
                </td>`).join('')}
            </tr>`);
            
            // --- Season Stats Section ---
            statRows.push(`<tr class="section-header"><td colspan="${players.length + 1}" style="background: var(--accent-amber); color: #000; font-weight: 700; padding: 0.5rem;">📋 Season Stats</td></tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Total Points</td>
                ${players.map((p, i) => `<td style="text-align: center; ${highlightBest(p.totalPoints, 'totalPoints')}"><span style="font-size: 1.3rem; font-weight: 700; color: ${colors[i]};">${p.totalPoints}</span></td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">⚽ Goals</td>
                ${players.map(p => `<td style="text-align: center; ${highlightBest(p.goals, 'goals')}">${p.goals}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">🅰️ Assists</td>
                ${players.map(p => `<td style="text-align: center; ${highlightBest(p.assists, 'assists')}">${p.assists}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">🛡️ Clean Sheets</td>
                ${players.map(p => `<td style="text-align: center; ${highlightBest(p.cleanSheets, 'cleanSheets')}">${p.cleanSheets}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">⭐ Bonus</td>
                ${players.map(p => `<td style="text-align: center; ${highlightBest(p.bonus, 'bonus')}">${p.bonus}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">⏱️ Minutes</td>
                ${players.map(p => `<td style="text-align: center;">${p.minutes}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">Games Played</td>
                ${players.map(p => `<td style="text-align: center;">${p.gamesPlayed}</td>`).join('')}
            </tr>`);
            
            statRows.push(`<tr>
                <td style="font-weight: 500;">🟨/🟥 Cards</td>
                ${players.map(p => `<td style="text-align: center;">${p.yellowCards} / ${p.redCards}</td>`).join('')}
            </tr>`);
            
            grid.innerHTML = `
                <table class="standings-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th style="text-align: left; padding: 0.75rem; min-width: 140px;">Stat</th>
                            ${headerCols}
                        </tr>
                    </thead>
                    <tbody>
                        ${statRows.join('')}
                    </tbody>
                </table>
            `;
        }
        
        // Render side-by-side history table
        function renderCompareHistory() {
            const table = document.getElementById('compareHistoryTable');
            const players = compareState.players.filter(p => p !== null);
            
            if (players.length === 0) {
                table.innerHTML = '';
                return;
            }
            
            // Get all unique GWs from all players
            const allGWs = new Set();
            players.forEach(p => {
                p.history.forEach(h => allGWs.add(h.round || h.event || h.gameweek));
            });
            const sortedGWs = [...allGWs].sort((a, b) => b - a).slice(0, 10); // Last 10 GWs
            
            const scoreColor = (pts) => {
                if (pts >= 10) return 'var(--accent-emerald)';
                if (pts >= 6) return 'var(--accent-cyan)';
                if (pts >= 3) return 'var(--text-primary)';
                if (pts > 0) return 'var(--accent-amber)';
                return 'var(--accent-rose)';
            };
            
            let html = '<table class="compare-history-table"><thead><tr><th>GW</th>';
            players.forEach(p => {
                html += `<th class="player-col">${p.name} (${p.team})</th>`;
            });
            html += '</tr></thead><tbody>';
            
            sortedGWs.forEach(gw => {
                html += `<tr><td style="font-weight: 600;">GW${gw}</td>`;
                players.forEach(p => {
                    const game = p.history.find(h => (h.round || h.event || h.gameweek) === gw);
                    if (game) {
                        const isHome = game.was_home;
                        const opp = fplTeamIdMap[game.opponent_team] || '?';
                        html += `<td>
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span style="color: var(--text-muted); font-size: 0.75rem;">${isHome ? '' : '@'}${opp}</span>
                                <span style="color: ${scoreColor(game.total_points)}; font-weight: 600;">${game.total_points}</span>
                                <span style="color: var(--text-muted); font-size: 0.7rem;">${game.minutes}'</span>
                            </div>
                        </td>`;
                    } else {
                        html += '<td style="color: var(--text-muted);">-</td>';
                    }
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            table.innerHTML = html;
        }
        
        // Quick compare - add player to existing comparison or open new
        function quickCompare(playerId) {
            const modal = document.getElementById('playerCompareModal');
            
            if (modal.style.display === 'flex') {
                // Modal already open - add to first empty slot or replace last slot
                const emptySlot = compareState.players.findIndex(p => p === null);
                if (emptySlot !== -1) {
                    selectPlayerForCompare(emptySlot + 1, playerId);
                } else {
                    // All 4 slots filled - replace slot 4
                    removePlayerFromCompare(4);
                    selectPlayerForCompare(4, playerId);
                }
            } else {
                // Open modal with this player in slot 1
                openCompareModal(playerId);
            }
        }
        
        // Open compare with two specific players
        function compareTwo(playerId1, playerId2) {
            openCompareModal(playerId1);
            setTimeout(() => {
                selectPlayerForCompare(2, playerId2);
            }, 100);
        }
        
        // ============================================
        // MONTE CARLO LINEUP SIMULATOR
        // ============================================
        
        async function runLineupSimulation(entryId, gameweek, numSims = 1000) {
            try {
                const response = await fetch('/api/simulate-lineup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        entry_id: entryId,
                        gameweek: gameweek,
                        simulations: numSims
                    })
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.warn('Lineup simulation API error:', e);
            }
            
            return null;
        }
        
        // Populate MC team selector
        function populateMCTeamSelect() {
            const select = document.getElementById('mcTeamSelect');
            if (!select || !importedLeagueData?.league_entries) return;
            
            select.innerHTML = '<option value="">Select a team...</option>';
            importedLeagueData.league_entries.forEach(entry => {
                const opt = document.createElement('option');
                opt.value = entry.entry_id;
                opt.textContent = entry.entry_name || `Team ${entry.entry_id}`;
                select.appendChild(opt);
            });
        }
        
        // Run Monte Carlo simulation
        async function runMCSimulation(forceSimCount = null) {
            const teamSelect = document.getElementById('mcTeamSelect');
            const simCount = document.getElementById('mcSimCount');
            const loading = document.getElementById('mcLoading');
            const results = document.getElementById('mcResults');
            
            if (!teamSelect?.value) {
                results.innerHTML = '<p style="color: var(--accent-rose);">Please select a team.</p>';
                return;
            }
            
            const entryId = parseInt(teamSelect.value);
            const numSims = forceSimCount || parseInt(simCount?.value || '1000');
            const gameweek = parseInt(document.getElementById('predictionGW')?.value || getCurrentGameweek() + 1);
            
            loading.style.display = 'block';
            loading.textContent = numSims === 1 ? 'Simulating single game...' : `Running ${numSims.toLocaleString()} simulations...`;
            results.innerHTML = '';
            
            // Use local simulation (Draft FPL - no captain)
            setTimeout(() => {
                runLocalMCSimulation(entryId, gameweek, numSims);
                loading.style.display = 'none';
            }, 10);
        }
        
        // Local Monte Carlo simulation (Draft FPL - NO captain doubling)
        function runLocalMCSimulation(entryId, gameweek, numSims) {
            const squads = importedLeagueData?.squads || {};
            const squadData = squads[String(entryId)] || squads[entryId];
            
            if (!squadData?.picks) {
                document.getElementById('mcResults').innerHTML = '<p style="color: var(--accent-rose);">No squad data found for this team.</p>';
                return;
            }
            
            const players = squadData.picks.map(pick => {
                const player = importedBootstrap?.elements?.find(e => e.id === pick.element);
                const details = importedPlayerDetails?.[pick.element] || {};
                const history = details.history || [];
                const scores = history.filter(h => h.minutes >= 10).map(h => h.total_points);
                
                // Check availability
                const isAvailable = player && (player.status === 'a' || player.status === 'd');
                const chanceOfPlaying = player?.chance_of_playing_next_round;
                
                return {
                    id: pick.element,
                    name: player?.web_name || `Player ${pick.element}`,
                    position: player?.element_type || 3,
                    team: player?.team,
                    scores: scores,
                    avgScore: scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : (player?.form || 3),
                    isAvailable: isAvailable,
                    chanceOfPlaying: chanceOfPlaying
                };
            });
            
            // Run simulations
            const selectionCounts = {};
            const totalPointsList = [];
            const singleGameResults = []; // For single game mode
            
            players.forEach(p => {
                selectionCounts[p.id] = 0;
            });
            
            for (let sim = 0; sim < numSims; sim++) {
                // Sample scores
                const sampledScores = players.map(p => {
                    // Check if player plays (based on availability)
                    let playsGame = p.isAvailable;
                    if (p.chanceOfPlaying !== null && p.chanceOfPlaying < 100) {
                        playsGame = Math.random() * 100 < p.chanceOfPlaying;
                    }
                    
                    return {
                        ...p,
                        sampledScore: playsGame ? sampleScore(p.scores, p.avgScore) : 0,
                        didPlay: playsGame
                    };
                });
                
                // Select best 11
                const lineup = selectBestLineup(sampledScores);
                
                lineup.forEach(p => selectionCounts[p.id]++);
                
                // Total points (NO captain doubling in Draft FPL)
                const total = lineup.reduce((sum, p) => sum + p.sampledScore, 0);
                totalPointsList.push(total);
                
                // Store single game details
                if (numSims === 1) {
                    singleGameResults.push(...sampledScores.map(p => ({
                        ...p,
                        inLineup: lineup.some(l => l.id === p.id)
                    })));
                }
            }
            
            // Build result object
            const playerResults = players.map(p => ({
                player_id: p.id,
                name: p.name,
                position: fplPositionMap[p.position] || '?',
                team: fplTeamIdMap[p.team] || '?',
                selection_rate: selectionCounts[p.id] / numSims,
                expected: p.avgScore,
                games_played: p.scores.length,
                isAvailable: p.isAvailable
            })).sort((a, b) => b.selection_rate - a.selection_rate);
            
            const avgTotal = totalPointsList.reduce((a, b) => a + b, 0) / numSims;
            const variance = totalPointsList.reduce((sum, p) => sum + Math.pow(p - avgTotal, 2), 0) / numSims;
            const stdDev = Math.sqrt(variance);
            
            totalPointsList.sort((a, b) => a - b);
            const ci80Low = numSims > 1 ? totalPointsList[Math.floor(numSims * 0.1)] : totalPointsList[0];
            const ci80High = numSims > 1 ? totalPointsList[Math.floor(numSims * 0.9)] : totalPointsList[0];
            
            const result = {
                entry_name: importedLeagueData.league_entries.find(e => e.entry_id === entryId)?.entry_name || `Team ${entryId}`,
                gameweek: gameweek,
                isSingleGame: numSims === 1,
                singleGameResults: singleGameResults,
                recommendation: {
                    players: playerResults,
                    expected_points: avgTotal,
                    std_dev: stdDev,
                    ci_80: [ci80Low, ci80High],
                    simulations: numSims
                }
            };
            
            renderMCResults(result);
        }
        
        function sampleScore(scores, avgScore) {
            if (scores.length === 0) {
                // Random around average
                return Math.max(0, Math.round(avgScore + (Math.random() - 0.5) * 4));
            }
            
            // Sample from historical scores with some noise
            const baseScore = scores[Math.floor(Math.random() * scores.length)];
            const noise = (Math.random() - 0.5) * 2;
            return Math.max(0, Math.round(baseScore + noise));
        }
        
        function selectBestLineup(players) {
            // Group by position
            const byPos = { 1: [], 2: [], 3: [], 4: [] };
            players.forEach(p => {
                if (byPos[p.position]) byPos[p.position].push(p);
            });
            
            // Sort each position by sampled score
            Object.keys(byPos).forEach(pos => {
                byPos[pos].sort((a, b) => b.sampledScore - a.sampledScore);
            });
            
            // Build lineup (simple: 1 GK, 3-5 DEF, 2-5 MID, 1-3 FWD)
            const lineup = [];
            
            // 1 GK
            if (byPos[1].length > 0) lineup.push(byPos[1][0]);
            
            // At least 3 DEF
            lineup.push(...byPos[2].slice(0, 3));
            
            // At least 2 MID
            lineup.push(...byPos[3].slice(0, 2));
            
            // At least 1 FWD
            lineup.push(...byPos[4].slice(0, 1));
            
            // Fill remaining with best available
            const remaining = 11 - lineup.length;
            const pool = [
                ...byPos[2].slice(3, 5),
                ...byPos[3].slice(2, 5),
                ...byPos[4].slice(1, 3)
            ].filter(p => !lineup.includes(p));
            
            pool.sort((a, b) => b.sampledScore - a.sampledScore);
            lineup.push(...pool.slice(0, remaining));
            
            return lineup.slice(0, 11);
        }
        
        function renderMCResults(result) {
            const rec = result.recommendation || {};
            const players = rec.players || [];
            const isSingleGame = result.isSingleGame;
            
            let html = '';
            
            if (isSingleGame) {
                // Single game mode - show actual sampled scores
                const singleResults = result.singleGameResults || [];
                const lineup = singleResults.filter(p => p.inLineup);
                const bench = singleResults.filter(p => !p.inLineup);
                const totalPts = lineup.reduce((sum, p) => sum + p.sampledScore, 0);
                
                html = `
                    <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(34, 211, 238, 0.1)); border: 2px solid var(--accent-emerald); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                        <div style="text-align: center;">
                            <div style="font-size: 0.9rem; color: var(--text-secondary);">Single Game Simulation</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-emerald);">${totalPts} pts</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">GW${result.gameweek} • ${result.entry_name}</div>
                        </div>
                    </div>
                    
                    <h4 style="margin-bottom: 0.75rem; color: var(--accent-emerald);">⭐ Starting XI</h4>
                    <table class="standings-table" style="width: 100%; margin-bottom: 1.5rem;">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Pos</th>
                                <th>Team</th>
                                <th>Sampled Score</th>
                                <th>Played?</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${lineup.sort((a, b) => b.sampledScore - a.sampledScore).map(p => `
                                <tr style="background: rgba(16, 185, 129, 0.1);">
                                    <td style="font-weight: 600;"><span class="player-link" onclick="showPlayerDetail(${p.id})">${p.name}</span></td>
                                    <td><span class="pos-badge pos-${fplPositionMap[p.position]}">${fplPositionMap[p.position]}</span></td>
                                    <td>${fplTeamIdMap[p.team] || '?'}</td>
                                    <td style="font-size: 1.2rem; font-weight: 600; color: var(--accent-cyan);">${p.sampledScore}</td>
                                    <td>${p.didPlay ? '✅' : '❌'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    
                    <h4 style="margin-bottom: 0.75rem; color: var(--text-muted);">📋 Bench</h4>
                    <table class="standings-table" style="width: 100%;">
                        <tbody>
                            ${bench.sort((a, b) => b.sampledScore - a.sampledScore).map(p => `
                                <tr style="opacity: 0.7;">
                                    <td><span class="player-link" onclick="showPlayerDetail(${p.id})">${p.name}</span></td>
                                    <td><span class="pos-badge pos-${fplPositionMap[p.position]}">${fplPositionMap[p.position]}</span></td>
                                    <td>${fplTeamIdMap[p.team] || '?'}</td>
                                    <td style="color: var(--text-muted);">${p.sampledScore}</td>
                                    <td>${p.didPlay ? '✅' : '❌'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    
                    <div style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.85rem; color: var(--text-secondary);">
                        💡 <strong>Tip:</strong> Run multiple simulations to see which players consistently make the optimal lineup.
                    </div>
                `;
            } else {
                // Multi-simulation mode
                html = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                        <div class="stat-card">
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Expected Points</div>
                            <div style="font-size: 1.8rem; font-weight: 600; color: var(--accent-cyan);">${rec.expected_points?.toFixed(1) || '-'}</div>
                        </div>
                        <div class="stat-card">
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">80% Range</div>
                            <div style="font-size: 1.8rem; font-weight: 600; color: var(--accent-emerald);">
                                ${rec.ci_80 ? `${rec.ci_80[0]?.toFixed(0)}-${rec.ci_80[1]?.toFixed(0)}` : '-'}
                            </div>
                        </div>
                        <div class="stat-card">
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Simulations</div>
                            <div style="font-size: 1.8rem; font-weight: 600;">${rec.simulations?.toLocaleString() || '-'}</div>
                        </div>
                    </div>
                    
                    <h4 style="margin-bottom: 0.75rem; color: var(--text-secondary);">Recommended Starting XI (by selection frequency)</h4>
                    <table class="standings-table" style="width: 100%;">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Pos</th>
                                <th>Team</th>
                                <th>Selection %</th>
                                <th>Avg Pts</th>
                                <th>Games</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${players.slice(0, 15).map((p, i) => `
                                <tr style="${i < 11 ? 'background: rgba(16, 185, 129, 0.1);' : ''}${!p.isAvailable ? 'opacity: 0.5;' : ''}">
                                    <td style="font-weight: ${i < 11 ? '600' : '400'};">
                                        ${i < 11 ? '⭐ ' : ''}<span class="player-link" onclick="showPlayerDetail(${p.id})">${p.name}</span>
                                        ${!p.isAvailable ? ' ⚠️' : ''}
                                    </td>
                                    <td><span class="pos-badge pos-${p.position}">${p.position}</span></td>
                                    <td>${p.team}</td>
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <div style="flex: 1; height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
                                                <div style="width: ${(p.selection_rate * 100).toFixed(0)}%; height: 100%; background: var(--accent-cyan);"></div>
                                            </div>
                                            <span style="min-width: 45px; text-align: right;">${(p.selection_rate * 100).toFixed(1)}%</span>
                                        </div>
                                    </td>
                                    <td>${p.expected?.toFixed(1) || '-'}</td>
                                    <td style="color: var(--text-muted);">${p.games_played || '-'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }
            
            document.getElementById('mcResults').innerHTML = html;
        }
        
        // Initialize MC team selector when predictions tab loads
        const originalRenderPredictionsTab = typeof renderPredictionsTab === 'function' ? renderPredictionsTab : null;
        if (originalRenderPredictionsTab) {
            const wrappedRenderPredictionsTab = async function() {
                await originalRenderPredictionsTab.apply(this, arguments);
                populateMCTeamSelect();
            };
            // Note: We're not reassigning here to avoid infinite loop, 
            // populateMCTeamSelect will be called separately
        }

        // ========================================
        // PREDICTED LINEUPS FUNCTIONS
        // ========================================

        async function loadPredictedLineups() {
            const select = document.getElementById('lineupsGwSelect');
            const gameweek = parseInt(select.value);
            
            if (!gameweek) {
                showLineupsStatus('Please select a gameweek', 'warning');
                return;
            }
            
            showLineupsStatus(`⏳ Loading predictions for GW${gameweek}...`, 'info');
            
            try {
                const response = await fetch(`http://localhost:5000/api/predicted-lineups/${gameweek}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data.predictions || data.predictions.length === 0) {
                    showLineupsStatus(
                        `⚠️ No predictions available for GW${gameweek}.<br>` +
                        `<span style="font-size: 0.9rem;">Click "🔄 Refresh Data" to fetch the latest lineups (takes ~45 seconds)</span>`, 
                        'warning'
                    );
                    renderEmptyLineups();
                    return;
                }
                
                const lastUpdated = data.last_updated ? 
                    ` (Updated: ${new Date(data.last_updated).toLocaleString()})` : '';
                
                // Calculate unique sources
                const sourcesSet = new Set();
                data.predictions.forEach(p => {
                    if (p.sources_data) {
                        try {
                            const sources = JSON.parse(p.sources_data);
                            sources.forEach(s => sourcesSet.add(s.name));
                        } catch (e) {}
                    }
                });
                const sourceCount = sourcesSet.size;
                const sourceInfo = sourceCount > 0 ? ` from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}` : '';
                const unmatchedInfo = data.total_unmatched > 0 ? ` (${data.total_unmatched} unmatched)` : '';
                
                showLineupsStatus(
                    `✅ Loaded ${data.predictions.length} player predictions for GW${gameweek}${sourceInfo}${unmatchedInfo}${lastUpdated}`,
                    'success'
                );
                
                renderLineups(data, gameweek);
                
            } catch (error) {
                console.error('Error loading lineup predictions:', error);
                showLineupsStatus(`❌ Error loading predictions: ${error.message}`, 'error');
                renderEmptyLineups();
            }
        }

        async function refreshPredictedLineups() {
            const select = document.getElementById('lineupsGwSelect');
            const gameweek = parseInt(select.value);
            
            if (!gameweek) {
                showLineupsStatus('Please select a gameweek', 'warning');
                return;
            }
            
            // Show loading state with animation
            const loadingDots = ['⚽', '⚽⚽', '⚽⚽⚽'];
            let dotIndex = 0;
            showLineupsStatus(`🔄 Fetching predicted lineups for GW${gameweek}... ${loadingDots[0]}`, 'info');
            renderLoadingLineups();
            
            // Animate loading dots
            const loadingInterval = setInterval(() => {
                dotIndex = (dotIndex + 1) % loadingDots.length;
                showLineupsStatus(
                    `🔄 Fetching lineups from RotoWire... ${loadingDots[dotIndex]}<br>` +
                    `<span style="font-size: 0.9rem; opacity: 0.8;">This takes 40-50 seconds. Please wait...</span>`,
                    'info'
                );
            }, 1000);
            
            try {
                // Trigger the refresh (starts background scraping)
                const response = await fetch(`http://localhost:5000/api/predicted-lineups/refresh/${gameweek}`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Poll every 3 seconds to check if data is ready
                let attempts = 0;
                const maxAttempts = 25; // 75 seconds max
                let lastCount = 0;
                
                const checkData = async () => {
                    attempts++;
                    
                    try {
                        const dataResponse = await fetch(`http://localhost:5000/api/predicted-lineups/${gameweek}`);
                        const data = await dataResponse.json();
                        
                        if (data.predictions && data.predictions.length > lastCount) {
                            // New data available!
                            clearInterval(loadingInterval);
                            lastCount = data.predictions.length;
                            
                            // Calculate unique sources
                            const sourcesSet = new Set();
                            data.predictions.forEach(p => {
                                if (p.sources_data) {
                                    try {
                                        const sources = JSON.parse(p.sources_data);
                                        sources.forEach(s => sourcesSet.add(s.name));
                                    } catch (e) {}
                                }
                            });
                            const sourceCount = sourcesSet.size;
                            const sourceInfo = sourceCount > 0 ? ` from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}` : '';
                            const unmatchedInfo = data.total_unmatched > 0 ? ` (${data.total_unmatched} unmatched)` : '';
                            
                            showLineupsStatus(
                                `✅ Successfully loaded ${data.predictions.length} player predictions for GW${gameweek}${sourceInfo}${unmatchedInfo}!`,
                                'success'
                            );
                            
                            renderLineups(data, gameweek);
                            return true;
                        }
                        
                        if (attempts < maxAttempts) {
                            // Keep polling
                            setTimeout(checkData, 3000);
                        } else {
                            // Timeout
                            clearInterval(loadingInterval);
                            showLineupsStatus(
                                `⏱️ Request took longer than expected. Click "Load Predictions" to check if data is ready.`,
                                'warning'
                            );
                            renderEmptyLineups();
                        }
                    } catch (error) {
                        console.error('Error checking data:', error);
                        if (attempts < maxAttempts) {
                            setTimeout(checkData, 3000);
                        }
                    }
                };
                
                // Start polling after 5 seconds (give scraping time to start)
                setTimeout(checkData, 5000);
                
            } catch (error) {
                clearInterval(loadingInterval);
                console.error('Error refreshing predictions:', error);
                showLineupsStatus(`❌ Error refreshing: ${error.message}`, 'error');
                renderEmptyLineups();
            }
        }
        
        function renderLoadingLineups() {
            const grid = document.getElementById('lineupsGrid');
            if (!grid) return;
            
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 3rem;">
                    <div style="font-size: 4rem; margin-bottom: 1rem; animation: pulse 2s ease-in-out infinite;">⚽</div>
                    <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--accent-cyan);">Fetching Lineup Predictions...</div>
                    <div style="color: var(--text-secondary); margin-bottom: 1rem;">Scraping RotoWire for the latest lineups</div>
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem;">
                        <div style="width: 12px; height: 12px; background: var(--accent-cyan); border-radius: 50%; animation: bounce 1.4s ease-in-out infinite;"></div>
                        <div style="width: 12px; height: 12px; background: var(--accent-emerald); border-radius: 50%; animation: bounce 1.4s ease-in-out 0.2s infinite;"></div>
                        <div style="width: 12px; height: 12px; background: var(--accent-violet); border-radius: 50%; animation: bounce 1.4s ease-in-out 0.4s infinite;"></div>
                    </div>
                </div>
            `;
        }

        function renderLineups(data, gameweek) {
            const predictions = data.predictions || data;  // Handle both array and object response
            const unmatchedPlayers = data.unmatched_players || [];
            
            console.log('[Lineups] Rendering', predictions.length, 'predictions + ', unmatchedPlayers.length, 'unmatched for GW', gameweek);
            
            const grid = document.getElementById('lineupsGrid');
            if (!grid) {
                console.error('[Lineups] Grid element not found!');
                return;
            }
            
            if (!predictions || predictions.length === 0) {
                console.warn('[Lineups] No predictions to render');
                renderEmptyLineups();
                return;
            }
            
            // Group predictions by team
            const teamGroups = {};
            predictions.forEach(pred => {
                const teamId = pred.team_id;
                if (!teamGroups[teamId]) {
                    teamGroups[teamId] = {matched: [], unmatched: []};
                }
                teamGroups[teamId].matched.push(pred);
            });
            
            // Group unmatched players by team code
            unmatchedPlayers.forEach(player => {
                // Find team by code - we need to match team_code to team_id
                // For now, add to a special "unmatched" group per team code
                const teamCode = player.team_code || 'UNK';
                // Try to find the team ID from matched players
                let foundTeamId = null;
                for (const [teamId, group] of Object.entries(teamGroups)) {
                    if (group.matched.length > 0 && group.matched[0].team_name === teamCode) {
                        foundTeamId = teamId;
                        break;
                    }
                }
                if (foundTeamId) {
                    if (!teamGroups[foundTeamId].unmatched) {
                        teamGroups[foundTeamId].unmatched = [];
                    }
                    teamGroups[foundTeamId].unmatched.push(player);
                }
            });
            
            console.log('[Lineups] Grouped into', Object.keys(teamGroups).length, 'teams');
            
            // Sort teams by ID
            const sortedTeams = Object.keys(teamGroups).sort((a, b) => parseInt(a) - parseInt(b));
            
            // Render team cards
            try {
                const html = sortedTeams.map(teamId => renderTeamCard(teamId, teamGroups[teamId].matched, teamGroups[teamId].unmatched || [])).join('');
                grid.innerHTML = html;
                console.log('[Lineups] ✅ Rendered successfully!');
            } catch (error) {
                console.error('[Lineups] Render error:', error);
                showLineupsStatus(`❌ Error rendering lineups: ${error.message}`, 'error');
            }
        }

        function renderTeamCard(teamId, matchedPlayers, unmatchedPlayers = []) {
            // Get team name from first player (all players in group have same team)
            const firstPlayer = matchedPlayers[0];
            const teamCode = firstPlayer?.team_name || 'TBD';
            const teamName = teamCode; // Use short name as display name
            
            // Sort matched players by start probability
            matchedPlayers.sort((a, b) => b.start_probability - a.start_probability);
            
            // Categorize matched players
            const starters = matchedPlayers.filter(p => p.start_probability >= 0.7 && !p.injured && !p.suspended);
            const doubtful = matchedPlayers.filter(p => 
                (p.start_probability >= 0.3 && p.start_probability < 0.7) || p.doubtful
            );
            const out = matchedPlayers.filter(p => p.injured || p.suspended || p.start_probability < 0.3);
            
            // Lineup validation
            const totalStarters = starters.length;
            const totalWithUnmatched = totalStarters + unmatchedPlayers.length;
            let validationWarning = '';
            
            if (totalWithUnmatched < 11) {
                validationWarning = `<div style="background: rgba(245, 158, 11, 0.1); border-left: 3px solid var(--accent-amber); padding: 0.75rem; margin-bottom: 1rem; border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--accent-amber); margin-bottom: 0.25rem;">⚠️ Incomplete Lineup</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">Only ${totalWithUnmatched}/11 starters predicted${unmatchedPlayers.length > 0 ? ` (${unmatchedPlayers.length} unmatched)` : ''}</div>
                </div>`;
            } else if (totalWithUnmatched > 11) {
                validationWarning = `<div style="background: rgba(245, 158, 11, 0.1); border-left: 3px solid var(--accent-amber); padding: 0.75rem; margin-bottom: 1rem; border-radius: 6px;">
                    <div style="font-weight: 600; color: var(--accent-amber); margin-bottom: 0.25rem;">⚠️ Position Conflict</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary)">${totalWithUnmatched} players predicted to start - check probabilities for rotations</div>
                </div>`;
            }
            
            return `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden;">
                    <div style="background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet)); padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; font-weight: 600; font-size: 1.1rem;">
                                <span style="background: rgba(255, 255, 255, 0.2); padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.85rem; font-weight: 700;">${teamCode}</span>
                                <span>${teamName}</span>
                            </div>
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                ${starters.length > 0 ? `<span style="padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: rgba(16, 185, 129, 0.3);">${starters.length} Starting</span>` : ''}
                                ${doubtful.length > 0 ? `<span style="padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: rgba(245, 158, 11, 0.3);">${doubtful.length} Doubtful</span>` : ''}
                                ${out.length > 0 ? `<span style="padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: rgba(244, 67, 54, 0.3);">${out.length} Out</span>` : ''}
                                ${unmatchedPlayers.length > 0 ? `<span style="padding: 0.25rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: rgba(148, 163, 184, 0.3);">${unmatchedPlayers.length} Unknown</span>` : ''}
                            </div>
                        </div>
                    </div>
                    <div style="padding: 1rem;">
                        ${validationWarning}
                        ${starters.length > 0 ? `
                            <div style="margin-bottom: 1rem;">
                                <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color);">✅ Expected Starters</div>
                                ${starters.map(p => renderPlayerRow(p, false)).join('')}
                            </div>
                        ` : ''}
                        ${doubtful.length > 0 ? `
                            <div style="margin-bottom: 1rem;">
                                <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color);">⚠️ Doubtful</div>
                                ${doubtful.map(p => renderPlayerRow(p, false)).join('')}
                            </div>
                        ` : ''}
                        ${unmatchedPlayers.length > 0 ? `
                            <div style="margin-bottom: 1rem;">
                                <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color);">❓ Unmatched Players (Not in DB)</div>
                                ${unmatchedPlayers.map(p => renderPlayerRow(p, true)).join('')}
                            </div>
                        ` : ''}
                        ${out.length > 0 ? `
                            <div>
                                <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color);">❌ Unlikely / Injured</div>
                                ${out.map(p => renderPlayerRow(p, false)).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderPlayerRow(player, isUnmatched = false) {
            const probability = isUnmatched ? 0 : Math.round(player.start_probability * 100);
            const statusBadge = getStatusBadge(player);
            const barColor = probability >= 80 ? '#10b981' : probability >= 50 ? '#f59e0b' : '#ef4444';
            
            // Player name - show scraped name for unmatched, web_name for matched
            const playerName = isUnmatched ? 
                player.scraped_name || player.player_name || 'Unknown' : 
                player.web_name || `Player ${player.player_id}`;
            
            // Validation note (if present)
            const validationNote = player.validation_note || '';
            const noteTooltip = validationNote ? ` title="${validationNote}"` : '';
            
            // Source count badge
            const sourceCount = player.sources_count || player.occurrences || 0;
            const sourceBadge = sourceCount > 0 ? 
                `<span style="padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: rgba(34, 211, 238, 0.2); color: var(--accent-cyan);" title="${sourceCount} source${sourceCount !== 1 ? 's' : ''}">📊 ${sourceCount}</span>` : '';
            
            // FPL Club ownership badge
            const fplClub = player.fpl_club || null;
            const fplBadge = fplClub ? 
                `<span style="padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 700; background: rgba(139, 92, 246, 0.2); color: var(--accent-violet); text-transform: uppercase;" title="Owned by ${player.fpl_club_name || fplClub}">${fplClub}</span>` :
                `<span style="padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: rgba(16, 185, 129, 0.2); color: var(--accent-emerald);" title="Available">FREE</span>`;
            
            // Unmatched player styling
            const unmatchedStyle = isUnmatched ? 
                'opacity: 0.5; background: rgba(100, 116, 139, 0.1);' : '';
            const unmatchedBadge = isUnmatched ? 
                `<span style="padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: rgba(148, 163, 184, 0.2); color: var(--text-muted);" title="Not found in FPL database">❓ Unknown</span>` : '';
            
            // Validation warning badge for rotation risk
            const rotationBadge = validationNote && (validationNote.includes('rotation') || validationNote.includes('competing')) ? 
                `<span style="padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: rgba(245, 158, 11, 0.2); color: var(--accent-amber);" title="${validationNote}">🔄 Rotation</span>` : '';
            
            return `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.05); ${unmatchedStyle}"${noteTooltip}>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                        <span style="font-weight: 500; color: var(--text-primary);">${playerName}</span>
                        ${fplBadge}
                        ${sourceBadge}
                        ${statusBadge}
                        ${rotationBadge}
                        ${unmatchedBadge}
                    </div>
                    ${!isUnmatched ? `
                        <div style="display: flex; align-items: center; gap: 0.75rem; min-width: 140px;">
                            <div style="flex: 1; height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
                                <div style="height: 100%; width: ${probability}%; background: linear-gradient(90deg, ${barColor}, ${barColor}dd); border-radius: 4px; transition: width 0.5s ease;"></div>
                            </div>
                            <span style="font-weight: 600; font-size: 0.85rem; color: var(--text-secondary); min-width: 35px; text-align: right;">${probability}%</span>
                        </div>
                    ` : `
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-style: italic;">Needs matching</span>
                    `}
                </div>
            `;
        }

        function getStatusBadge(player) {
            if (player.injured) {
                return `<span style="padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: rgba(244, 67, 54, 0.2); color: #f87171;" title="${player.injury_details || 'Injured'}">🔴 Injured</span>`;
            }
            if (player.suspended) {
                return `<span style="padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: rgba(244, 67, 54, 0.2); color: #f87171;">🔴 Suspended</span>`;
            }
            if (player.doubtful) {
                return `<span style="padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; background: rgba(245, 158, 11, 0.2); color: #fbbf24;" title="${player.injury_details || 'Doubtful'}">🟡 Doubtful</span>`;
            }
            return '';
        }

        function renderEmptyLineups() {
            const grid = document.getElementById('lineupsGrid');
            if (!grid) return;
            
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 3rem; color: var(--text-muted);">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">📋</div>
                    <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">No lineup predictions available</div>
                    <div>Click "Refresh Data" to fetch the latest predicted lineups</div>
                </div>
            `;
        }

        function showLineupsStatus(message, type = 'info') {
            const statusDiv = document.getElementById('lineupsStatus');
            if (!statusDiv) return;
            
            const colors = {
                'info': 'var(--accent-cyan)',
                'success': 'var(--accent-emerald)',
                'warning': 'var(--accent-amber)',
                'error': 'var(--accent-rose)'
            };
            
            const color = colors[type] || colors.info;
            
            statusDiv.innerHTML = `
                <div style="padding: 1rem; background: ${color}22; border-left: 3px solid ${color}; border-radius: 8px; color: var(--text-primary);">
                    ${message}
                </div>
            `;
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }

    </script>
    
    <!-- Player Comparison Modal (Global - outside tabs) -->
    <div id="playerCompareModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 1400px; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; position: sticky; top: 0; background: var(--bg-secondary); padding: 1rem; margin: -1.5rem -1.5rem 1.5rem -1.5rem; border-bottom: 1px solid var(--border-color); z-index: 10;">
                <h3 style="color: var(--accent-cyan); margin: 0;">🔍 Player Comparison (up to 4)</h3>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <select id="compareGW" onchange="refreshComparison()" style="padding: 0.4rem 0.75rem; font-size: 0.85rem;">
                        <!-- Populated dynamically -->
                    </select>
                    <span class="close-modal" onclick="closeCompareModal()" style="font-size: 1.5rem; cursor: pointer;">&times;</span>
                </div>
            </div>
            
            <!-- Player Search Section - 4 slots -->
            <div id="compareSearchSection" style="margin-bottom: 1.5rem;">
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem;">
                    <div id="compareSlot1" class="compare-slot">
                        <div class="compare-search-container">
                            <input type="text" id="compareSearch1" placeholder="Player 1..." 
                                   oninput="filterCompareSearch(1)" onfocus="showCompareDropdown(1)"
                                   style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 2px solid var(--accent-cyan); border-radius: 8px; color: var(--text-primary); font-size: 0.85rem;">
                            <div id="compareDropdown1" class="compare-dropdown" style="display: none;"></div>
                        </div>
                        <div id="comparePlayer1" class="compare-player-card" style="display: none;"></div>
                    </div>
                    <div id="compareSlot2" class="compare-slot">
                        <div class="compare-search-container">
                            <input type="text" id="compareSearch2" placeholder="Player 2..." 
                                   oninput="filterCompareSearch(2)" onfocus="showCompareDropdown(2)"
                                   style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 2px solid var(--accent-rose); border-radius: 8px; color: var(--text-primary); font-size: 0.85rem;">
                            <div id="compareDropdown2" class="compare-dropdown" style="display: none;"></div>
                        </div>
                        <div id="comparePlayer2" class="compare-player-card" style="display: none;"></div>
                    </div>
                    <div id="compareSlot3" class="compare-slot">
                        <div class="compare-search-container">
                            <input type="text" id="compareSearch3" placeholder="Player 3..." 
                                   oninput="filterCompareSearch(3)" onfocus="showCompareDropdown(3)"
                                   style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 2px solid var(--accent-emerald); border-radius: 8px; color: var(--text-primary); font-size: 0.85rem;">
                            <div id="compareDropdown3" class="compare-dropdown" style="display: none;"></div>
                        </div>
                        <div id="comparePlayer3" class="compare-player-card" style="display: none;"></div>
                    </div>
                    <div id="compareSlot4" class="compare-slot">
                        <div class="compare-search-container">
                            <input type="text" id="compareSearch4" placeholder="Player 4..." 
                                   oninput="filterCompareSearch(4)" onfocus="showCompareDropdown(4)"
                                   style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 2px solid var(--accent-amber); border-radius: 8px; color: var(--text-primary); font-size: 0.85rem;">
                            <div id="compareDropdown4" class="compare-dropdown" style="display: none;"></div>
                        </div>
                        <div id="comparePlayer4" class="compare-player-card" style="display: none;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Comparison Content -->
            <div id="compareContent" style="display: none;">
                <!-- Horizontal stat-by-stat comparison table -->
                <div id="compareGrid" style="overflow-x: auto;">
                    <!-- Table rendered here -->
                </div>
                
                <!-- Side-by-side history -->
                <div id="compareHistory" class="stat-card" style="margin-top: 1.5rem;">
                    <h4 style="color: var(--accent-cyan); margin-bottom: 1rem;">📊 Gameweek History Comparison</h4>
                    <div id="compareHistoryTable" style="overflow-x: auto;"></div>
                </div>
            </div>
            
            <!-- Empty state -->
            <div id="compareEmptyState" style="text-align: center; padding: 3rem; color: var(--text-muted);">
                <div style="font-size: 3rem; margin-bottom: 1rem;">👥</div>
                <p>Search and select players above to compare their stats</p>
            </div>
        </div>
    </div>
</body>
</html>

